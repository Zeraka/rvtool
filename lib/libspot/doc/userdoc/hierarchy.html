<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-09-27 Fri 20:05 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Exploring the temporal hierarchy of Manna &amp; Pnueli</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="root" />
<meta name="description" content="Spot command-line tools for exploring the temporal hierarchy of Manna &amp; Pnueli"
 />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="spot.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="tools.html"> UP </a>
 |
 <a accesskey="H" href="index.html"> HOME </a>
</div><div id="content">
<h1 class="title">Exploring the temporal hierarchy of Manna &amp; Pnueli</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org509e4ea">Description of the classes</a></li>
<li><a href="#orgf2a860c">Deciding class membership</a></li>
<li><a href="#orga703eb1">Deciding classes membership syntactically</a></li>
<li><a href="#orgb365805">What to do with each class?</a>
<ul>
<li><a href="#orga93689e">Obligation</a></li>
<li><a href="#org1f6097b">Guarantee</a></li>
<li><a href="#safety">Safety</a></li>
<li><a href="#org1744a8a">Recurrence</a></li>
<li><a href="#org4fcf2d8">Persistence</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div class="figure">
<p><object type="image/svg+xml" data="spot2.svg" class="org-svg" id="spotlogo">
Sorry, your browser does not support SVG.</object>
</p>
</div>
<p>
<i>A hierarchy of temporal properties</i> was defined by Manna &amp; Pnueli in
their <a href="ftp://www-cs.stanford.edu/cs/theory/amir/hierarchy.ps">PODC'90 paper</a>.
</p>

<p>
This hierarchy relates "properties" (i.e., omega-regular languages) to
structural properties of the automata that can recognize them.
</p>

<div id="outline-container-org509e4ea" class="outline-2">
<h2 id="org509e4ea">Description of the classes</h2>
<div class="outline-text-2" id="text-org509e4ea">
<p>
The hierarchy is built from the classes pictured in the following
diagram, where each class includes everything below it. For instance,
the <i>recurrence</i> class includes the <i>obligation</i> class which also
includes the <i>safety</i> and <i>guarantee</i> classes, as well as the unnamed
intersection of <i>safety</i> and <i>guarantee</i> (<code>B</code> in the picture).
</p>


<div class="figure">
<p><object type="image/svg+xml" data="hierarchy.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

<p>
Forget about the LTL properties and about the red letters displayed in
this picture for a moment.
</p>

<ul class="org-ul">
<li>The <i>reactivity</i> class represents all possible omega-regular
languages, i.e., all languages that can be recognized by a
non-deterministic Büchi automaton.</li>

<li>The <i>recurrence</i> subclass contains all properties that can be
recognized by a deterministic Büchi automaton.</li>

<li>The dual class, <i>persistence</i> properties, are those that can be
recognized by a weak Büchi automaton (i.e., in each SCC either all
states are accepting, or all states are rejecting).</li>

<li>The intersection of <i>recurrence</i> and <i>persistence</i> classes form the
<i>obligation</i> properties: any of those can be recognized by a weak
and deterministic Büchi automaton.</li>

<li><i>Guarantee</i> properties are a subclass of <i>obligation</i> properties
that can be recognized by terminal Büchi automata (i.e., upon
reaching an accepting state, any suffix will be accepted).</li>

<li><i>Safety</i> properties are the dual of <i>Guarantee</i> properties: they can
be recognized by ω-automata that accept all their runs (i.e., the
acceptance condition is "true").  Note that since these automata are
not necessary complete, it is still possible for some words not to
be accepted.  If we interpret the ω-automata with "true" acceptance
as finite automata with all states marked as final, we obtain
monitors, i.e., finite automata that recognize all finite prefixes
that can be extended into valid ω-words.</li>

<li>Finally, at the very bottom is an unnamed class that contains
<i>Safety</i> properties that are also <i>Guarantee</i> properties: those are
properties that can be represented by monitors in which the only
cycles are self-loops labeled by true.</li>
</ul>

<p>
The "LTL normal forms" displayed in the above figure help to visualize
the type of LTL formulas contained in each of these class.  But note
that (1) this hierarchy applies to all omega-regular properties, not
just LTL-defined properties, and (2) the LTL expression displayed in
the figure are actually normal forms in the sense that if an
LTL-defined property belongs to the given class, then there exists an
equivalent LTL property under the stated form, were \(p\), \(q\), \(p_i\)
and \(q_i\) are subexpressions that may use only Boolean operators, the
next operator (\(\mathsf{X}\)), and past-LTL operators (which are not
supported by Spot).  The combination of these allowed operators only
makes it possible to express constraints on finite prefixes.
</p>

<p>
<i>Obligations</i> can be thought of as Boolean combinations of <i>safety</i>
and <i>guarentee</i> properties, while <i>reactivity</i> properties are Boolean
combinations of <i>recurrence</i> and <i>persistence</i> properties.  The
negation of a <i>safety</i> property is a <i>guarantee</i> property (and
vice-versa), and the same duality hold for <i>persistence</i> and
<i>recurrence</i> properties.
</p>

<p>
The red letters in each of these seven classes are keys used in
Spot to denote the classes.
</p>
</div>
</div>

<div id="outline-container-orgf2a860c" class="outline-2">
<h2 id="orgf2a860c">Deciding class membership</h2>
<div class="outline-text-2" id="text-orgf2a860c">
<p>
The <code>--format=%h</code> option can be used to display the "class key" of the
most precise class to which a formula belongs.
</p>

<div class="org-src-container">
<pre class="src src-sh">ltlfilt -f <span class="org-string">'a U b'</span> --format=%h
</pre>
</div>
<pre class="example">
G

</pre>

<p>
If you find hard to remember the class name corresponding to the class
keys, you can request verbose output with <code>%[v]h</code>:
</p>

<div class="org-src-container">
<pre class="src src-sh">ltlfilt -f <span class="org-string">'a U b'</span> --format=<span class="org-string">'%[v]h'</span>
</pre>
</div>
<pre class="example">
guarantee

</pre>

<p>
But actually any <i>guarantee</i> property is also an <i>obligation</i>, a
<i>recurrence</i>, a <i>persistence</i>, and a <i>reactivity</i> property.  You can
get the complete list of classes using <code>%[w]h</code> or <code>%[vw]h</code>:
</p>

<div class="org-src-container">
<pre class="src src-sh">ltlfilt -f <span class="org-string">'a U b'</span> --format=<span class="org-string">'%[w]h = %[vw]h'</span>
</pre>
</div>
<pre class="example">
GOPRT = guarantee obligation persistence recurrence reactivity

</pre>

<p>
This <code>--format</code> option is also supported by <code>randltl</code>, <code>genltl</code>, and
<code>ltlgrind</code>.  So for instance if you want to classify the 55 LTL
patterns of <a href="http://patterns.projects.cs.ksu.edu/documentation/patterns/ltl.shtml">Dwyers et al. (FMSP'98)</a> using this hierarchy, try:
</p>

<div class="org-src-container">
<pre class="src src-sh">genltl --dac-patterns --format=<span class="org-string">'%[v]h'</span> | sort | uniq -c
</pre>
</div>

<pre class="example">
 1 guarantee
 2 obligation
 1 persistence
 2 reactivity
12 recurrence
37 safety

</pre>

<p>
In this output, the most precise class is given for each formula, and
the count of formulas for each subclass is given.  We have to remember
that the recurrence class also includes obligation, safety, and
guarantee properties.  In this list, there are no formulas that belong
to the intersection of the <i>guarantee</i> and <i>safety</i> classes (it would
have been listed as <code>guarantee safety</code>).
</p>

<p>
From this list, only 3 formulas are not recurrence properties (i.e.,
not recognized by deterministic Büchi automata): one of them is a
persistence formula, the other two cannot be classified better than in
the <i>reactivity</i> class.  Let's pretend we are interested in those
three non-recurrence formulas, we can use <code>ltlfilt -v --recurrence</code> to
remove all recurrence properties from the <code>genltl --dac-pattern</code>
output:
</p>

<div class="org-src-container">
<pre class="src src-sh">genltl --dac-patterns |
  ltlfilt -v --recurrence --format=<span class="org-string">'%[v]h, %f'</span>
</pre>
</div>

<pre class="example">
persistence, G!p0 | F(p0 &amp; (!p1 W p2))
reactivity, G(p0 -&gt; ((p1 -&gt; (!p2 U (!p2 &amp; p3 &amp; X(!p2 U p4)))) U (p2 | G(p1 -&gt; (p3 &amp; XFp4)))))
reactivity, G(p0 -&gt; ((p1 -&gt; (!p2 U (!p2 &amp; p3 &amp; !p4 &amp; X((!p2 &amp; !p4) U p5)))) U (p2 | G(p1 -&gt; (p3 &amp; !p4 &amp; X(!p4 U p5))))))

</pre>

<p>
Similar filtering options exist for other classes.  Since these tests
are automata-based, they work with PSL formulas as well. For instance,
here is how to generate 10 random recurrence PSL formulas that are
not LTL formulas, and that are not obligations:
</p>

<div class="org-src-container">
<pre class="src src-sh">randltl --psl -n -1 a b |
   ltlfilt -v --ltl |
   ltlfilt -v --obligation |
   ltlfilt --recurrence -n10
</pre>
</div>
<pre class="example">
{[*]}&lt;&gt;-&gt; (!a &amp; XG!Ga)
F({[*2][*]}[]-&gt; (b M 1))
{[*0] | b[*]}&lt;&gt;-&gt; GFb
F{1:{{a | !b} | [*0]}} W (a &amp; b)
X{b | [*0]} &amp; GF!b
{a[*]}[]-&gt; !Gb
!({{[*] &amp; b[*]}[:*1..2]}&lt;&gt;-&gt; F(Ga R b))
a -&gt; G(G{{!{a xor b}}[*]} -&gt; Gb)
({[*]}[]-&gt; a) &amp; GFb
XXGF!XX({[*]}[]-&gt; a)
</pre>

<p>
Note that the order of the <code>ltlfilt</code> filters could be changed provided
the <code>-n10</code> stays at the end.  For instance we could first keep all
recurrence before removing obligations and then removing LTL formulas.
The order given above actually starts with the easier checks first and
keep the most complex tests at the end of the pipeline so they are
applied to fewer formulas.  Testing whether a formula is an LTL
formula is very cheap, testing if a formula is an obligation is harder
(it may involves a translation to automata and a poweset
construction), and testing whether a formula is a recurrence is the
most costly procedure (it involves a translation as well, plus
conversion to deterministic Rabin automata, and an attempt to convert
the automaton back to deterministic Büchi).  As a rule of thumb,
testing classes that are lower in the hierarchy is cheaper.
</p>

<p>
Since option <code>-o</code> (for specifying output file) also honors <code>%</code>-escape
sequences, we can use it with <code>%h</code> to split a list of formulas in 7
possible files.  Here is a generation of 200 random LTL formulas
binned into aptly named files:
</p>

<div class="org-src-container">
<pre class="src src-sh">randltl -n 200 a b -o random-%h.ltl
wc -l random-?.ltl
</pre>
</div>

<pre class="example">
 45 random-B.ltl
 49 random-G.ltl
 12 random-O.ltl
 21 random-P.ltl
 18 random-R.ltl
 46 random-S.ltl
  9 random-T.ltl
200 total

</pre>
</div>
</div>

<div id="outline-container-orga703eb1" class="outline-2">
<h2 id="orga703eb1">Deciding classes membership syntactically</h2>
<div class="outline-text-2" id="text-orga703eb1">
<p>
LTL formulas can also be classified into related classes which we
shall call <i>syntactic-safety</i>, <i>syntactic-guarantee</i>, etc.  See <a href="https://spot.lrde.epita.fr/tl.pdf">tl.pdf</a>
for the grammar of each syntactic class.  Any LTL-definable property
of class C can be defined by an LTL formulas in class syntactic-C, but
an LTL formula can describe a property of class C even if that formula
is not in class syntactic-C (we just know that some equivalent formula
is in class syntactic-C).
</p>

<p>
<code>ltlfilt</code> has options like <code>--syntactic-guarantee</code>,
<code>--syntactic-persistence</code>, etc. to match formulas from this classes.
</p>

<p>
Here is how to generate 10 random LTL formulas that describe safety
properties but that are not in the syntactic-safety class:
</p>

<div class="org-src-container">
<pre class="src src-sh">randltl -n-1 a b |
  ltlfilt -v --syntactic-safety |
  ltlfilt --safety -n10
</pre>
</div>

<pre class="example">
F!(!b &lt;-&gt; FGb)
!Fb xor G((b xor (Xa M b)) U b)
a W F(a -&gt; b)
((0 R Xa) R a) -&gt; Fa
X(Xb &amp; (!Ga R Ga))
(1 U b) | F(Fb W (a &lt;-&gt; FXa))
(a M 1) | (!a W a)
(G!a W ((b M 1) -&gt; Fa)) -&gt; !a
!a -&gt; ((a xor !GFa) W 0)
b M Gb
</pre>

<p>
Since all those formulas describe safety properties, an exercise would
be to suggest equivalent formulas that are in the syntactic-safety
fragment.  For instance <code>b M Gb</code> can be rewritten as just <code>Gb</code>, which
belongs to this fragment.  In this particular case, <code>ltlfilt
--simplify</code> recognizes this:
</p>

<div class="org-src-container">
<pre class="src src-sh">ltlfilt --simplify -f <span class="org-string">'b M Gb'</span>
</pre>
</div>
<pre class="example">
Gb

</pre>

<p>
However in the general case Spot is not able to provide the equivalent
formula from the appropriate syntactic class.
</p>
</div>
</div>

<div id="outline-container-orgb365805" class="outline-2">
<h2 id="orgb365805">What to do with each class?</h2>
<div class="outline-text-2" id="text-orgb365805">
</div>
<div id="outline-container-orga93689e" class="outline-3">
<h3 id="orga93689e">Obligation</h3>
<div class="outline-text-3" id="text-orga93689e">
<p>
Spot implements algorithms from Löding (<a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.24.6718"><i>Efficient minimization of
deterministic weak ω-automata</i>, IPL 2001</a>) and Dax et al. (<a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.83.2081"><i>Mechanizing
the powerset constructions for restricted classes of ω-automata</i>,
ATVA'07</a>) in order to detect obligation properties, and produce minimal
weak deterministic automata for them.
</p>

<p>
When running <code>ltl2tgba -D</code> on a formula that represents an
obligation property, you are guaranteed to obtain a minimal (in the
number of states) deterministic weak Büchi automaton that recognizes
it.  Note that since the <i>obligation</i> class includes the <i>safety</i> and
<i>guarantee</i> classes, minimal deterministic automata will also be
produced for those classes.  Dax et al.'s determinization of obligation
properties combined with Löding's minimization renders obsolete
older algorithms (and tools) that produced minimal deterministic
automata but only for the subclasses of <i>safety</i> or <i>guarantee</i>.
</p>

<p>
If <code>ltl2tgba</code> is run without <code>-D</code> (but still with the default <code>--high</code>
optimization level), the minimal weak deterministic automaton will
only be output if it is smaller than the non-deterministic automaton
the translator could produce before determinization and minimization.
</p>

<p>
For instance <code>Fa R b</code> is an obligation:
</p>

<div class="org-src-container">
<pre class="src src-sh">ltlfilt -f <span class="org-string">'Fa R b'</span> --format=<span class="org-string">'%[v]h'</span>
</pre>
</div>

<pre class="example">
obligation

</pre>

<p>
If we translate it without <code>-D</code> we get a 3-state non-deterministic
automaton (here we use <code>autfilt --highlight-nondet</code> to show where the
non-determinism occurs):
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org7c77a41">ltl2tgba <span class="org-string">'Fa R b'</span> | autfilt --highlight-nondet -d
</pre>
</div>


<div class="figure">
<p><object type="image/svg+xml" data="hier-oblig-1.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

<p>
Note that the default translation used by <code>ltl2tgba</code> will turn any
syntactic persistence formulas (this includes obligations formulas)
into a weak automaton.  In a weak automaton, the acceptance condition
could be defined in term of SCCs, i.e., the cycles of some SCCs are
either all accepting, or all rejecting.  As a consequence, it there is
no incentive to use transition-based acceptance; instead, state-based
acceptance is output by default.
</p>

<p>
With <code>ltl2tgba -D</code> we get a (minimal) deterministic weak Büchi
automaton instead.
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org4b17e5d">ltl2tgba -D <span class="org-string">'Fa R b'</span> -d
</pre>
</div>


<div class="figure">
<p><object type="image/svg+xml" data="hier-oblig-2.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>


<p>
When we called <code>ltl2tgba</code>, without the option <code>-D</code>, the two automata
(non-deterministic and deterministic) were constructed, but the
deterministic one was discarded because it was bigger.  Using <code>-D</code>
forces the deterministic automaton to be used regardless of its size.
</p>

<p>
The detection and minimization of obligation properties is also used
by <code>autfilt</code> when simplifying deterministic automata (they need to be
deterministic so that <code>autfilt</code> can easily compute their complement).
</p>

<p>
For instance, let us use <code>ltl2dstar</code> to construct a Streett automaton
for the obligation property <code>Ga | XFb</code>.
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org8c97375">ltldo <span class="org-string">'ltl2dstar --automata=streett'</span> -f <span class="org-string">'Ga | XFb'</span> -d
</pre>
</div>


<div class="figure">
<p><object type="image/svg+xml" data="hier-oblig-3.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

<p>
We can now minimize this automaton with:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org36bf680">ltldo <span class="org-string">'ltl2dstar --automata=streett'</span> -f <span class="org-string">'Ga | XFb'</span> | autfilt -D -C -d
</pre>
</div>

<div class="figure">
<p><object type="image/svg+xml" data="hier-oblig-4.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

<p>
Here we have used option <code>-C</code> to keep the automaton complete, so that
the comparison with <code>ltl2dstar</code> is fair, since <code>ltl2dstar</code> always
output complete automata.
</p>
</div>
</div>

<div id="outline-container-org1f6097b" class="outline-3">
<h3 id="org1f6097b">Guarantee</h3>
<div class="outline-text-3" id="text-org1f6097b">
<p>
<i>Guarantee</i> properties can be translated into terminal automata.
There is nothing particular in Spot about <i>guarantee</i> properties, they
are all handled like <i>obligations</i>.
</p>

<p>
Again, using <code>-D</code> will always produce (minimal) deterministic Büchi
automata, even if they are larger than the non-deterministic version.
The output should be a terminal automaton in either case,
</p>

<p>
An example is <code>a U Xb</code>:
</p>

<div class="org-src-container">
<pre class="src src-sh">ltlfilt -f <span class="org-string">'a U Xb'</span> --format=<span class="org-string">'%[v]h'</span>
</pre>
</div>

<pre class="example">
guarantee

</pre>


<div class="org-src-container">
<pre class="src src-sh" id="org174c9dc">ltl2tgba <span class="org-string">'a U Xb'</span> | autfilt --highlight-nondet -d
</pre>
</div>

<div class="figure">
<p><object type="image/svg+xml" data="hier-guarantee-1.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

<div class="org-src-container">
<pre class="src src-sh" id="orgf1008ed">ltl2tgba -D <span class="org-string">'a U Xb'</span> -d
</pre>
</div>

<div class="figure">
<p><object type="image/svg+xml" data="hier-guarantee-2.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>

<div id="outline-container-org8a6c9ed" class="outline-3">
<h3 id="safety"><a id="org8a6c9ed"></a>Safety</h3>
<div class="outline-text-3" id="text-safety">
<p>
<i>Safety</i> properties also form a subclass of <i>obligation</i> properties,
and again there is no code specific to them in the translation.
However, the <i>safety</i> class corresponds to what can be represented
faithfully by monitors, i.e., automata that accept all their infinite
runs.
</p>

<p>
For most safety formulas, the acceptance output by <code>ltl2tgba</code> will
already be <code>t</code> (meaning that all runs are accepting).  However since
the translator does not do anything particular about safety formulas,
it is possible to find some pathological formulas for which the
translator outputs a non-deterministic Büchi automaton where not all
run are accepting.
</p>

<p>
Here is an example:
</p>

<div class="org-src-container">
<pre class="src src-sh">ltlfilt -f <span class="org-string">'(a W Gb) M b'</span> --format=<span class="org-string">'%[v]h'</span>
</pre>
</div>

<pre class="example">
safety

</pre>


<div class="org-src-container">
<pre class="src src-sh" id="org30c2a56">ltl2tgba <span class="org-string">'(a W Gb) M b'</span> | autfilt --highlight-nondet -d
</pre>
</div>

<div class="figure">
<p><object type="image/svg+xml" data="hier-safety-1.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

<p>
Actually, marking all states of this automaton as accepting would not
be wrong, the translator simply does not know it.
</p>

<p>
Using <code>-D</code> will fix that: it then produces a deterministic automaton
that is guaranteed to be minimal, and where all runs are accepting.
</p>

<div class="org-src-container">
<pre class="src src-sh" id="orgb94457e">ltl2tgba -D <span class="org-string">'(a W Gb) M b'</span> -d
</pre>
</div>

<div class="figure">
<p><object type="image/svg+xml" data="hier-safety-2.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>


<p>
If you are working with safety formula, and know you want to work with
monitors, you can use the <code>-M</code> option of <code>ltl2tgba</code>.  In this case
this will output the same automaton, but using the universal
acceptance (i.e. <code>t</code>).  You can interpret this output as a monitor
(i.e., a finite automaton that accepts all prefixes that can be
extended into valid ω-words).
</p>

<div class="org-src-container">
<pre class="src src-sh" id="orgd7a8f47">ltl2tgba -M <span class="org-string">'(a W Gb) M b'</span> | autfilt --highlight-nondet -d
</pre>
</div>

<div class="figure">
<p><object type="image/svg+xml" data="hier-safety-1m.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

<div class="org-src-container">
<pre class="src src-sh" id="orgdd83791">ltl2tgba -M -D <span class="org-string">'(a W Gb) M b'</span> -d
</pre>
</div>

<div class="figure">
<p><object type="image/svg+xml" data="hier-safety-2m.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>


<p>
Note that the <code>-M</code> option can be used with formulas that are not
safety properties.  In this case, the output monitor will recognize a
language larger than that of the property.
</p>
</div>
</div>

<div id="outline-container-org1744a8a" class="outline-3">
<h3 id="org1744a8a">Recurrence</h3>
<div class="outline-text-3" id="text-org1744a8a">
<p>
<i>Recurrence</i> properties can be represented by deterministic Büchi
automata.
</p>

<p>
For the subclass of <i>obligation</i> properties, using <code>-D</code> is a sure way
to obain a deterministic automaton (and even a minimal one), but for
the <i>recurrence</i> properties that are not <i>obligations</i> the translator
does not make <i>too much</i> effort to produce deterministic automata,
even with <code>-D</code> (this might change in the future).
</p>

<p>
All properties that are not in the <i>persistence</i> class (this includes
the <i>recurrence</i> properties that are not <i>obligations</i>) can benefit
from transition-based acceptance.  In other words using
transition-based acceptance will often produce shorter automata.
</p>

<p>
The typical example is <code>GFa</code>, which can be translated into a 1-state
transition-based Büchi automaton:
</p>

<div class="org-src-container">
<pre class="src src-sh">ltlfilt -f <span class="org-string">'GFa'</span> --format=<span class="org-string">'%[v]h'</span>
</pre>
</div>

<pre class="example">
recurrence

</pre>

<div class="org-src-container">
<pre class="src src-sh" id="orgb81ff8b">ltl2tgba <span class="org-string">'GFa'</span> -d
</pre>
</div>

<div class="figure">
<p><object type="image/svg+xml" data="hier-recurrence-1.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

<p>
Using state-based acceptance, at least two states are required.  For instance:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org703edaf">ltl2tgba -S <span class="org-string">'GFa'</span> -d
</pre>
</div>

<div class="figure">
<p><object type="image/svg+xml" data="hier-recurrence-2.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>


<p>
Here is an example of a formula for which <code>ltl2tgba</code> does not produce a
deterministic automaton, even with <code>-D</code>.
</p>

<div class="org-src-container">
<pre class="src src-sh">ltlfilt -f <span class="org-string">'G(Gb | Fa)'</span> --format=<span class="org-string">'%[v]h'</span>
</pre>
</div>

<pre class="example">
recurrence

</pre>

<div class="org-src-container">
<pre class="src src-sh" id="orge940c76">ltl2tgba -D <span class="org-string">'G(Gb | Fa)'</span> | autfilt --highlight-nondet -d
</pre>
</div>

<div class="figure">
<p><object type="image/svg+xml" data="hier-recurrence-3.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

<p>
One way to obtain a deterministic Büchi automaton (it has to exist, since this is
a <i>recurrence</i> property), is to request a deterministic automaton with parity
acceptance using <code>-P</code>.  The number of color output with <code>-P</code> is always reduced
to the minimal number possible, so for a <i>recurrence</i> property the output
automaton can only have one of three possible acceptance: <code>Inf(0)</code>, <code>t</code>, or <code>f</code>.
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org4081a5f">ltl2tgba -P -D <span class="org-string">'G(Gb | Fa)'</span> -d
</pre>
</div>

<div class="figure">
<p><object type="image/svg+xml" data="hier-recurrence-4.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

<p>
Note that if the acceptance is <code>t</code>, the property is a monitor, and if
its <code>f</code>, the property is <code>false</code>.  In any way, if you would like to
obtain a DBA for any recurrent property, a sure way to avoid these
difference is to pipe the result through <code>autfilt -B</code>
</p>

<div class="org-src-container">
<pre class="src src-sh" id="orge184033">ltl2tgba -P -D <span class="org-string">'G(Gb | Fa)'</span> | autfilt -B -d
</pre>
</div>

<div class="figure">
<p><object type="image/svg+xml" data="hier-recurrence-5.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>


<p>
It is likely that <code>ltl2tgba -B -D</code> will implement these steps in the
future, but so originally <code>-D</code> was only expressing a preference not a
requirement.
</p>
</div>
</div>

<div id="outline-container-org4fcf2d8" class="outline-3">
<h3 id="org4fcf2d8">Persistence</h3>
<div class="outline-text-3" id="text-org4fcf2d8">
<p>
Since <i>persistence</i> properties are outside of the <i>recurrence</i> class,
they cannot be represented by deterministic Büchi automata.  The typical
persistence formula is <code>FGa</code>, and using <code>-D</code> on this is hopeless.
</p>

<div class="org-src-container">
<pre class="src src-sh" id="orgc4b00e8">ltl2tgba -D FGa -d
</pre>
</div>

<div class="figure">
<p><object type="image/svg+xml" data="hier-persistence-1.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>


<p>
However since the <b>negation</b> of <code>FGa</code> is a <i>recurrence</i>, this negation
can be represented by a deterministic Büchi automaton, which means
that <code>FGa</code> could be represented by a deterministic co-Büchi automaton.
<code>ltl2tgba</code> does not generate co-Büchi acceptance, but we can do the
complementation ourselves:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="orgd984418">ltl2tgba --negate -D FGa | autfilt --complement -d
</pre>
</div>

<div class="figure">
<p><object type="image/svg+xml" data="hier-persistence-2.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

<p>
Note that in this example, we know that <code>GFa</code> is trivial enough that
<code>ltl2tgba -D GFa</code> will generate a deterministic automaton.  In the
general case we might have to determinize the automaton using <code>-P -D</code> as
we did in the previous section.  For persistence properties, <code>-P -D</code> should
return an automaton whose acceptance is one of <code>Fin(0)</code>, <code>t</code>, or <code>f</code>.
</p>

<p>
<i>Persistence</i> properties can be represented by weak Büchi automata.
The translator is aware of that, so when it detects that the input
formula is a syntactic-persistence, it simplifies its translation
slightly to ensure that the output will use at most one acceptance
set.  (It is possible to define a persistence properties using an LTL
formula that is not a syntactic-persistance, in that case this
optimization is simply not applied.)
</p>

<p>
If the input is a weak property that is not syntactically weak, the
output will not necessarily be weak.  One costly way to obtain a weak
automaton for a formula \(\varphi\) would be to first compute a
deterministic co-Büchi automaton \(\varphi\) then transform that into a
Büchi automaton.
</p>

<p>
Let's do that on the persistence formula <code>F(G!a | G(b U a))</code>, just for
the fun of it.
</p>

<div class="org-src-container">
<pre class="src src-sh">ltlfilt -f <span class="org-string">'F(G!a | G(b U a))'</span> --format=<span class="org-string">'%[v]h'</span>
</pre>
</div>
<pre class="example">
persistence

</pre>

<p>
Unfortunately the default output of the translation is not weak:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="orgbd0e833">ltl2tgba <span class="org-string">'F(G!a | G(b U a))'</span> -d
</pre>
</div>

<div class="figure">
<p><object type="image/svg+xml" data="hier-persistence-3.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

<p>
So let's determinize using parity acceptance:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org0aa8ecb">ltl2tgba -P -D <span class="org-string">'F(G!a | G(b U a))'</span> -d
</pre>
</div>

<div class="figure">
<p><object type="image/svg+xml" data="hier-persistence-4.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

<p>
And finally we convert the result back to Büchi with <code>autfilt -B</code>.
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org79c196c">ltl2tgba -P -D <span class="org-string">'F(G!a | G(b U a))'</span> | autfilt -B --highlight-nondet --small -d
</pre>
</div>

<div class="figure">
<p><object type="image/svg+xml" data="hier-persistence-7.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

<p>
That is indeed, a weak non-deterministic automaton.
</p>
</div>
</div>
</div>
</div>
</body>
</html>
