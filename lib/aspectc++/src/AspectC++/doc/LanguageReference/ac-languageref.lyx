#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
%
% setup fancyhdr
%
\RequirePackage{fancyhdr}
\fancypagestyle{plain}{%
  %
  % two side book class setup
  % odd page  - left head: chapter  - left foot: page number
  % even page - right head: section - right foot: page number
  % no head on plain pages
  %
  \fancyhf{}%
  \fancyhead[LE,RO]{\slshape \rightmark}
  \fancyhead[LO,RE]{\slshape \leftmark}
  \fancyfoot[LE,RO]{\bfseries \thepage}
  %
  % rules for head and foot
  % also on plain pages
  %
  \renewcommand{\headrulewidth}{.4pt}
  \renewcommand{\footrulewidth}{.4pt}
  \renewcommand{\plainfootrulewidth}{.4pt}
}
%
% Variables to change some details
%
% version number for this document
%
\newcommand{\@version}{1}
\newcommand{\version}[1]{ \renewcommand{\@version}{#1} }
%
%
\newcommand\pslogo[1]{\gdef\@pslogo{#1}}
\pslogo{}
%
\newcommand\otherlogo[1]{\gdef\@otherlogo{#1}}
\otherlogo{}
%
\newcommand\remark[1]{\gdef\@remark{#1}}
\remark{}
%
\newcommand{\doctype}[1]{\gdef\@doctype{#1}}
\doctype{Studie:}
%
\newcommand\credit[1]{\gdef\@credit{#1}}
\credit{Diese Studie wurde durch die\par
\vskip .3cm
pure-systems GmbH\par
Agnetenstr. 14\par
39106 Magdeburg\par
http://www.pure-systems.com\par
\vskip .3cm
erstellt.}
%
%
%
\newcommand\layoutlogos{

        \newlength{\@pslogowidth}
        \newlength{\@otherlogowidth}
        \settowidth{\@otherlogowidth}{\@otherlogo}
        \settowidth{\@pslogowidth}{\@pslogo}

        \noindent
        \begin{minipage}{\@otherlogowidth}
        {\@otherlogo}
        \end{minipage}
        \hspace*{\fill}
        \begin{minipage}{\@pslogowidth}
        {\@pslogo} 
        \end{minipage}
}

%
% redefine \maketitle macro
%
\renewcommand{\maketitle}{
    \null
    \thispagestyle{empty}

        {\layoutlogos}

        \vskip 3cm
        \begin{center}\leavevmode
        {\Huge\raggedright {\@doctype}\\ {\@title}\par}
        \rule{\textwidth}{1mm}
        \vskip 3mm
        {\Large\raggedleft {\@author}\par}
        \vskip 15mm
        {\Large\raggedleft {\@date}\par}
        \end{center}
        \vfill
        {\large\raggedleft {\@remark}\par}
        \vskip 1cm
        \null
%
        \newpage
%
        \null
        \thispagestyle{empty}
        \vfill
        {\@credit}
        \null
        \cleardoublepage
}

%--------------------------------------------------------------------
% setup pure-systems style
%--------------------------------------------------------------------
\doctype{Documentation:}
\credit{
  \noindent\small{(c) 2017 Olaf Spinczyk and pure-systems GmbH\\All rights reserved.}}
\pslogo{
  \resizebox{6cm}{!}{\includegraphics{images/ps-logo}}}
\otherlogo{
  \resizebox{4cm}{!}{\includegraphics{images/ac++logo}}}
\sloppy
\remark{
  \small{(c) 2017 Olaf Spinczyk$^1$ and pure-systems GmbH$^2$\\~\\
$^1$\href{mailto:os@aspectc.org}{os@aspectc.org}\\
\href{http://www.aspectc.org}{www.aspectc.org}\\~\\
$^2$\href{mailto:aspectc@pure-systems.com}{aspectc@pure-systems.com}\\
\href{http://www.pure-systems.com}{www.pure-systems.com}\\
Agnetenstr. 14\\
39106 Magdeburg\\
Germany
}}

%--------------------------------------------------------------------
% place footnotes at the bottom of the page
%--------------------------------------------------------------------
\renewcommand\footnoterule{%
  \vfill
  \kern-3\p@
  \hrule\@width.3\columnwidth
  \kern2.6\p@}

%--------------------------------------------------------------------
% leave less than one and a half space between lines
%--------------------------------------------------------------------
\setstretch{1.15}

%--------------------------------------------------------------------
% 'list of examples' environment
%--------------------------------------------------------------------
\newcommand\examplesname{List of Examples}
\newenvironment{examples} 
  {\section*{\examplesname}% 
   \@mkboth{\MakeUppercase\examplesname}% 
                 {\MakeUppercase\examplesname}% 
   \thispagestyle{plain}
   \parindent\z@ \parskip\z@ \@plus .3\p@\relax} %
  {\clearpage}

%--------------------------------------------------------------------
% environment 'comment' 
%--------------------------------------------------------------------
\usepackage{comment}

%--------------------------------------------------------------------
% add 'Index' to table of contents 
%--------------------------------------------------------------------
\let\old@theindex\theindex
\def\theindex{
  \old@theindex
  \addcontentsline{toc}{section}{\indexname}}

%--------------------------------------------------------------------
% landscape mode
%--------------------------------------------------------------------
\usepackage{pdflscape}

%--------------------------------------------------------------------
% caption of longtables
%--------------------------------------------------------------------
\usepackage{capt-of}
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "times" "default"
\font_sans "helvet" "default"
\font_typewriter "courier" "default"
\font_math "auto" "auto"
\font_default_family sfdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing onehalf
\use_hyperref true
\pdf_title "AspectC++ Language Reference"
\pdf_author "\\textcopyright\\ Olaf Spinczyk and pure-systems GmbH"
\pdf_subject "Documentation"
\pdf_keywords "AOP, AspectC++, ac++, pure-systems"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\pdf_quoted_options "urlcolor=blue"
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 0
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2.5cm
\topmargin 3cm
\rightmargin 3.5cm
\bottommargin 4cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title

\emph on
AspectC++ Language Reference
\end_layout

\begin_layout Author

\size largest
Olaf Spinczyk and
\begin_inset VSpace 3mm
\end_inset


\begin_inset Newline newline
\end_inset

pure-systems GmbH
\end_layout

\begin_layout Date
Version 2.2, March 10, 2017
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\end_inset


\end_layout

\begin_layout Section
About
\end_layout

\begin_layout Standard
This document is intended to be used as a reference book for the AspectC++
 language elements.
 It describes in-depth the use and meaning of each element providing examples.
 For experienced users the contents of this document are summarized in the
 
\begin_inset CommandInset href
LatexCommand href
name "AspectC++ Quick Reference"
target "http://www.aspectc.org/doc/ac-quickref.pdf"

\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
A step-by-step introduction how to program with AspectC++ is given in the
 
\begin_inset CommandInset href
LatexCommand href
name "AspectC++ Programming Guide"
target "http://www.aspectc.org/Documentation.5.0.html"

\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Sorry, but the Programming Guide is not written yet 
\family typewriter
:-(
\end_layout

\end_inset

.
 
\end_layout

\end_inset

Detailed information about the AspectC++ compiler 
\family typewriter
\series bold
ac++
\family default
\series default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
ac++@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{ac++}
\end_layout

\end_inset


\end_layout

\end_inset

 can be looked up in the 
\begin_inset CommandInset href
LatexCommand href
name "AspectC++ Compiler Manual"
target "http://www.aspectc.org/doc/ac-compilerman.pdf"

\end_inset

.
 
\end_layout

\begin_layout Standard
AspectC++ is an aspect-oriented extension to the C++ language
\begin_inset Foot
status open

\begin_layout Plain Layout
defined in the ISO/IEC 14882:1998(E) standard
\end_layout

\end_inset

.
 It is similar to AspectJ
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "http://www.eclipse.org/aspectj/"
target "http://www.eclipse.org/aspectj/"

\end_inset


\end_layout

\end_inset

 but, due to the nature of C++, in some points completely different.
 The first part of this document introduces the basic concepts of the AspectC++
 language.
 The in-depth description of each language element is subject of the second
 part.
\end_layout

\begin_layout Section
Basic Concepts
\end_layout

\begin_layout Subsection
Pointcuts
\begin_inset Index idx
status open

\begin_layout Plain Layout
pointcut
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

(
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Aspects in AspectC++ implement crosscutting concerns
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
crosscutting concern
\end_layout

\end_inset

 in a modular way.
 With this in mind the most important element of the AspectC++ language
 is the pointcut.
 Pointcuts describe a set of join points
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
join point
\end_layout

\end_inset

 by determining on which condition an aspect shall take effect.
 Thereby each join point can either refer to a function, a type/class, a
 variable, or a point from which a join point is accessed so that this condition
 can be for instance the event of reaching a designated code position or
 the allocation of a variable with a certain value.
 Depending on the kind of pointcuts, they are evaluated at compile time
 or at runtime.
\end_layout

\begin_layout Subsubsection
Match Expressions
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
match expression
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

(
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
search pattern!match expression
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

(
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There are two types of pointcuts in AspectC++: 
\emph on
code pointcuts
\emph default
 and 
\emph on
name pointcuts
\emph default
.
 Name pointcuts
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
name pointcut
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pointcut!name
\end_layout

\end_inset

 describe a set of (statically) known program entities like types/classes,
 variables, functions, or namespaces.
 All name pointcuts are based on match expressions.
 A match expression can be understood as a search pattern
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
search pattern
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
match expression!search pattern
\end_layout

\end_inset

.
 In such a search pattern the special character 
\begin_inset Quotes eld
\end_inset

%
\begin_inset Quotes erd
\end_inset

 is interpreted as a wildcard for names or parts of a signature.
 The special character sequence 
\begin_inset Quotes eld
\end_inset

…
\begin_inset Quotes erd
\end_inset

 matches any number of parameters in a function signature or any number
 of scopes in a qualified name.
 A match expression is a quoted string.
\end_layout

\begin_layout Subsubsection*
Example: match expressions (name pointcuts)
\begin_inset CommandInset label
LatexCommand label
name "exa:match-expressions"

\end_inset


\end_layout

\begin_layout Description

\family typewriter
\series medium
"int
\series default

\begin_inset space ~
\end_inset


\series medium
C::%(...)"
\family default
\series default
 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

matches all member functions of the class C that return an 
\family typewriter
int
\end_layout

\begin_layout Description

\family typewriter
\series medium
"%List"
\family default
\series default
 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

matches any namespace, class, struct, union, or enum whose name ends with
 
\family typewriter
List
\family default
.
 In case of a matched namespace or class the match expression also matches
 entities inside the namespace resp.
 class.
 For more information see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Namspace-and-Class"

\end_inset

.
\end_layout

\begin_layout Description

\family typewriter
\series medium
"%
\family default
\series default
 
\family typewriter
printf(const char *, ...)"
\family default
 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

matches the function 
\family typewriter
printf
\family default
 (defined in the global scope) having at least one parameter of type 
\family typewriter
const
\begin_inset space ~
\end_inset

char
\begin_inset space ~
\end_inset

*
\family default
 and returning any type
\end_layout

\begin_layout Description

\family typewriter
\series medium
"const
\series default

\begin_inset space ~
\end_inset


\series medium
%&
\begin_inset space ~
\end_inset

...::%(...)"
\family default
\series default
 
\family typewriter

\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\family default
matches all functions that return a reference to a constant object
\end_layout

\begin_layout Standard
Match expressions select program entities with respect to their definition
 scope, their type, and their name.
 A detailed description of the match expression semantics follows in section
 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:Match-Expressions"

\end_inset

.
 The grammar which defines syntactically valid match expressions is shown
 in appendix 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:Match-Expression-Grammar"

\end_inset

.
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
match expression
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

)
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
search pattern!match expression
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Pointcut Expressions
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pointcut!expression
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

(
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The other type of pointcuts, the code pointcuts
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
code pointcut
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pointcut!code
\end_layout

\end_inset

, describe an intersection through the set of the points in the control
 flow
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
control flow
\end_layout

\end_inset

 of a program.
 A code pointcut can refer to a call or execution point of a function, to
 a call of a built-in operator or and to write and read points of member
 variables and global variables.
 They can only be created with the help of name pointcuts because all join
 points supported by AspectC++ require at least one name to be defined.
 This is done by calling predefined pointcut functions
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pointcut function
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pointcut!function
\end_layout

\end_inset

 in a pointcut expression that expect a pointcut as argument.
 Such a pointcut function is for instance 
\series bold
within
\series default
(
\emph on
pointcut
\emph default
), which filters all join points that are within the functions or classes
 in the given pointcut.
\end_layout

\begin_layout Standard
Name and code pointcuts can be combined in pointcut expressions by using
 the algebraic operators 
\begin_inset Quotes eld
\end_inset

&&
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

||
\begin_inset Quotes erd
\end_inset

, and 
\begin_inset Quotes eld
\end_inset

!
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsubsection*
Example: pointcut expressions
\begin_inset CommandInset label
LatexCommand label
name "exa:pointcut-expressions"

\end_inset


\end_layout

\begin_layout Description

\family typewriter
\series medium
"%List"
\begin_inset space ~
\end_inset

&&
\begin_inset space ~
\end_inset

!derived("Queue")
\family default
\series default
 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

describes the set of classes with names that end with 
\begin_inset Quotes eld
\end_inset

List
\begin_inset Quotes erd
\end_inset

 and that are not derived from the class 
\family typewriter
Queue
\end_layout

\begin_layout Description

\family typewriter
\series medium
call("void
\family default
\series default
 
\family typewriter
draw()
\series medium
")
\begin_inset space ~
\end_inset


\series default
&&
\begin_inset space ~
\end_inset

within
\series medium
("
\series default
Shape
\series medium
")
\family default
\series default
 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

describes the set of calls to the function 
\family typewriter
draw
\family default
 that are within methods of the class 
\family typewriter
Shape
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pointcut!expression
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Types of Join Points
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
join point
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

(
\end_layout

\end_inset


\end_layout

\begin_layout Standard
According to the two types of pointcuts supported by AspectC++ there are
 also two coarse types of join points: name join points and code join points.
 As diagramed in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:acpp_model_inheri_only_less"

\end_inset

 both of these have sub join point types.
 The types 
\family typewriter
Any
\family default
, 
\family typewriter
Name
\family default
, 
\family typewriter
Code
\family default
 and 
\family typewriter
Access
\family default
 are abstract types and exist just for categorizing the other join point
 types.
\begin_inset Newline newline
\end_inset


\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/acmodel_inheri_only_less.eps
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:acpp_model_inheri_only_less"

\end_inset

join point type hierarchy
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:acpp_model_inheri_only_less"

\end_inset

 is extracted from the AspectC++ project repository hierarchy, that can
 be found in appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:appendix:projectmodel_structure"

\end_inset

.
\end_layout

\begin_layout Standard
Based on a short code fragment the differences and relations between the
 types of join points shall be clarified.
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "exa:shape_example_code"

\end_inset


\begin_inset listings
lstparams "numbers=left,numberstyle={\footnotesize},basicstyle={\ttfamily},breaklines=true,showstringspaces=false,tabsize=2"
inline false
status open

\begin_layout Plain Layout

class Shape { /*...*/ };
\end_layout

\begin_layout Plain Layout

void draw(Shape& shape) { /*...*/ }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

namespace Circle { 
\end_layout

\begin_layout Plain Layout

  typedef int PRECISION;
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  class S_Circle : public Shape {
\end_layout

\begin_layout Plain Layout

    PRECISION m_radius;
\end_layout

\begin_layout Plain Layout

    public:
\end_layout

\begin_layout Plain Layout

      void radius(PRECISION r) {
\end_layout

\begin_layout Plain Layout

        m_radius = r;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      ~S_Circle() { /*...*/ }
\end_layout

\begin_layout Plain Layout

  };
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  void draw(PRECISION r) {
\end_layout

\begin_layout Plain Layout

    S_Circle circle;
\end_layout

\begin_layout Plain Layout

    circle.radius(r);
\end_layout

\begin_layout Plain Layout

    draw(circle);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() {
\end_layout

\begin_layout Plain Layout

  Circle::draw(10);
\end_layout

\begin_layout Plain Layout

  return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Code join points
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
code join point
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
join point!code
\end_layout

\end_inset

 are used to form code pointcuts and name join points (i.e.
\begin_inset space ~
\end_inset

names) are used to form name pointcuts.
 Figure 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:join-points-new"

\end_inset

 shows join points of the code fragment above and how they correlate.
 Built-in constructors, destructors and uncalled operators are not shown.
 Additionally appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Project-Repository-File"

\end_inset

 shows the contents of the project repository
\begin_inset Foot
status open

\begin_layout Plain Layout
The AspectC++ project repository is a file, that contains the internal AspectC++
 model as xml-tree.
 The actual style and format of the content may change at any time.
 For more information see the AspectC++ Compiler Manual.
\end_layout

\end_inset

 for the code fragment.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/JoinPointModelNew.eps
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:join-points-new"

\end_inset

join points and their relations
\end_layout

\end_inset


\end_layout

\end_inset

Every 
\series bold
execution
\series default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
execution join point
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
join point!execution
\end_layout

\end_inset

 join point is associated with the name of an executable function.
 Pure virtual functions
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pure virtual!functions
\end_layout

\end_inset

 are not executable.
 Thus, advice code for execution join points would never be triggered for
 this kind of function.
 However, the call of such a function, i.e.
\begin_inset space ~
\end_inset

a 
\series bold
call
\series default
 join point with this function as target, is absolutely possible.
 Furthermore there are no execution join points for built-in operator functions.
\end_layout

\begin_layout Standard
Every 
\series bold
call
\series default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
call join point
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
join point!call
\end_layout

\end_inset

 or 
\series bold
builtin
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
builtin join point
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
join point!builtin
\end_layout

\end_inset

 join point is associated with two names: the name of the source and the
 target function (in case of builtin this is the global built-in operator
 function) of a function call.
 As there can be multiple function calls within the same function, each
 function name can be associated with a list of 
\series bold
call
\series default
 join points
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
join point
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

)
\end_layout

\end_inset

 and
\series bold
 builtin
\series default
 join points
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
join point
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

)
\end_layout

\end_inset

.
 The same holds for 
\series bold
set
\series default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
set join point
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
join point!set
\end_layout

\end_inset

 and 
\series bold
get
\series default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
get join point
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
join point!get
\end_layout

\end_inset

 join points, which represent write resp.
\begin_inset space ~
\end_inset

read operations on data members or global variables.
 Each of these join points is associated with the name of the function that
 contains the join point and the name of the accessed member variable or
 global variable.
 A 
\series bold
construction
\series default
 join point means the class specific instruction sequence executed when
 an instance is created.
 In analogy, a 
\series bold
destruction
\series default
 join point means the object destruction.
\end_layout

\begin_layout Subsubsection
Pointcut declarations
\series bold

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pointcut!declaration
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

(
\end_layout

\end_inset


\end_layout

\begin_layout Standard
AspectC++ provides the possibility to name pointcut
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
name pointcut
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pointcut!name
\end_layout

\end_inset

 expressions with the help of pointcut declarations.
 This makes it possible to reuse pointcut expressions in different parts
 of a program.
 They are allowed where C++ declarations are allowed.
 Thereby the usual C++ name lookup and inheritance rules are also applicable
 for pointcut declarations.
\end_layout

\begin_layout Standard
A pointcut declaration is introduced by the keyword 
\family typewriter
pointcut
\family default
.
 
\end_layout

\begin_layout Subsubsection*
Example: pointcut declaration
\begin_inset CommandInset label
LatexCommand label
name "exa:pointcut-declaration"

\end_inset


\end_layout

\begin_layout Description

\family typewriter
\series medium
pointcut
\series default

\begin_inset space ~
\end_inset


\series medium
lists()
\begin_inset space ~
\end_inset

=
\series default

\begin_inset space ~
\end_inset


\series medium
derived("List");
\family default
\series default
 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\family typewriter
lists
\family default
 can now be used everywhere in a program where a pointcut expression can
 be used to refer to 
\family typewriter
derived("List")
\end_layout

\begin_layout Standard
Furthermore pointcut declarations can be used to define pure virtual pointcuts
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pure virtual!pointcut
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pointcut!pure virtual
\end_layout

\end_inset

.
 This enables the possibility of having re-usable abstract aspects
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
aspect
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
abstract aspect
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
aspect!abstract
\end_layout

\end_inset

 that are discussed in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Aspects"

\end_inset

.
 The syntax of pure virtual pointcut declarations is the same as for usual
 pointcut declarations except the keyword 
\family typewriter
virtual
\family default
 following 
\family typewriter
pointcut
\family default
 and that the pointcut expression is 
\begin_inset Quotes eld
\end_inset

0
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsubsection*
Example: pure virtual pointcut declaration
\begin_inset CommandInset label
LatexCommand label
name "exa:pure-virtual"

\end_inset


\end_layout

\begin_layout Description

\family typewriter
\series medium
pointcut
\series default

\begin_inset space ~
\end_inset


\series medium
virtual
\begin_inset space ~
\end_inset

methods()
\begin_inset space ~
\end_inset

=
\series default

\begin_inset space ~
\end_inset


\series medium
0;
\family default
\series default
 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\family typewriter
methods
\family default
 is a pure virtual pointcut that has to be redefined in a derived aspect
 to refer to the actual pointcut
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pointcut
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

)
\end_layout

\end_inset

 expression
\series bold

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pointcut!declaration
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Attributes
\end_layout

\begin_layout Standard
Based on the C++11 attribute syntax AspectC++ provides an annotation mechanism
 for join points
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
In other languages this mechanism is known as 
\begin_inset Quotes eld
\end_inset

annotations
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset

.
 All join points annotated with the same attribute 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

, e.g.
 
\family typewriter
class [[a]] C {…}
\family default
, can be referred to in a pointcut expression as a().
 Further information can be found in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:attributes"

\end_inset

.
\end_layout

\begin_layout Subsection
Slices
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
slice
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

(
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A 
\emph on
slice
\emph default
 is a fragment of a C++ language element that defines a scope.
 It can be used by advice to extend the static structure of the program.
 For example, the elements of a class slice can be merged into one or more
 target classes by introduction advice.
 The following example shows a simple class slice declaration.
\end_layout

\begin_layout Subsubsection*
Example: class slice declaration
\begin_inset CommandInset label
LatexCommand label
name "exa:class-slice-declaration"

\end_inset


\end_layout

\begin_layout LyX-Code
slice class Chain {
\end_layout

\begin_layout LyX-Code
  Chain *_next;
\end_layout

\begin_layout LyX-Code
public:
\end_layout

\begin_layout LyX-Code
  Chain *next () const { return _next; }
\end_layout

\begin_layout LyX-Code
};
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
slice
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Advice Code
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
advice
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

(
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
advice!code
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

(
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To a code join point
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
code join point
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
join point!code
\end_layout

\end_inset

 so-called advice code can be bound.
 Advice code can be understood as an action
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
action
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
runtime support!action
\end_layout

\end_inset

 activated by an aspect when a corresponding code join point in a program
 is reached.
 The activation of the advice code can happen before
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
before
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
advice!before
\end_layout

\end_inset

, after
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
after
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
advice!after
\end_layout

\end_inset

, or before and after the code join point is reached.
 The AspectC++ language element to specify advice code is the advice declaration
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
advice!declaration
\end_layout

\end_inset

.
 It is introduced by the keyword 
\family typewriter
advice
\family default
 followed by a pointcut expression defining where and under which conditions
 the advice code shall be activated.
 
\end_layout

\begin_layout Subsubsection*
Example: advice declaration
\begin_inset CommandInset label
LatexCommand label
name "exa:advice-declaration"

\end_inset


\end_layout

\begin_layout LyX-Code
advice execution("void login(...)") : before() {
\end_layout

\begin_layout LyX-Code
  cout << "Logging in." << endl;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
The code fragment 
\family typewriter
:before()
\family default
 following the pointcut expression determines that the advice code shall
 be activated directly 
\series bold
before
\series default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
before
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
advice!before
\end_layout

\end_inset

 the code join point is reached.
 It is also possible here to use 
\family typewriter
:after()
\family default
 which means 
\series bold
after
\series default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
after
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
advice!after
\end_layout

\end_inset

 reaching the code join point respectively 
\family typewriter
:around()
\family default
 which means that the advice code shall be executed instead of the code
 described by the code join point.
 In an 
\series bold
around
\series default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
around
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
advice!around
\end_layout

\end_inset

 advice the advice code can explicitly trigger the execution of the program
 code at the join point so that advice code can be executed 
\series bold
before
\series default
 and 
\series bold
after
\series default
 the join point.
 There are no special access rights of advice code regarding to program
 code at a join point.
\end_layout

\begin_layout Standard
Beside the pure description of join points pointcuts can also bind variables
 to context
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
context variables
\end_layout

\end_inset

 information of a join point.
 Thus for instance the actual argument values of a function call can be
 made accessible to the advice code.
\end_layout

\begin_layout Subsubsection*
Example: advice declaration with access to context information
\begin_inset CommandInset label
LatexCommand label
name "exa:advice-declaration-with"

\end_inset


\end_layout

\begin_layout LyX-Code
pointcut new_user(const char *name) = 
\end_layout

\begin_layout LyX-Code
  execution("void login(...)") && args(name); 
\end_layout

\begin_layout LyX-Code
advice new_user(name) : before(const char *name) { 
\end_layout

\begin_layout LyX-Code
  cout << "User " << name << " is logging in." << endl; 
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
In the example above at first the pointcut 
\family typewriter
new_user
\family default
 is defined including a context variable
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
context variables
\end_layout

\end_inset

 
\family typewriter
name
\family default
 that is bound to it.
 This means that a value of type 
\family typewriter
const char*
\family default
 is supplied every time the join point described by the pointcut 
\family typewriter
new_user
\family default
 is reached.
 The pointcut function 
\family typewriter
args
\family default
 used in the pointcut expression delivers all join points in the program
 where an argument of type 
\family typewriter
const char*
\family default
 is used.
 Therefore 
\family typewriter
args(name)
\family default
 in touch with the 
\series bold
execution
\series default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
execution join point
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
join point!execution
\end_layout

\end_inset

 join point binds 
\family typewriter
name
\family default
 to the first and only parameter of the function 
\family typewriter
login
\family default
.
 
\end_layout

\begin_layout Standard
The advice declaration in the example above following the pointcut declaration
 binds the execution of advice code to the event when a join point described
 in 
\family typewriter
new_user
\family default
 is reached.
 The context variable
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
context variables
\end_layout

\end_inset

 that holds the actual value of the parameter of the reached join point
 has to be declared as a formal parameter of 
\family typewriter
before
\family default
, 
\family typewriter
after
\family default
, or 
\family typewriter
around
\family default
.
 This parameter can be used in the advice code like an oridinary function
 parameter.
\end_layout

\begin_layout Standard
Beside the pointcut function 
\family typewriter
args
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
args@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{args()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pointcut function!args@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{args()}
\end_layout

\end_inset


\end_layout

\end_inset

 the binding of context variables is performed by 
\family typewriter
that
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
that@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{that()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pointcut function!that@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{that()}
\end_layout

\end_inset


\end_layout

\end_inset

, 
\family typewriter
target
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
target@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{target()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pointcut function!target@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{target()}
\end_layout

\end_inset


\end_layout

\end_inset

, and 
\family typewriter
result
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
result@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{result()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pointcut function!base@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{base()}
\end_layout

\end_inset


\end_layout

\end_inset

.
 At the same time these pointcut functions act as filters corresponding
 to the type of the context variable.
 For instance 
\family typewriter
args
\family default
 in the example above filters all join points having an argument of type
 
\family typewriter
const char*
\family default
.
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
advice!code
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Introductions
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
introduction
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

(
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
advice!introduction
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

(
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The second type of advice supported by AspectC++ are the introductions.
 Introductions are used to extend program code and data structures in particular.
 The following example extends two classes each by a member variable and
 a member function.
\end_layout

\begin_layout Subsubsection*
Example: introductions
\begin_inset CommandInset label
LatexCommand label
name "exa:introductions"

\end_inset


\end_layout

\begin_layout LyX-Code
pointcut shapes() = "Circle" || "Polygon";
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
advice shapes() : slice class {
\end_layout

\begin_layout LyX-Code
  bool m_shaded;
\end_layout

\begin_layout LyX-Code
  void shaded(bool state) {
\end_layout

\begin_layout LyX-Code
    m_shaded = state;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
};
\end_layout

\begin_layout Standard
Like an ordinary advice declaration an introduction is introduced by the
 keyword 
\family typewriter
advice
\family default
.
 If the following pointcut is a name pointcut
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
name pointcut
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pointcut!name
\end_layout

\end_inset

 the slice declaration following the token 
\begin_inset Quotes eld
\end_inset

:
\begin_inset Quotes erd
\end_inset

 is introduced in the classes and aspects described by the pointcut.
 Introduced code can then be used in normal program code like any other
 member function, member variable, etc.
 Advice code in introductions has full access rights
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
introduction!access rights
\end_layout

\end_inset

 regarding to program code at a join point, i.e.
\begin_inset space ~
\end_inset

a method introduced in a class has access even to private members of that
 class.
\end_layout

\begin_layout Standard
Slices can also be used to introduce new base classes.
 In the first line of the following example it is made sure that every class
 with a name that ends with 
\begin_inset Quotes eld
\end_inset

Object
\begin_inset Quotes erd
\end_inset

 is derived from a class 
\family typewriter
MemoryPool
\family default
.
 This class may implement an own memory management by overloading the 
\family typewriter
new
\family default
 and 
\family typewriter
delete
\family default
 operators.
 Classes that inherit from 
\family typewriter
MemoryPool
\family default
 must redefine the pure virtual method 
\family typewriter
release
\family default
 that is part of the implemented memory management.
 This is done in the second line for all classes in the pointcut
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
advice
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

)
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
introduction
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

)
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
advice!introduction
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

)
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection*
Example: base class introduction
\begin_inset CommandInset label
LatexCommand label
name "exa:base-class-intro"

\end_inset


\end_layout

\begin_layout LyX-Code
advice "%Object" : slice class : public MemoryPool {
\end_layout

\begin_layout LyX-Code
  virtual void release() = 0;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Subsubsection
Advice Ordering
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
ordering
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

(
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If more than one advice affects the same join point it might be necessary
 to define an order of advice execution if there is a dependency between
 the advice codes (
\begin_inset Quotes eld
\end_inset

aspect interaction
\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
aspect interaction
\end_layout

\end_inset

).
 The following example shows how the precedence of advice code can be defined
 in AspectC++.
\end_layout

\begin_layout Subsubsection*
Example: advice ordering
\begin_inset CommandInset label
LatexCommand label
name "exa:order"

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
order
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
advice!order
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code
advice call("% send(...)") : order("Encrypt", "Log");
\end_layout

\begin_layout Standard
If advice of both aspects (see 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Aspects"

\end_inset

) 
\family typewriter
Encrypt
\family default
 and 
\family typewriter
Log
\family default
 should be run when the function 
\family typewriter
send(...)
\family default
 is called this order declaration defines that the advice of 
\family typewriter
Encrypt
\family default
 has a higher precedence.
 More details on advice ordering and precedence 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
precedence
\end_layout

\end_inset

 can be found in section 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:ordering"

\end_inset

.
\end_layout

\begin_layout Subsection
Aspects
\begin_inset CommandInset label
LatexCommand label
name "subsec:Aspects"

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
aspect
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

(
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The aspect is the language element of AspectC++ to collect introductions
 and advice code implementing a common crosscutting concern
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
crosscutting concern
\end_layout

\end_inset

 in a modular way.
 This put aspects in a position to manage common state information.
 They are formulated by means of aspect declarations
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
aspect!declaration
\end_layout

\end_inset

 as a extension to the class concept of C++.
 The basic structure of an aspect declaration is exactly the same as an
 usual C++ class definition, except for the keyword 
\family typewriter
aspect
\family default
 instead of 
\family typewriter
class
\family default
, 
\family typewriter
struct
\family default
 or 
\family typewriter
union
\family default
.
 According to that, aspects can have member variables and member functions
 and can inherit from classes and even other aspects.
\end_layout

\begin_layout Subsubsection*
Example: aspect declaration
\begin_inset CommandInset label
LatexCommand label
name "exa:aspect-decl"

\end_inset


\end_layout

\begin_layout LyX-Code
aspect Counter { 
\end_layout

\begin_layout LyX-Code
  static int m_count;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
  pointcut counted() = "Circle" || "Polygon";
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
  advice counted() : slice struct {
\end_layout

\begin_layout LyX-Code
    class Helper {
\end_layout

\begin_layout LyX-Code
      Helper() { Counter::m_count++; }
\end_layout

\begin_layout LyX-Code
    } m_counter;
\end_layout

\begin_layout LyX-Code
  };
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
  advice execution("% main(...)") : after() {
\end_layout

\begin_layout LyX-Code
    cout << "Final count: " << m_count << " objects"
\end_layout

\begin_layout LyX-Code
         << endl;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
};
\end_layout

\begin_layout LyX-Code

\emph on
...
 and at an appropriate place
\end_layout

\begin_layout LyX-Code
#include "Counter.ah"
\end_layout

\begin_layout LyX-Code
int Counter::m_count = 0;
\end_layout

\begin_layout Standard
In this example the count of object instantiations for a set of classes
 is determined.
 Therefore, a member variable 
\family typewriter
m_counter
\family default
 is introduced into the classes described by the pointcut incrementing a
 global counter on construction time.
 By applying advice code for the function 
\family typewriter
main
\family default
 the final count of object instantiations is displayed when the program
 terminates.
 
\end_layout

\begin_layout Standard
This example can also be rewritten as an abstract aspect
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
abstract aspect
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
aspect!abstract
\end_layout

\end_inset

 that can for instance be archived in an aspect library for the purpose
 of reuse.
 It only require to reimplement the pointcut declaration to be pure virtual
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pure virtual!pointcut
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection*
Example: abstract aspect
\begin_inset CommandInset label
LatexCommand label
name "exa:abstract-aspect"

\end_inset


\end_layout

\begin_layout LyX-Code
aspect Counter { 
\end_layout

\begin_layout LyX-Code
  static int m_count;
\end_layout

\begin_layout LyX-Code
  Counter() : m_count(0) {}
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
  pointcut virtual counted() = 0;
\end_layout

\begin_layout LyX-Code
  ...
\end_layout

\begin_layout LyX-Code
};
\end_layout

\begin_layout Standard
It is now possible to inherit from 
\family typewriter
Counter
\family default
 to reuse its functionality by reimplementing 
\family typewriter
counted
\family default
 to refer to the actual pointcut expression.
\end_layout

\begin_layout Subsubsection*
Example: reused abstract aspect
\begin_inset CommandInset label
LatexCommand label
name "exa:reused-abstract"

\end_inset


\end_layout

\begin_layout LyX-Code
aspect MyCounter : public Counter { 
\end_layout

\begin_layout LyX-Code
  pointcut counted() = derived("Shape");
\end_layout

\begin_layout LyX-Code
};
\end_layout

\begin_layout Subsubsection
Aspect Instantiation
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
aspect!instantiation
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

(
\end_layout

\end_inset


\end_layout

\begin_layout Standard
By default aspects in AspectC++ are automatically instantiated as global
 objects.
 The idea behind it is that aspects can also provide global program properties
 and therefore have to be always accessible.
 However in some special cases it may be desired to change this behavior,
 e.g.
\begin_inset space ~
\end_inset

in the context of operating systems when an aspect shall be instantiated
 per process or per thread.
 
\end_layout

\begin_layout Standard
The default instantiation scheme can be changed by defining the static method
 
\family typewriter
aspectof
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
aspectof@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{aspectof()}
\end_layout

\end_inset


\end_layout

\end_inset

 resp.
\begin_inset space ~
\end_inset


\family typewriter
aspectOf
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
aspectOf@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{aspectOf()}
\end_layout

\end_inset


\end_layout

\end_inset

 that is otherwise generated for an aspect.
 This method is intended to be always able to return an instance of the
 appropriate aspect.
\end_layout

\begin_layout Subsubsection*
Example: aspect instantiation using 
\family typewriter
aspectof
\begin_inset CommandInset label
LatexCommand label
name "exa:aspect-aspectof"

\end_inset


\end_layout

\begin_layout LyX-Code
aspect ThreadCounter : public Counter {
\end_layout

\begin_layout LyX-Code
  pointcut counted() = "Thread";
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
  advice counted() : ThreadCounter m_instance;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
  static ThreadCounter *aspectof() {
\end_layout

\begin_layout LyX-Code
    return tjp->target()->m_instance;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
};
\end_layout

\begin_layout Standard
The introduction of 
\family typewriter
m_instance
\family default
 into 
\family typewriter
Thread
\family default
 guarantees that every thread object has an instance of the aspect.
 By calling 
\family typewriter
aspectof
\family default
 it is possible to get this instance at any join point which is essential
 for accessing advice code and members of the aspect.
 For this purpose code in 
\family typewriter
aspectof
\family default
 has full access to the actual join point in a way described in the next
 section.
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
aspect
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

)
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
aspect!instantiation
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Runtime Support
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
runtime support
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

(
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Support for Advice Code
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
runtime support!for advice code
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

(
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
advice!runtime support
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

(
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For many aspects access to context variables
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
context variables
\end_layout

\end_inset

 may not be sufficient to get enough information about the join point where
 advice code was activated.
 For instance a control flow
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
control flow
\end_layout

\end_inset

 aspect for a complete logging of function calls in a program would need
 information about function arguments and its types on runtime to be able
 to produce a type-compatible output.
 
\end_layout

\begin_layout Standard
In AspectC++ this information is provided by the members of the class 
\family typewriter
JoinPoint
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
runtime support!JoinPoint@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}
\end_layout

\end_inset


\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{comment}
\end_layout

\end_inset

available both in advice code and introductions 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{comment}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

(see table below).
 
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="21" columns="2">
<features islongtable="true" longtabularalignment="center">
<column alignment="center" valignment="top" width="0cm">
<column alignment="center" valignment="top" width="0cm">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
types:
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Result
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
result type
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
That
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
object type
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Target
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
target type
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
AC::Type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
encoded type of an object
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
AC::JPType
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
join point types
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
static methods:
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
int args()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
number of arguments
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
AC::Type type()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
typ of the function or attribute
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
AC::Type argtype(int)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
types of the arguments
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
const char *signature()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
signature of the function or variable
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
unsigned id()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
identification of the join point
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
AC::Type resulttype()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
result type
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
AC::JPType jptype()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
type of join point
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
non-static methods:
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
void *arg(int)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
actual argument
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Result *result()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
result value
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
That *that()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
object referred to by 
\family typewriter
\size small
this
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Target *target()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
target object of a call
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
void proceed()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
execute join point code
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
AC::Action &action()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Action
\family default
 structure
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_layout Standard
\align center
Table 1: API of class 
\family typewriter
JoinPoint
\family default
 available in advice code
\end_layout

\begin_layout Standard
Types and static methods of the 
\family typewriter
JoinPoint
\family default
 API deliver information that is the same for every advice code activation.
 The non-static methods deliver information that differ from one activation
 to another.
 These methods are accessed by the object 
\family typewriter
tjp
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
tjp@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{tjp}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
runtime support!thisJoinPoint@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{thisJoinPoint}
\end_layout

\end_inset


\end_layout

\end_inset

 resp.
\begin_inset space ~
\end_inset


\family typewriter
thisJoinPoint
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
thisJoinPoint@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{thisJoinPoint}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
runtime support!thisJoinPoint@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{thisJoinPoint}
\end_layout

\end_inset


\end_layout

\end_inset

 which is of type 
\family typewriter
JoinPoint
\family default
 and is always available in advice code
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{comment}
\end_layout

\end_inset

 and introductions
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{comment}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

, too.
\end_layout

\begin_layout Standard
The following example illustrates how to implement a re-usable control flow
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
control flow
\end_layout

\end_inset

 aspect using the 
\family typewriter
JoinPoint
\family default
 API.
 
\end_layout

\begin_layout Subsubsection*
Example: re-usable trace aspect
\begin_inset CommandInset label
LatexCommand label
name "exa:re-usable-trace"

\end_inset


\end_layout

\begin_layout LyX-Code
aspect Trace {
\end_layout

\begin_layout LyX-Code
  pointcut virtual methods() = 0;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
  advice execution(methods()) : around() {
\end_layout

\begin_layout LyX-Code
    cout << "before " << JoinPoint::signature() << "(";
\end_layout

\begin_layout LyX-Code
    for (unsigned i = 0; i < JoinPoint::args(); i++)
\end_layout

\begin_layout LyX-Code
      printvalue(tjp->arg(i), JoinPoint::argtype(i));
\end_layout

\begin_layout LyX-Code
    cout << ")" << endl;
\end_layout

\begin_layout LyX-Code
    tjp->proceed()
\series bold
;
\end_layout

\begin_layout LyX-Code
    cout << "after" << endl;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
};
\end_layout

\begin_layout Standard
This aspect weaves tracing code into every function specified by the virtual
 pointcut
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pure virtual!pointcut
\end_layout

\end_inset

 redefined in a derived aspect.
 The helper function 
\family typewriter
printvalue
\family default
 is responsible for the formatted output of the arguments given at the function
 call.
 After calling 
\family typewriter
printvalue
\family default
 for every argument the program code of the actual join point is executed
 by calling 
\family typewriter
proceed
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
proceed@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{proceed()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}!proceed()@
\backslash
texttt{proceed()}
\end_layout

\end_inset


\end_layout

\end_inset

 on the 
\family typewriter
JoinPoint
\family default
 object.
 The functionality of 
\family typewriter
proceed
\family default
 is achieved by making use of the so-called actions.
\end_layout

\begin_layout Subsubsection
Actions
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
action
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

(
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
runtime support!action
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

(
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In AspectC++ an action is the statement sequence that would follow a reached
 join point in a running program if advice code would not have been activated.
 Thus 
\family typewriter
tjp->proceed()
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
proceed@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{proceed()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}!proceed()@
\backslash
texttt{proceed()}
\end_layout

\end_inset


\end_layout

\end_inset

 triggers the execution of the program code of a join point.
 This can be the call or execution of a function as well as the writing
 or reading of member variables or global variables.
 The actions concept is realized in the 
\family typewriter
AC::Action
\family default
 structure.
 In fact, 
\family typewriter
proceed
\family default
 is equivalent to 
\family typewriter
action().trigger()
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
trigger@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{trigger()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
action!trigger@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{trigger()}
\end_layout

\end_inset


\end_layout

\end_inset

 so that 
\family typewriter
tjp->proceed()
\family default
 may also be replaced by 
\family typewriter
tjp->action().trigger()
\family default
.
 Thereby the method 
\family typewriter
action()
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
action@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{action()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}!action@
\backslash
texttt{action()}
\end_layout

\end_inset


\end_layout

\end_inset

 of the 
\family typewriter
JoinPoint
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
runtime support!JoinPoint@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}
\end_layout

\end_inset


\end_layout

\end_inset

 API returns the actual action object for a join point.
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
runtime support!for advice code
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

)
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
advice!runtime support
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

)
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
action
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

)
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
runtime support!action
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{comment}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Support for Introductions
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
runtime support!for introductions
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

(
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
introduction!runtime support
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

(
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\family typewriter
JoinPoint
\family default
 API available in code introduced by an introduction is listed in the following
 table.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0cm">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
static methods:
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
const char *signature()
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
signature of the function or member variable
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
unsigned id()
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
identification of the join point
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
AC::JPType jptype()
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
type of join point
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
types:
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Aspect
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
type of the aspect
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout

\family typewriter
JoinPoint
\family default
 API for introductions
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In difference to the API available for advice code the API for introduction
 only provides static information about a join point.
 A nice demonstration of this API is shown in the following example.
\end_layout

\begin_layout Subsubsection*
Example: static type identification using introductions
\begin_inset CommandInset label
LatexCommand label
name "exa:static-type-id"

\end_inset


\end_layout

\begin_layout LyX-Code
aspect TypeInfo {
\end_layout

\begin_layout LyX-Code
  pointcut virtual typed() = 0;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
  advice typed() : static unsigned type_id() {
\end_layout

\begin_layout LyX-Code
    return JoinPoint::id();
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
  advice typed() : virtual unsigned type() { 
\end_layout

\begin_layout LyX-Code
    return type_id(); 
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
};
\end_layout

\begin_layout Standard
The first introduction of this aspect introduces a static method 
\family typewriter
type_id
\family default
 into a set of classes returning an unique integer value.
 By introducing a second non-static but virtual method type into these classes
 also returning the unique integer value a type identification can be realized
 like this:
\end_layout

\begin_layout LyX-Code
if (obj->type() == AClass::type_id())
\end_layout

\begin_layout LyX-Code
  ...
\end_layout

\begin_layout LyX-Code
else if (obj->type() == AnotherClass::type_id())
\end_layout

\begin_layout LyX-Code
  ...
\end_layout

\begin_layout Standard
This implements a nice alternative to the C++ RTTI mechanism especially
 when the RTTI support of a compiler is switched off.
 
\end_layout

\begin_layout Standard
Code of introductions have to use the type 
\family typewriter
Aspect
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Aspect@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{Aspect}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}!Aspect@
\backslash
texttt{Aspect}
\end_layout

\end_inset


\end_layout

\end_inset

 to get access to the methods and member variables of an aspect, e.g.
\begin_inset space ~
\end_inset

by calling 
\family typewriter
Aspect::aspectof()
\family default
.
 Because the static function 
\family typewriter
aspectof
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
aspectof@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{aspectof()}
\end_layout

\end_inset


\end_layout

\end_inset

 is always generated for an aspect, except when it is already explicitly
 defined, 
\family typewriter
aspectof
\family default
 always returns the actual aspect instance.
 By courtesy of this technique the example 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "exa:aspect-decl"

\end_inset

 can be changed to provide not only the count of all threads but to provide
 a count for every thread.
\end_layout

\begin_layout Subsubsection*
Example: 
\begin_inset CommandInset label
LatexCommand label
name "exa:extended-thread"

\end_inset

extended thread counting
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
runtime support
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

)
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
runtime support!for introductions
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

)
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
introduction!runtime support
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

)
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code
aspect Counter { 
\end_layout

\begin_layout LyX-Code
  int m_count;
\end_layout

\begin_layout LyX-Code
  ...
\end_layout

\begin_layout LyX-Code
  advice counted() : class Helper {
\end_layout

\begin_layout LyX-Code
    Helper() { Aspect::aspectof()->m_count++; }
\end_layout

\begin_layout LyX-Code
  } m_counter;
\end_layout

\begin_layout LyX-Code
  ...
\end_layout

\begin_layout LyX-Code
};
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{comment}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Match-Expressions"

\end_inset

Match Expressions
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
match expression
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

(
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
search pattern!match expression
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

(
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Match expressions are a used to describe a set of statically known program
 entities in a C++ source code.
 These program entities correspond to name join points.
 Therefore a match expression always returns a name pointcut.
  There can be match expressions for namespaces, classes, functions or variables.
\end_layout

\begin_layout Subsection
Commonly Used Matching Mechanisms
\begin_inset CommandInset label
LatexCommand label
name "subsec:Commonly-Used-Matchings"

\end_inset


\end_layout

\begin_layout Standard
This section describes matching mechanisms that are used in match expressions
 listed in sections 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Namspace-and-Class"

\end_inset

 to 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Variable-Matching"

\end_inset

.
\end_layout

\begin_layout Standard
The grammar used for match expression parsing is shown in appendix 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:Match-Expression-Grammar"

\end_inset

.
 The following subsections separately describe the name, scope, and type
 matching mechanisms.
 All of them are used in match expressions of functions and variables, while
 match expressions of namespaces and classes only uses name and scope matching.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Name-Matching"

\end_inset

Name Matching
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
match expression!name matching
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

(
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
name matching
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

(
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Name matching is trivial as long as the compared name is a normal C++ identifier.
 If the 
\emph on
name pattern
\emph default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
name pattern
\end_layout

\end_inset

 does 
\emph on
not
\emph default
 contain the special wildcard character %
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
%
\end_layout

\end_inset


\end_layout

\end_inset

, it matches a name only if it is exactly the same.
 Otherwise each wildcard character matches an arbitrary sequence of characters
 in the compared name.
 The wildcard character also matches an empty sequence.
\end_layout

\begin_layout Paragraph*
Example: simple name patterns 
\family typewriter

\begin_inset CommandInset label
LatexCommand label
name "exa:match-name-patterns"

\end_inset


\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
match expression!simple name pattern
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
simple name pattern
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="block" valignment="top" width="11cm">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Token
\end_layout

\end_inset
</cell>
<cell alignment="block" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
only matches 
\family typewriter
Token
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
%
\end_layout

\end_inset
</cell>
<cell alignment="block" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
matches any name
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
parse_%
\end_layout

\end_inset
</cell>
<cell alignment="block" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
matches any name beginning with 
\family typewriter
parse_
\family default
 like 
\family typewriter
parse_declarator
\family default
 or 
\family typewriter
parse_
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
parse_%_id%
\end_layout

\end_inset
</cell>
<cell alignment="block" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
matches names like 
\family typewriter
parse_type_id
\family default
, 
\family typewriter
parse_private_identifier
\family default
, etc.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
%_token
\end_layout

\end_inset
</cell>
<cell alignment="block" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
matches all names that end with 
\family typewriter
_token
\family default
 like 
\family typewriter
start_token
\family default
, 
\family typewriter
end_token
\family default
, and 
\family typewriter
_token
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Scope-Matching"

\end_inset

Scope Matching
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
match expression!scope matching
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

(
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
scope matching
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

(
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Restrictions on definition scopes can be described by 
\emph on
scope patterns
\emph default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
scope pattern
\end_layout

\end_inset

.
 This is a sequence of name patterns (or the special 
\emph on
any scope sequence
\emph default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
any scope sequence
\end_layout

\end_inset

pattern 
\family typewriter
...
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
...
\end_layout

\end_inset

), which are separated by 
\family typewriter
::
\family default
, like in 
\family typewriter
Puma::...::
\family default
.
 A scope pattern always ends with 
\family typewriter
::
\family default
 and should never start with 
\family typewriter
::
\family default
, because scope patterns are interpreted relative to the global scope anyway
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This restriction is also needed to avoid ambiguities in the match expression
 grammar: Does 
\begin_inset Quotes eld
\end_inset


\family typewriter
A
\begin_inset space ~
\end_inset

::
\begin_inset space ~
\end_inset

B
\begin_inset space ~
\end_inset

::
\begin_inset space ~
\end_inset

C(int)
\family default

\begin_inset Quotes erd
\end_inset

 mean 
\begin_inset Quotes eld
\end_inset


\family typewriter
A
\begin_inset space ~
\end_inset

::B::C(int)
\family default

\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset


\family typewriter
A::B
\begin_inset space ~
\end_inset

::C(int)
\family default

\begin_inset Quotes erd
\end_inset

?
\end_layout

\end_inset

.
 The definition scope can either be a namespace or a class.
\end_layout

\begin_layout Standard
A scope pattern matches the definition scope of a compared function or type
 if every part can successfully be matched with a corresponding part in
 the qualified name of the definition scope.
 The compared qualified name has to be relative to the global scope and
 should not start with 
\family typewriter
::
\family default
, which is optional in a C++ nested-name-specifier.
 The special 
\family typewriter
...

\family default
 pattern matches any (even empty) sequence of scope names.
 If no scope pattern is given, a compared namespace, class, function or
 variable has to be defined in the global scope to be matched.
\end_layout

\begin_layout Paragraph*
Example: scope patterns 
\family typewriter

\begin_inset CommandInset label
LatexCommand label
name "exa:match-scope-patterns"

\end_inset


\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
match expression!scope pattern
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
scope pattern
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="block" valignment="top" width="10cm">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
...::
\end_layout

\end_inset
</cell>
<cell alignment="block" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
matches any definition scope, even the global scope
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Puma::CCParser::
\end_layout

\end_inset
</cell>
<cell alignment="block" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
matches the scope 
\family typewriter
Puma::CCParser
\family default
 exactly
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
...::%Compiler%::
\end_layout

\end_inset
</cell>
<cell alignment="block" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
matches any class or namespace, which matches the name pattern 
\family typewriter
%Compiler%
\family default
, in any scope
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Puma::...::
\end_layout

\end_inset
</cell>
<cell alignment="block" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
matches any scope defined within the class or namespace 
\family typewriter
Puma
\family default
 and 
\family typewriter
Puma
\family default
 itself
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
scope matching
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

)
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
match expression!scope matching
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Type-Matching"

\end_inset

Type Matching
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
match expression!type matching
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

(
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
type matching
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

(
\end_layout

\end_inset


\end_layout

\begin_layout Standard
C++ types can be represented as a tree.
 For example, the function type 
\family typewriter
int(double)
\family default
 is a function type node with two children, one is an 
\family typewriter
int
\family default
 node, the other a 
\family typewriter
double
\family default
 node.
 Both children are leaves of the tree.
\end_layout

\begin_layout Standard
The types used in match expressions can also be interpreted as trees.
 As an addition to normal C++ types they can also contain the %
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
%
\end_layout

\end_inset


\end_layout

\end_inset

 wildcard character, name patterns, and scope patterns.
 A single wildcard character in a type pattern becomes a special 
\emph on
any type node
\emph default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
any type node
\end_layout

\end_inset

 in the tree representation.
\end_layout

\begin_layout Standard
For comparing a type pattern with a specific type the tree representation
 is used and the 
\emph on
any type node
\emph default
 matches an arbitrary type (sub-)tree.
 
\end_layout

\begin_layout Paragraph*
Example: type patterns with the wildcard character 
\family typewriter

\begin_inset CommandInset label
LatexCommand label
name "exa:match-type-patterns-wildcard"

\end_inset


\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
match expression!type pattern with 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
%
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
type pattern with 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
%
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="block" valignment="top" width="11cm">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
matches any type
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
void (*)(%)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
matches any pointer type that points to functions with a single argument
 and a 
\family typewriter
void
\family default
 result type
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%*
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
matches any pointer type
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Paragraph
Matching of Named Types
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Type patterns may also contain name and scope patterns.
 They become a 
\emph on
named type node
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
named type
\end_layout

\end_inset


\emph default
 in the tree representation and match any union, struct, class, or enumeration
 type if its name and scope match the given pattern (see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Name-Matching"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Scope-Matching"

\end_inset

).
\end_layout

\begin_layout Paragraph
Matching of 
\begin_inset Quotes eld
\end_inset

Pointer to Member
\begin_inset Quotes erd
\end_inset

 Types
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Patterns for pointers to members
\begin_inset Index idx
status open

\begin_layout Plain Layout
pointer to member
\end_layout

\end_inset

 also contain a scope pattern, e.g.
 
\family typewriter
%
\begin_inset space ~
\end_inset

(Puma::CSyntax::*)()
\family default
.
 In this context the scope pattern is mandatory.
 The pattern is used for matching the class associated with a pointer to
 member type.
\end_layout

\begin_layout Paragraph
Matching of Qualified Types (
\family typewriter
const
\family default
/
\family typewriter
volatile
\family default
)
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Many C++ types can be qualified as 
\family typewriter
const
\family default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
const
\end_layout

\end_inset

or 
\family typewriter
volatile
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
volatile
\end_layout

\end_inset

.
 In a type pattern these qualifier can also be used, but they are interpreted
 restrictions.
 If no 
\family typewriter
const
\family default
 or 
\family typewriter
volatile
\family default
 qualifier is given in a type pattern, the pattern also matches qualified
 types
\begin_inset Foot
status open

\begin_layout Plain Layout
Matching only non-constant or non-volatile types can be achieved by using
 the operators explained in section 
\begin_inset CommandInset ref
LatexCommand vref
reference "subsec:Algebraic-Operators"

\end_inset

.
 For example, 
\family typewriter
!"const
\begin_inset space ~
\end_inset

%"
\family default
 describes all types which are not constant.
\end_layout

\end_inset

.
\end_layout

\begin_layout Paragraph*
Example: type patterns with 
\family typewriter
const
\family default
 and 
\family typewriter
volatile
\family default
 
\family typewriter

\begin_inset CommandInset label
LatexCommand label
name "exa:match-type-patterns-cv"

\end_inset


\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
match expression!type pattern with cv qualifier
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
type pattern with cv qualifier
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="block" valignment="top" width="9cm">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
matches any type, even types qualified with 
\family typewriter
const
\family default
 or 
\family typewriter
volatile
\family default
 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
const %
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
matches only types qualified by 
\family typewriter
const
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
% (*)() const volatile
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
matches the type of all pointers to functions that are qualified by 
\family typewriter
const
\family default
 and 
\family typewriter
volatile
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Paragraph
Handling of Conversion Function Types
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
The result type of conversion functions is interpreted as a special 
\emph on
undefined
\emph default
 type in type patterns as well as in compared types.
 The 
\emph on
undefined
\emph default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
undefined type
\end_layout

\end_inset

 type is only matched by the 
\emph on
any type
\emph default
 node and the 
\emph on
undefined type
\emph default
 node.
\end_layout

\begin_layout Paragraph
Ellipses in Function Type Patterns
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
In the list of function argument types the type pattern 
\family typewriter
...

\family default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
...
\end_layout

\end_inset

can be used to match an arbitrary (even empty) list of types.
 The 
\family typewriter
...

\family default
 pattern should not be followed by other argument type patterns in the list
 of argument types.
\end_layout

\begin_layout Paragraph
Matching Virtual Functions
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
decl-specifier-seq
\emph default
 of a function type match expression may include the keyword 
\family typewriter
\size small
virtual
\family default
\size default
.
 In this case the function type match expression only matches virtual or
 pure virtual member functions.
 As 
\family typewriter
\size small
const
\family default
\size default
 and 
\family typewriter
\size small
volatile
\family default
\size default
, the 
\family typewriter
\size small
virtual
\family default
\size default
 keyword is regarded as a restriction.
 This means that a function type match expression without 
\family typewriter
\size small
virtual
\family default
\size default
 matches virtual and non-virtual functions.
\end_layout

\begin_layout Paragraph*
Example: type patterns with 
\family typewriter
virtual
\family default
 
\family typewriter

\begin_inset CommandInset label
LatexCommand label
name "exa:match-type-patterns-virtual"

\end_inset


\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
match expression!type pattern with virtual keyword
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
type pattern with virtual keyword
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="block" valignment="top" width="9cm">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
virtual % ...::%(...)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
matches all virtual or pure virtual functions in any scope
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
% C::%(...)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
matches all member functions of C, even if they are virtual
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Paragraph
Matching Static Functions
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Matching static functions works similar as matching virtual functions.
 The 
\emph on
decl-specifier-seq
\emph default
 of a function type match expression may include the keyword 
\family typewriter
\size small
static
\family default
\size default
.
 In this case the function type match expression only matches static functions
 in global or namespace scope and static member functions of classes.
 As 
\family typewriter
\size small
const
\family default
\size default
 and 
\family typewriter
\size small
volatile
\family default
\size default
, the 
\family typewriter
\size small
static
\family default
\size default
 keyword is regarded as a restriction.
 This means that a function type match expression without 
\family typewriter
\size small
static
\family default
\size default
 matches static and non-static functions.
\end_layout

\begin_layout Paragraph*
Example: type patterns with 
\family typewriter
static
\family default
 
\family typewriter

\begin_inset CommandInset label
LatexCommand label
name "exa:match-type-patterns-static"

\end_inset


\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
match expression!type pattern with static keyword
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
type pattern with static keyword
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="block" valignment="top" width="9cm">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
static % ...::%(...)
\end_layout

\end_inset
</cell>
<cell alignment="block" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
matches all static member and non-member functions in any scope
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
% C::%(...)
\end_layout

\end_inset
</cell>
<cell alignment="block" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
matches all member functions of C, even if they are static
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Paragraph
Argument Type Adjustment
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Argument types 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
argument types
\end_layout

\end_inset

 in type patterns are adjusted according to the usual C++ rules, i.e.
 array and function types are converted to pointers to the given type and
 
\family typewriter
const
\family default
/
\family typewriter
volatile
\family default
 qualifiers are removed.
 Furthermore, argument type lists containing a single 
\family typewriter
void
\family default
 type are converted into an empty argument type list.
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
type matching
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

)
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
match expression!type matching
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

)
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
match expression
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

)
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
search pattern!match expression
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Namespace and Class Match Expressions
\begin_inset CommandInset label
LatexCommand label
name "subsec:Namspace-and-Class"

\end_inset


\end_layout

\begin_layout Standard
For namespaces and classes the matching process is special because it consists
 of two steps.
\end_layout

\begin_layout Standard
First, each namespace and class is compared with a given match expression.
 A match expression that matches a namespace or class begins with the optional
 scope part and ends with the required name part.
 In course of this step the matching name join points are collected in a
 temporary pointcut.
 
\end_layout

\begin_layout Subsubsection*
Example: scope and name parts of a namespace or class match expression 
\family typewriter

\begin_inset CommandInset label
LatexCommand label
name "exa:match-expr-parts-namespaces-classes"

\end_inset


\end_layout

\begin_layout LyX-Code
"Puma::...::Parser%"
\end_layout

\begin_layout Standard
This match expression describes the following requirements on a compared
 namespace or class:
\end_layout

\begin_layout Description
scope: the scope in which the namespace or class is defined has to match
 
\family typewriter
Puma::...::
\end_layout

\begin_layout Description
name: the name of the namespace or class has to match the name pattern 
\family typewriter
Parser%
\end_layout

\begin_layout Standard
For more information about these parts see sections 
\begin_inset CommandInset ref
LatexCommand nameref
reference "subsec:Scope-Matching"

\end_inset

 
\begin_inset CommandInset ref
LatexCommand eqref
reference "subsec:Scope-Matching"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand nameref
reference "subsec:Name-Matching"

\end_inset

 
\begin_inset CommandInset ref
LatexCommand eqref
reference "subsec:Name-Matching"

\end_inset

.
 
\end_layout

\begin_layout Standard
In the second step the temporary pointcut will be extended by contained
 name join points yielding the result pointcut.
 The extension rules are as follows:
\end_layout

\begin_layout Itemize
If a namespace 
\emph on
N
\emph default
 is matched, the resulting pointcut additionally contains the following
 name join points:
\begin_inset Newline newline
\end_inset

all functions, variables, (nested) classes, member functions, data members,
 constructors and destructors that are anywhere and arbitrary nested inside
 
\emph on
N
\emph default
.
 
\end_layout

\begin_layout Itemize
If a class 
\emph on
C
\emph default
 is matched, the resulting pointcut additionally contains the following
 name join points:
\begin_inset Newline newline
\end_inset

all member functions, data members and constructors of 
\emph on
C
\emph default
 as well as the destructor of 
\emph on
C
\emph default
 that are directly located inside 
\emph on
C
\emph default
.
 So name join points that are nested inside a member function, a data member
 or a nested class are 
\series bold
not
\series default
 added to the pointcut.
\end_layout

\begin_layout Standard
The following list contains example match expressions and the results after
 the first as well as after the second step.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
steptwodescribedabove}{
\backslash
textit{step one extended as described in step two}}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="block" valignment="top" width="5cm">
<column alignment="block" valignment="top" width="5.5cm">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="block" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset

 
\series bold
after step one
\end_layout

\end_inset
</cell>
<cell alignment="block" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset

 
\series bold
result
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Token
\end_layout

\end_inset
</cell>
<cell alignment="block" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
only matches namespaces or classes with the name 
\family typewriter
Token 
\family default
that are directly inside the global namespace
\end_layout

\end_inset
</cell>
<cell alignment="block" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
steptwodescribedabove
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
...::Token
\end_layout

\end_inset
</cell>
<cell alignment="block" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
matches 
\family typewriter
Token
\family default
 at arbitrary location
\end_layout

\end_inset
</cell>
<cell alignment="block" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
steptwodescribedabove
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
%
\end_layout

\end_inset
</cell>
<cell alignment="block" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
matches any namespace or class that is directly located in the global namespace
 but not the global namespace itself
\end_layout

\end_inset
</cell>
<cell alignment="block" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
matches any namespace except the global namespace, any class that is arbitrary
 nested in a non-global namespace, any class directly located in the global
 namespace and all functions, member functions, variables, data members,
 constructors and destructors that are contained in one of the just mentioned
 entities
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
::
\end_layout

\end_inset
</cell>
<cell alignment="block" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
matches the global namespace
\end_layout

\end_inset
</cell>
<cell alignment="block" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
matches any function, variable, (nested) class, member function, data member,
 constructor or destructor
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="block" valignment="top" width="6.2cm">
<column alignment="block" valignment="top" width="3.7cm">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="block" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset

 
\series bold
after step one
\end_layout

\end_inset
</cell>
<cell alignment="block" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset

 
\series bold
result
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
OOStuBS::CGA%
\end_layout

\end_inset
</cell>
<cell alignment="block" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
matches any namespace or class inside 
\family typewriter
OOStuBS
\family default
 beginning with 
\family typewriter
CGA
\family default
 like 
\family typewriter
OOStuBS::CGA, OOStuBS::CGA_Screen
\family default
 or 
\family typewriter
OOStuBS::CGA_Stream
\family default
.
 Note that this matches 
\family typewriter
OOStuBS 
\family default
only inside the global namespace.
\end_layout

\end_inset
</cell>
<cell alignment="block" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
steptwodescribedabove
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
%::Smtp%Bldr%
\end_layout

\end_inset
</cell>
<cell alignment="block" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
matches namespaces and classes like 
\family typewriter
SmtpBldr, SmtpClientBldr
\family default
 or
\family typewriter
 SmtpServerBldrCreator
\family default
, that are nested in exact one namespace or class.
\end_layout

\end_inset
</cell>
<cell alignment="block" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
steptwodescribedabove
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
%Node
\end_layout

\end_inset
</cell>
<cell alignment="block" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
matches any namespace or class ending with 
\family typewriter
Node
\family default
 like 
\family typewriter
ModelNode, GraphNode
\family default
 and 
\family typewriter
Node
\end_layout

\end_inset
</cell>
<cell alignment="block" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
steptwodescribedabove
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset VSpace bigskip
\end_inset

Please note that local classes inside functions or member functions are
 never matched.
\end_layout

\begin_layout Subsection
Function Match Expressions
\end_layout

\begin_layout Standard
For function (or member function) matching a match expression is internally
 decomposed into the function type pattern
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
type pattern
\end_layout

\end_inset

, the scope pattern
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
scope pattern
\end_layout

\end_inset

, and the name pattern
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
name pattern
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection*
Example: type, scope, and name parts of a function match expression 
\family typewriter

\begin_inset CommandInset label
LatexCommand label
name "exa:match-expr-parts-functions"

\end_inset


\end_layout

\begin_layout LyX-Code
"const % Puma::...::parse_% (Token *)"
\end_layout

\begin_layout Standard
This match expression describes the following requirements on a compared
 function name:
\end_layout

\begin_layout Description
name: the function name has to match the name pattern 
\family typewriter
parse_%
\end_layout

\begin_layout Description
scope: the scope in which the function is defined has to match 
\family typewriter
Puma::...::
\end_layout

\begin_layout Description
type: the function type has to match 
\family typewriter
const %(Token *)
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
For classes and other types this decomposion is not necessary.
 For example, the type name 
\begin_inset Quotes eld
\end_inset


\family typewriter
Puma::CCParser
\family default

\begin_inset Quotes erd
\end_inset

 is sufficient to describe a class, because this is the same as the class
 name.
\end_layout

\end_inset

If an entity matches all parts of the match expression, it becomes an element
 of the pointcut, which is defined and returned by the match expression.
\end_layout

\begin_layout Standard
Common descriptions of name, scope and type matching can be found in section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Commonly-Used-Matchings"

\end_inset

.
 The following sections additionally describe the name matching of special
 functions.
\end_layout

\begin_layout Subsubsection
Operator Function and Conversion Function Name Matching
\end_layout

\begin_layout Standard
The name matching mechanism is more complicated if the pattern is compared
 with the name of a conversion function or an operator function.
 Both are matched by the name pattern 
\family typewriter
%
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
%
\end_layout

\end_inset


\end_layout

\end_inset

.
 However, with a different name pattern than 
\family typewriter
%
\family default
 they are only matched if the pattern begins with "
\family typewriter
operator
\family default

\begin_inset space ~
\end_inset

".
 The pattern "
\family typewriter
operator
\begin_inset space ~
\end_inset

%
\family default
" matches any operator function or conversion function name.
\end_layout

\begin_layout Standard
C++ defines a fixed set of operators which are allowed to be overloaded.
 In a name pattern the same operators may be used after the "
\family typewriter
operator
\family default

\begin_inset space ~
\end_inset

" prefix to match a specific operator function name.
 Operator names in name patterns are not allowed to contain the wildcard
 character.
 For ambiguity resolution the operators 
\family typewriter
%
\family default
 and 
\family typewriter
%=
\family default
 are matched by 
\family typewriter
%%
\family default
 and 
\family typewriter
%%=
\family default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
%
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
%
\end_layout

\end_inset


\end_layout

\end_inset

in a name pattern.
\end_layout

\begin_layout Paragraph*
Example: operator name patterns
\begin_inset Index idx
status open

\begin_layout Plain Layout
match expression!operator name pattern
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
operator name pattern
\end_layout

\end_inset


\family typewriter

\begin_inset CommandInset label
LatexCommand label
name "exa:match-operator-name-patterns"

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="block" valignment="top" width="11cm">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
operator
\begin_inset space ~
\end_inset

%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
matches any operator function name (as well as any conversion function name)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
operator
\begin_inset space ~
\end_inset

+=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
matches only the name of a 
\family typewriter
+=
\family default
 operator
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
operator
\begin_inset space ~
\end_inset

%%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
matches the name of an 
\family typewriter
operator
\begin_inset space ~
\end_inset

%
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Conversion functions don't have a real name.
 For example, the conversion function 
\family typewriter
operator int*()
\family default
 defined in a class 
\family typewriter
C
\family default
 defines a conversion from a 
\family typewriter
C
\family default
 instance into an object of type 
\family typewriter
int*
\family default
.
 To match conversion functions the name pattern may contain a type pattern
 after the prefix "
\family typewriter
operator
\family default
 ".
 The type matching mechanism is explained in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Type-Matching"

\end_inset

.
\end_layout

\begin_layout Paragraph*
Example: conversion function name patterns
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
match expression!conversion function name pattern
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
conversion function name pattern
\end_layout

\end_inset


\family typewriter

\begin_inset CommandInset label
LatexCommand label
name "exa:match-conversion-function-name-patterns"

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="block" valignment="top" width="11cm">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
operator
\begin_inset space ~
\end_inset

%
\end_layout

\end_inset
</cell>
<cell alignment="block" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
matches any conversion function name
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
operator
\begin_inset space ~
\end_inset

int*
\end_layout

\end_inset
</cell>
<cell alignment="block" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
matches any name of a conversion that converts something into an 
\family typewriter
int*
\family default
 object
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
operator
\begin_inset space ~
\end_inset

%*
\end_layout

\end_inset
</cell>
<cell alignment="block" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
matches any conversion function name if that function converts something
 into a pointer
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Constructors and Destructors
\end_layout

\begin_layout Standard
Name patterns cannot be used to match constructor or destructor names.
\end_layout

\begin_layout Subsection
Variable Match Expressions
\begin_inset CommandInset label
LatexCommand label
name "subsec:Variable-Matching"

\end_inset


\end_layout

\begin_layout Standard
For variable (or member) matching a match expression is internally decomposed
 into the variable type pattern
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
type pattern
\end_layout

\end_inset

, the scope pattern
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
scope pattern
\end_layout

\end_inset

, and the name pattern
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
name pattern
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection*
Example: type, scope, and name parts of a variable match expression 
\family typewriter

\begin_inset CommandInset label
LatexCommand label
name "exa:match-expr-parts-variable"

\end_inset


\end_layout

\begin_layout LyX-Code
"const % Puma::...::parsed_%"
\end_layout

\begin_layout Standard
This match expression describes the following requirements on a compared
 variable name:
\end_layout

\begin_layout Description
name: the variable name has to match the name pattern 
\family typewriter
parsed_%
\end_layout

\begin_layout Description
scope: the scope in which the variable is defined has to match 
\family typewriter
Puma::...::
\end_layout

\begin_layout Description
type: the variable type has to match 
\family typewriter
const %
\end_layout

\begin_layout Standard
If an entity matches all parts of the match expression, it becomes an element
 of the pointcut, which is defined and returned by the match expression.
\end_layout

\begin_layout Standard
Descriptions of name, scope and type matching can be found in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Commonly-Used-Matchings"

\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO?: The following sections additionally describe the name matching of
 special variables.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Predefined Pointcut Functions
\begin_inset CommandInset label
LatexCommand label
name "sec:Predefined"

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pointcut function
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

(
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pointcut!function
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

(
\end_layout

\end_inset


\end_layout

\begin_layout Standard
On the following pages a complete list of the pointcut functions supported
 by AspectC++ is presented.
 For every pointcut function it is indicated which type of pointcut is expected
 as argument(s) and of which type the result pointcut is.
 Thereby 
\begin_inset Quotes eld
\end_inset

N
\begin_inset Quotes erd
\end_inset

 stands for name pointcut and 
\begin_inset Quotes eld
\end_inset

C
\begin_inset Quotes erd
\end_inset

 for code pointcut.
 The optionally given index is an assurance about the type of join point(s)
 described by the result pointcut
\begin_inset Foot
status open

\begin_layout Plain Layout
C, C
\begin_inset Formula $_{\textrm{C}}$
\end_inset

, C
\begin_inset Formula $_{\textrm{E}}$
\end_inset

, C
\begin_inset Formula $_{\textrm{B}}$
\end_inset

, C
\begin_inset Formula $_{\textrm{S}}$
\end_inset

, C
\begin_inset Formula $_{\textrm{G}}$
\end_inset

: Code (any, only 
\emph on
\bar under
C
\bar default
all
\emph default
 (without Builtin), only 
\emph on
\bar under
E
\bar default
xecution
\emph default
, only 
\emph on
\bar under
B
\bar default
uiltin
\emph default
, only 
\emph on
\bar under
S
\bar default
et
\emph default
, only 
\emph on
\bar under
G
\bar default
et
\emph default
); N, N
\begin_inset Formula $_{N}$
\end_inset

, N
\begin_inset Formula $_{C}$
\end_inset

, N
\begin_inset Formula $_{F}$
\end_inset

, N
\begin_inset Formula $_{T}$
\end_inset

N
\begin_inset Formula $_{V}$
\end_inset

: Names (any, only 
\emph on
\bar under
N
\bar default
amespace
\emph default
, only 
\emph on
\bar under
C
\bar default
lass
\emph default
, only 
\emph on
\bar under
F
\bar default
unction
\emph default
, only 
\emph on
\bar under
T
\bar default
ype
\emph default
, only 
\emph on
\bar under
V
\bar default
ariable
\emph default
)
\end_layout

\end_inset

.
 If a pointcut is used as argument of a pointcut function and the type of
 some join points in argument pointcut does not match one of the expected
 argument types of the pointcut function, these non-matching join points
 are silently ignored.
\end_layout

\begin_layout Subsection
Types
\end_layout

\begin_layout Description
base
\series medium
(
\emph on
pointcut
\emph default
)
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
base@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{base()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pointcut function!base@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{base()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hfill 
\end_layout

\end_inset

N
\begin_inset Formula $_{C,F,V}$
\end_inset


\begin_inset Formula $\rightarrow$
\end_inset

N
\begin_inset Formula $_{C,F,V}$
\end_inset


\begin_inset Newline newline
\end_inset

returns a pointcut 
\shape italic

\begin_inset Formula $p_{b}$
\end_inset


\shape default
 of name join points created as follows
\begin_inset Newline newline
\end_inset


\shape italic

\begin_inset Formula $p_{b}\leftarrow\{$
\end_inset


\shape default
all base classes of classes in 
\shape italic
pointcut
\shape default
 but not the classes in 
\shape italic
pointcut
\shape default

\begin_inset Formula $\}$
\end_inset

,
\begin_inset Newline newline
\end_inset


\shape italic

\begin_inset Formula $p_{b}\leftarrow p{}_{b}\,||\,\{$
\end_inset


\shape default
all member functions and data members of classes in 
\begin_inset Formula $p_{b}$
\end_inset


\begin_inset Formula $\}$
\end_inset

,
\begin_inset Newline newline
\end_inset


\shape italic

\begin_inset Formula $p_{b}\leftarrow p{}_{b}\,||\,\{$
\end_inset


\shape default
all previous definitions of member functions in 
\shape italic
pointcut
\shape default
 but not the member functions in 
\shape italic
pointcut
\shape default

\begin_inset Formula $\}$
\end_inset

,
\begin_inset Newline newline
\end_inset


\shape italic

\begin_inset Formula $p_{b}\leftarrow p{}_{b}\,||\,\{$
\end_inset


\shape default
all previous definitions of data members in 
\shape italic
pointcut
\shape default
 but not the data members in 
\shape italic
pointcut
\shape default

\begin_inset Formula $\}$
\end_inset


\end_layout

\begin_layout Description

\shape italic
\begin_inset Note Note
status open

\begin_layout Description
base
\series medium
(
\emph on
pointcut
\emph default
)
\series default
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hfill 
\end_layout

\end_inset

N
\begin_inset Formula $_{F}$
\end_inset


\begin_inset Formula $\rightarrow$
\end_inset

N
\begin_inset Formula $_{F}$
\end_inset


\begin_inset Newline newline
\end_inset

returns all previous definitions of member-functions in 
\shape italic
pointcut
\shape default
 but not the member-functions in 
\shape italic
pointcut
\end_layout

\begin_layout Description
base
\series medium
(
\emph on
pointcut
\emph default
)
\series default
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hfill 
\end_layout

\end_inset

N
\begin_inset Formula $_{V}$
\end_inset


\begin_inset Formula $\rightarrow$
\end_inset

N
\begin_inset Formula $_{V}$
\end_inset


\begin_inset Newline newline
\end_inset

returns all previous definitions of members in 
\shape italic
pointcut
\shape default
 but not the members in 
\shape italic
pointcut
\end_layout

\end_inset


\end_layout

\begin_layout Description
derived
\series medium
(
\emph on
pointcut
\emph default
)
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
derived@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{derived()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pointcut function!derived@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{derived()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hfill 
\end_layout

\end_inset

N
\begin_inset Formula $_{C,F,V}$
\end_inset


\begin_inset Formula $\rightarrow$
\end_inset

N
\begin_inset Formula $_{C,F,V}$
\end_inset


\begin_inset Newline newline
\end_inset

returns a pointcut 
\shape italic

\begin_inset Formula $p_{d}$
\end_inset


\shape default
 of name join points created as follows
\begin_inset Newline newline
\end_inset


\shape italic

\begin_inset Formula $p_{d}\leftarrow\{$
\end_inset


\shape default
all classes in 
\shape italic
pointcut
\shape default
 and all classes derived from them
\begin_inset Formula $\}$
\end_inset

,
\begin_inset Newline newline
\end_inset


\shape italic

\begin_inset Formula $p_{d}\leftarrow p{}_{d}\,||\,\{$
\end_inset


\shape default
all member functions and data members of classes in 
\begin_inset Formula $p_{d}$
\end_inset


\begin_inset Formula $\}$
\end_inset

,
\begin_inset Newline newline
\end_inset


\shape italic

\begin_inset Formula $p_{d}\leftarrow p{}_{d}\,||\,\{$
\end_inset


\shape default
all member functions in 
\shape italic

\begin_inset Formula $pointcut$
\end_inset


\shape default
 and all redefinitions of these member functions in derived classes
\begin_inset Formula $\}$
\end_inset

,
\begin_inset Newline newline
\end_inset


\shape italic

\begin_inset Formula $p_{d}\leftarrow p{}_{d}\,||\,\{$
\end_inset


\shape default
all data members in 
\shape italic

\begin_inset Formula $pointcut$
\end_inset


\shape default
 and all redefinitions of these data members in derived classes
\begin_inset Formula $\}$
\end_inset


\end_layout

\begin_layout Subsubsection*
Example: derived function matching
\begin_inset CommandInset label
LatexCommand label
name "exa:derived_function_matching"

\end_inset


\end_layout

\begin_layout LyX-Code
struct A {};
\end_layout

\begin_layout LyX-Code

\family typewriter
struct B : public A { void f(); };
\end_layout

\begin_layout LyX-Code

\family typewriter
struct C : public B { void f(); };
\end_layout

\begin_layout LyX-Code

\family typewriter
aspect Z {
\end_layout

\begin_layout LyX-Code

\family typewriter
  advice execution(derived("A")) : before() {
\end_layout

\begin_layout LyX-Code

\family typewriter
    // before execution of B::f() or C::f()
\end_layout

\begin_layout LyX-Code

\family typewriter
  }
\end_layout

\begin_layout LyX-Code

\family typewriter
};
\end_layout

\begin_layout Subsubsection*
Example: type matching
\begin_inset CommandInset label
LatexCommand label
name "exa:type-matching"

\end_inset


\end_layout

\begin_layout Standard
A software may contain the following class hierarchy.
 
\end_layout

\begin_layout LyX-Code
class Shape { ...
 };
\end_layout

\begin_layout LyX-Code
class Scalable { ...
 };
\end_layout

\begin_layout LyX-Code
class Point : public Shape { ...
 };
\end_layout

\begin_layout LyX-Code
...
\end_layout

\begin_layout LyX-Code
class Rectangle : public Line, public Rotatable { ...
 };
\end_layout

\begin_layout Standard
With the following aspect a special feature is added to a designated set
 of classes of this class hierarchy.
\end_layout

\begin_layout LyX-Code
aspect Scale {
\end_layout

\begin_layout LyX-Code
  pointcut scalable() = "Rectangle" ||
\end_layout

\begin_layout LyX-Code
    (base("Rectangle") && derived("Point"));
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
  advice "Point" : slice class : public Scalable;
\end_layout

\begin_layout LyX-Code
  advice scalable() : slice class { 
\end_layout

\begin_layout LyX-Code
      void scale(int value) { ...
 }
\end_layout

\begin_layout LyX-Code
  };
\end_layout

\begin_layout LyX-Code
};
\end_layout

\begin_layout Standard
The pointcut describes the classes 
\family typewriter
Point
\family default
 and 
\family typewriter
Rectangle
\family default
 and all classes derived from 
\family typewriter
Point
\family default
 that are direct or indirect base classes of 
\family typewriter
Rectangle
\family default
.
 With the first advice 
\family typewriter
Point
\family default
 gets a new base class.
 The second advice adds a corresponding method to all classes in the pointcut.
\end_layout

\begin_layout Subsection
Control Flow
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
control flow
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

(
\end_layout

\end_inset


\end_layout

\begin_layout Description
cflow
\series medium
(
\emph on
pointcut
\emph default
)
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
cflow@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{cflow()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pointcut function!cflow@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{cflow()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hfill 
\end_layout

\end_inset

C
\begin_inset Formula $\rightarrow$
\end_inset

C
\begin_inset Newline newline
\end_inset

captures join points occurring in the dynamic execution context of join
 points in 
\shape italic
pointcut
\shape default
.
 Currently the language features being used in the argument pointcut are
 restricted.
 The argument is not allowed to contain any context variable bindings (see
 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:context"

\end_inset

) or other pointcut functions which have to be evaluated at runtime like
 
\series bold
cflow
\series default
(
\emph on
pointcut
\emph default
) itself.
\end_layout

\begin_layout Subsubsection*
Example: control flow dependant advice activation
\begin_inset CommandInset label
LatexCommand label
name "exa:control-flow"

\end_inset


\end_layout

\begin_layout Standard
The following example demonstrates the use of the 
\series bold
cflow
\series default
 pointcut function.
\end_layout

\begin_layout LyX-Code
class Bus {
\end_layout

\begin_layout LyX-Code
  void out (unsigned char);
\end_layout

\begin_layout LyX-Code
  unsigned char in ();
\end_layout

\begin_layout LyX-Code
};
\end_layout

\begin_layout Standard
Consider the class 
\family typewriter
Bus
\family default
 shown above.
 It might be part of an operating system kernel and is used there to access
 peripheral devices via a special I/O bus.
 The execution of the member functions 
\family typewriter
in()
\family default
 and 
\family typewriter
out()
\family default
 should not be interrupted, because this would break the timing of the bus
 communication.
 Therefore, we decide to implement an interrupt synchronization aspect that
 disables interrupts during the execution of in() and out():
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},breaklines=true,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

aspect BusIntSync {
\end_layout

\begin_layout Plain Layout

  pointcut critical() = execution("% Bus::%(...)");
\end_layout

\begin_layout Plain Layout

  advice critical() && !cflow(execution("% os::int_handler()")) : around()
 {
\end_layout

\begin_layout Plain Layout

    os::disable_ints();
\end_layout

\begin_layout Plain Layout

    tjp->proceed();
\end_layout

\begin_layout Plain Layout

    os::enable_ints();
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

};
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As the bus driver code might also be called from an interrupt handler, the
 interrupts should not be disabled in any case.
 Therefore, the pointcut expression exploits the 
\series bold
cflow()
\series default
 pointcut function to add a runtime condition for the advice activation.
 The advice body should only be executed if the control flow did not come
 from the interrupt handler 
\family typewriter
os::int_handler()
\family default
, because it is not interruptable by definition and 
\family typewriter
os::enable_ints()
\family default
 in the advice body would turn on the interrupts too early.
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
control flow
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Scope
\end_layout

\begin_layout Description
within
\series medium
(
\emph on
pointcut
\emph default
)
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
within@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{within()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pointcut function!within@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{within()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hfill 
\end_layout

\end_inset

N
\begin_inset Formula $\rightarrow$
\end_inset

C
\begin_inset Newline newline
\end_inset

returns all code join points that are located directly inside or at a name
 join point in 
\shape italic
pointcut
\end_layout

\begin_layout Description
member
\series medium
(
\emph on
pointcut
\emph default
)
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
member@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{member()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pointcut function!member@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{member()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hfill 
\end_layout

\end_inset

N
\begin_inset Formula $\rightarrow$
\end_inset

N
\begin_inset Newline newline
\end_inset

maps the scopes given in 
\emph on
pointcut
\emph default
 to any contained named entities.
 Thus a class name for example is mapped to all contained member functions,
 variables and nested types.
\end_layout

\begin_layout Subsubsection*
Example: matching in scopes
\begin_inset CommandInset label
LatexCommand label
name "exa:matching-in-scopes"

\end_inset


\end_layout

\begin_layout LyX-Code
aspect Logger {
\end_layout

\begin_layout LyX-Code
  pointcut calls() =
\end_layout

\begin_layout LyX-Code
    call("void transmit()") && within("Transmitter");
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
  advice calls() : around() {
\end_layout

\begin_layout LyX-Code
    cout << "transmitting ...
 " << flush;
\end_layout

\begin_layout LyX-Code
    tjp->proceed();
\end_layout

\begin_layout LyX-Code
    cout << "finished." << endl;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
};
\end_layout

\begin_layout Standard
This aspect inserts code logging all calls to 
\family typewriter
transmit
\family default
 that are within the methods of class 
\family typewriter
Transmitter
\family default
.
 
\end_layout

\begin_layout Subsection
Functions
\begin_inset CommandInset label
LatexCommand label
name "subsec:Functions"

\end_inset


\end_layout

\begin_layout Description
call
\series medium
(
\emph on
pointcut
\emph default
)
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
call@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{call()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pointcut function!call@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{call()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hfill 
\end_layout

\end_inset

N
\begin_inset Formula $_{F}$
\end_inset


\begin_inset Formula $\rightarrow$
\end_inset

C
\begin_inset Formula $_{C}$
\end_inset


\begin_inset Newline newline
\end_inset

returns all code join points where a user provided function or member function
 in 
\shape italic
pointcut
\shape default
 is called.
 The resulting join points are located in the scope of the resp.
 caller meaning where the function or member functions is called.
 The pointcut does not include join points at calls to built-in operators.
 
\end_layout

\begin_layout Description
execution
\series medium
(
\emph on
pointcut
\emph default
)
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
execution@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{execution()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
pointcut function!execution@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{execution()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hfill 
\end_layout

\end_inset

N
\begin_inset Formula $_{F}$
\end_inset


\begin_inset Formula $\rightarrow$
\end_inset

C
\begin_inset Formula $_{E}$
\end_inset


\begin_inset Newline newline
\end_inset

returns all code join points where a function or member function in 
\shape italic
pointcut
\shape default
 is executed.
 The resulting join points are located in the scope of the callee meaning
 where the function or member function is defined/implemented.
\end_layout

\begin_layout Subsubsection*
Example: function matching
\begin_inset CommandInset label
LatexCommand label
name "exa:function-matching"

\end_inset


\end_layout

\begin_layout Standard
The following aspect weaves debugging code into a program that checks whether
 a method is called on a null pointer and whether the argument of the call
 is null.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},breaklines=true,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

aspect Debug {
\end_layout

\begin_layout Plain Layout

  pointcut fct() = "% MemPool::dealloc(void*)";
\end_layout

\begin_layout Plain Layout

  pointcut exec() = execution(fct());
\end_layout

\begin_layout Plain Layout

  pointcut calls() = call(fct());
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  advice exec() && args(ptr) : before(void *ptr) {
\end_layout

\begin_layout Plain Layout

    assert(ptr && "argument is NULL");
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  advice calls() : before() {
\end_layout

\begin_layout Plain Layout

    assert(tjp->target() && "'this' is NULL");
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

};
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first advice provides code to check the argument of the function 
\family typewriter
dealloc
\family default
 before the function is executed.
 A check whether 
\family typewriter
dealloc
\family default
 is called on a null object is provided by the second advice.
 This is realized by checking the target of the call.
\end_layout

\begin_layout Subsection
Built-in Operators
\begin_inset CommandInset label
LatexCommand label
name "subsec:builtin_operators"

\end_inset


\end_layout

\begin_layout Description
builtin
\series medium
(
\emph on
pointcut
\emph default
)
\series default
 
\begin_inset Index idx
status open

\begin_layout Plain Layout
builtin@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{builtin()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
pointcut function!builtin@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{builtin()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
built-in operators!builtin@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{builtin()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hfill 
\end_layout

\end_inset

N
\begin_inset Formula $_{F}$
\end_inset


\begin_inset Formula $\rightarrow$
\end_inset

C
\begin_inset Formula $_{B}$
\end_inset


\begin_inset Newline newline
\end_inset

returns all code join points where a built-in operator in 
\shape italic
pointcut
\shape default
 is called.
\begin_inset Newline newline
\end_inset

This pointcut function does not return join points at constructor or destructor
 calls.
 See section 
\begin_inset CommandInset ref
LatexCommand nameref
reference "subsec:Object-Construction-and"

\end_inset

 (
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Object-Construction-and"

\end_inset

) to find out how to describe these join points.
\begin_inset Newline newline
\end_inset

The builtin pointcut function is a new feature that was introduced in version
 2.0 and is therefore not enabled by default to avoid compatibility issues
 (e.g., if someone named a pointcut 
\begin_inset Quotes eld
\end_inset

builtin
\begin_inset Quotes erd
\end_inset

).
 The 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{{-}{-}builtin
\backslash
_operators} 
\end_layout

\end_inset

 command-line argument enables the described functionality.
\end_layout

\begin_layout Standard
The intersection of the results of 
\series bold
call
\series default
 and 
\series bold
builtin
\series default
 always yields the empty pointcut:
\begin_inset Newline newline
\end_inset

call(
\emph on
pointcut
\emph default
)
\begin_inset space ~
\end_inset

&&
\series medium
\emph on

\begin_inset space ~
\end_inset


\series default
\emph default
builtin(
\series medium
\emph on
pointcut
\series default
\emph default
)
\series medium
\emph on
 
\series default
\emph default
= 
\begin_inset Formula $\varnothing\quad\forall$
\end_inset


\emph on
pointcut
\end_layout

\begin_layout Subsubsection*
Example: operator matching
\begin_inset CommandInset label
LatexCommand label
name "exa:builtin-matching"

\end_inset


\end_layout

\begin_layout Standard
The following aspect weaves code into a program that checks whether a null-point
er will be dereferenced.
 If this occurs, the advice will provide the code position on the error
 stream.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},breaklines=true,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

aspect ProblemReporter {
\end_layout

\begin_layout Plain Layout

  advice builtin("% operator *(%)") : before() {
\end_layout

\begin_layout Plain Layout

    if(*tjp->arg<0>() == 0) {    
\end_layout

\begin_layout Plain Layout

      cerr << tjp->filename() << " (Line " << tjp->line() << "): dereferencing
 of null-pointer!" << endl;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

};
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Limitations
\begin_inset CommandInset label
LatexCommand label
name "subsec:builtin_limitations"

\end_inset


\begin_inset Index CommandInset label
status open

\begin_layout Plain Layout
builtin!limitations
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
built-in operators!limitations
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Some built-in operators could not be fully supported.
 For example, weaving advice code for built-in operators in 
\series bold
constant expressions
\series default
 would destroy the constancy of the expressions and inhibit evaluation at
 compile time.
 Therefore, operators in constant expressions are not matched.
 The following code listing gives some examples for operators in constant
 expressions.
\begin_inset listings
lstparams "basicstyle={\ttfamily},breaklines=true,tabsize=2"
inline false
status open

\begin_layout Plain Layout

class ExampleClass {
\end_layout

\begin_layout Plain Layout

  static const int const_member = 5 * 2;
\end_layout

\begin_layout Plain Layout

  unsigned int bitfield : 4 / 2;
\end_layout

\begin_layout Plain Layout

}; 
\end_layout

\begin_layout Plain Layout

const int const_two = 3 - 1;
\end_layout

\begin_layout Plain Layout

static char char_array[const_two + 5];
\end_layout

\begin_layout Plain Layout

enum ExampleEnum {
\end_layout

\begin_layout Plain Layout

  ENUM_VALUE = const_two + 1
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

switch(const int const_temp = 1) {
\end_layout

\begin_layout Plain Layout

  case const_temp + 1: {
\end_layout

\begin_layout Plain Layout

    // ...
\end_layout

\begin_layout Plain Layout

    break;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

A further limitation results from the fact, that the C++-standard forbids
 
\series bold
pointers and references to bit-fields
\series default
.
 Thus all operators that refer to a bit-field (e.g.
 the assignment- or increment-/decrement-operator needs a reference as first
 argument) are not supported.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Moreover any operator that has an 
\series bold
anonymous/unnamed or local type or a type with no linkage
\series default
 as argument or result is not supported (because these types shall not be
 used as a template argument which makes weaving impossible in most cases).
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Additionally 
\series bold
postfix increment/decrement operators
\series default
 have a second implicit argument of type 
\family typewriter
int
\family default
 to distinguish between pre- and postfix operators.
 So e.g.
 
\family typewriter

\begin_inset Quotes eld
\end_inset

% operator ++(%, int)
\begin_inset Quotes erd
\end_inset


\family default
 matches the postfix increment operator and 
\family typewriter

\begin_inset Quotes eld
\end_inset

% operator ++(%)
\begin_inset Quotes erd
\end_inset


\family default
 matches the prefix increment operator.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Also the 
\series bold
address-of operator 
\family typewriter
&
\family default
\series default
 is not supported, if the argument is a data member or member function,
 because these types do not exist as type of a variable.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Furthermore the C++-standard states that if the result of .* or ->* is a
 function, that result can be used only as the operand for the function
 call operator 
\family typewriter
()
\family default
.
 Therefore the 
\series bold
pointer to member operators 
\family typewriter
.*
\family default
 and 
\family typewriter
->*
\family default
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
pointer to member
\end_layout

\end_inset

 that get a member function pointer as second argument are not supported,
 because a caching of the result is not possible.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

At last there are some limitations with the 
\series bold
short-circuiting
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
short circuit evaluation
\end_layout

\end_inset

 operators 
\family typewriter
&&
\family default
, 
\family typewriter
||
\family default
 and 
\family typewriter
?:
\family default
\series default
.
 If the second or third argument is not evaluated, tjp->args() will return
 a null-pointer for the corresponding argument.
 Additionally the result of the args pointcut function (see 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:context"

\end_inset

) is determined at runtime, if an short-circuit argument is bound with the
 args pointcut function .
 Thus the advice code in the following example is only executed, if the
 first argument evaluates to 
\family typewriter
true
\family default
 so that the second argument is available.
 In case of 
\family typewriter
||
\family default
 the first argument have to be 
\family typewriter
false
\family default
 to make the second argument available and in case of 
\family typewriter
?:
\family default
 the first argument makes the decision about the availability of the second
 resp.
 third argument.
 
\begin_inset listings
lstparams "basicstyle={\ttfamily},breaklines=true,showstringspaces=false,tabsize=2"
inline false
status open

\begin_layout Plain Layout

advice builtin("% operator &&(bool, bool)") && args("%", b2) : before(bool
 b2) {
\end_layout

\begin_layout Plain Layout

  // advice code
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

A 
\series bold
complete list with all limitations and not supported operators
\series default
 can be found in the next section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:builtin_supported_operators"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Supported And Not Supported Operators
\begin_inset CommandInset label
LatexCommand label
name "subsec:builtin_supported_operators"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
builtin!supported operators
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
built-in operators!supported operators
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This section contains information about the builtin pointcut function in
 terms of supported operators.
\begin_inset Newline newline
\end_inset

Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:builtin_supported_operators"

\end_inset

 shows all operators that are fully or partly supported and indicates the
 special characteristics of these operators, if available.
 For more information see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:builtin_limitations"

\end_inset

.
\begin_inset Newline newline
\end_inset

Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:builtin_not_supported_operators"

\end_inset

 shows not supported operators.
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="47" columns="4">
<features islongtable="true" longtabularalignment="center">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top" width="0pt">
<row endhead="true">
<cell multicolumn="1" alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none" special="c">
\begin_inset Text

\begin_layout Plain Layout

\series bold
operator and example
\begin_inset CommandInset label
LatexCommand label
name "tab:builtin_supported_operators"

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
special characteristics
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
unary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
+
\begin_inset ERT
status open

\begin_layout Plain Layout

{}
\end_layout

\end_inset

+
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
a+
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{}
\end_layout

\end_inset

+
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
postfix operator (second argument of type 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{int}
\end_layout

\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
unary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
-
\begin_inset ERT
status open

\begin_layout Plain Layout

{}
\end_layout

\end_inset

-
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
a-
\begin_inset ERT
status open

\begin_layout Plain Layout

{}
\end_layout

\end_inset

-
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
postfix operator (second argument of type 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{int}
\end_layout

\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
unary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
+
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{}
\end_layout

\end_inset

+
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
+
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{}
\end_layout

\end_inset

+a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
prefix operator; not supported if 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{a}
\end_layout

\end_inset

 is a bit-field
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
unary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
-
\begin_inset ERT
status open

\begin_layout Plain Layout

{}
\end_layout

\end_inset

-
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
-
\begin_inset ERT
status open

\begin_layout Plain Layout

{}
\end_layout

\end_inset

-a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
prefix operator; not supported if 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{a}
\end_layout

\end_inset

 is a bit-field 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
unary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
&
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
&a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
not supported if 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{a}
\end_layout

\end_inset

 is a member
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
unary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
*
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
*a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
unary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
+
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
+a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
unary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
-
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
-a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
unary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\begin_inset Formula $\sim$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\begin_inset Formula $\sim$
\end_inset

a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
unary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
!a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
.*
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
a.*b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
not supported if 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{b}
\end_layout

\end_inset

 is a member function pointer
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
->*
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
a->*b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
not supported if 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{b}
\end_layout

\end_inset

 is a member function pointer
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
*
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
a*b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
/
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
a/b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
a%b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
in match expressions: escape 
\family typewriter
%
\family default
 with 
\family typewriter
%%
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
+
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
a+b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
-
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
a-b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
<
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{}
\end_layout

\end_inset

<
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
a<
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{}
\end_layout

\end_inset

<b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
>
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{}
\end_layout

\end_inset

>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
a>
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{}
\end_layout

\end_inset

>b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
<
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
a<b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
a>b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
<=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
a<=b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
>=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
a>=b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
==
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
a==b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
!=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
a!=b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
&
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
a&b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
‸
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
a‸b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
a|b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
&&
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
a&&b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
limitations due to short-circuit evaluation
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
short circuit evaluation
\end_layout

\end_inset

 (see 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:builtin_limitations"

\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
||
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
a||b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
limitations due to short-circuit evaluation (see 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:builtin_limitations"

\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
a=b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
copy-assignment not supported;
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
not supported if 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{a}
\end_layout

\end_inset

 is a bit-field
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
*=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
a*=b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
not supported if 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{a}
\end_layout

\end_inset

 is a bit-field
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
/=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
a/=b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
not supported if 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{a}
\end_layout

\end_inset

 is a bit-field
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
%=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
a%=b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
in match expressions: escape 
\family typewriter
%=
\family default
 with 
\family typewriter
%%=;
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
not supported if 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{a}
\end_layout

\end_inset

 is a bit-field
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
+=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
a+=b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
not supported if 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{a}
\end_layout

\end_inset

 is a bit-field
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
-=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
a-=b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
not supported if 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{a}
\end_layout

\end_inset

 is a bit-field
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
<
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{}
\end_layout

\end_inset

<=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
a<
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{}
\end_layout

\end_inset

<=b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
not supported if 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{a}
\end_layout

\end_inset

 is a bit-field
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
>
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{}
\end_layout

\end_inset

>=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
a>
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{}
\end_layout

\end_inset

>=b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
not supported if 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{a}
\end_layout

\end_inset

 is a bit-field
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
&=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
a&=b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
not supported if 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{a}
\end_layout

\end_inset

 is a bit-field
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
|=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
a|=b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
not supported if 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{a}
\end_layout

\end_inset

 is a bit-field
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
‸=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
a‸=b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
not supported if 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{a}
\end_layout

\end_inset

 is a bit-field
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
[]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
a[b]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row endlastfoot="true">
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ternary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
?:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
a?b:c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
limitations due to short-circuit evaluation (see 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:builtin_limitations"

\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row endfoot="true">
<cell multicolumn="1" alignment="right" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
continuation on next page...
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addtocounter{table}{-1}%because longtable did a +1
\end_layout

\begin_layout Plain Layout


\backslash
captionof{table}{operators that are (partly) supported by the builtin pointcut
 function}
\backslash
vfill
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
,$
\backslash

\backslash
$
\backslash
,$
\backslash

\backslash
$
\backslash
,$
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="3">
<features islongtable="true" longtabularalignment="center">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<row endhead="true">
<cell multicolumn="1" alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none" special="c">
\begin_inset Text

\begin_layout Plain Layout

\series bold
operator and example
\begin_inset CommandInset label
LatexCommand label
name "tab:builtin_not_supported_operators"

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
,
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
a,b
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
->
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
a->b
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
a.b
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
new
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
new a
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
delete
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
delete a
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
new[]
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
new[] a
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
delete[]
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
delete[] a
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
implicit conversions
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
operators in constant expressions (see 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:builtin_limitations"

\end_inset

)
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
operators with an anonymous/unnamed or local type (see 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:builtin_limitations"

\end_inset

)
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
operators that have a type with no linkage (see 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:builtin_limitations"

\end_inset

)
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addtocounter{table}{-1}%because longtable did a +1
\end_layout

\begin_layout Plain Layout


\backslash
captionof{table}{operators that are not supported by the builtin pointcut
 function}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Object Construction and Destruction
\begin_inset CommandInset label
LatexCommand label
name "subsec:Object-Construction-and"

\end_inset


\end_layout

\begin_layout Description
construction
\series medium
(
\emph on
pointcut
\emph default
)
\series default
 
\begin_inset Index idx
status open

\begin_layout Plain Layout
construction@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{construction()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
pointcut function!construction@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{construction()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hfill 
\end_layout

\end_inset

N
\begin_inset Formula $_{C}$
\end_inset


\begin_inset Formula $\rightarrow$
\end_inset

C
\begin_inset Formula $_{Cons}$
\end_inset


\begin_inset Newline newline
\end_inset

returns all code join points where an instance of a class in 
\shape italic
pointcut
\shape default
 is constructed.
 The construction join point begins after all base class and member construction
 join points.
 It can be imagined as the execution of the constructor.
 However, advice for construction join points work, even if there is no
 constructor defined explicitly.
 A construction join point has arguments and argument types, which can be
 exposed or filtered, e.g.
 by using the 
\series bold
args
\series default
 pointcut function.
\end_layout

\begin_layout Description
destruction
\series medium
(
\emph on
pointcut
\emph default
)
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
destruction@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{destruction()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pointcut function!destruction@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{destruction()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hfill 
\end_layout

\end_inset

N
\begin_inset Formula $_{C}$
\end_inset


\begin_inset Formula $\rightarrow$
\end_inset

C
\begin_inset Formula $_{Des}$
\end_inset


\begin_inset Newline newline
\end_inset

returns all code join points where an instance of a class in 
\shape italic
pointcut
\shape default
 is destructed.
 The destruction join point ends before the destruction join point of all
 members and base classes.
 It can be imagined as the execution of the destructor, although a destructor
 does not to be defined explicitly.
 A destruction join point has an empty argument list.
\end_layout

\begin_layout Subsubsection*
Example: instance counting
\begin_inset CommandInset label
LatexCommand label
name "exa:instance-counting"

\end_inset


\end_layout

\begin_layout Standard
The following aspect counts how many instances of the class 
\family typewriter
ClassOfInterest
\family default
 are created and destroyed.
\end_layout

\begin_layout LyX-Code
aspect InstanceCounting {
\end_layout

\begin_layout LyX-Code
  // the class for which instances should be counted
\end_layout

\begin_layout LyX-Code
  pointcut observed() = "ClassOfInterest";
\end_layout

\begin_layout LyX-Code
  // count constructions and destructions
\end_layout

\begin_layout LyX-Code
  advice construction (observed ()) : before () {
\end_layout

\begin_layout LyX-Code
                                        _created++; }
\end_layout

\begin_layout LyX-Code
  advice destruction (observed ())  : after ()  {
\end_layout

\begin_layout LyX-Code
                                        _destroyed++; }
\end_layout

\begin_layout LyX-Code
  // counters
\end_layout

\begin_layout LyX-Code
  int _created, _destroyed;
\end_layout

\begin_layout LyX-Code
public:
\end_layout

\begin_layout LyX-Code
  // Singleton aspects can have a default constructor
\end_layout

\begin_layout LyX-Code
  InstanceCounting () { _created = _destroyed = 0; }
\end_layout

\begin_layout LyX-Code
}; 
\end_layout

\begin_layout Standard
The implementation of this aspect is straightforward.
 Two counters are initialized by the aspect constructor and incremented
 by the construction/destruction advice.
 By defining 
\family typewriter
observed()
\family default
 as a pure virtual pointcut the aspect can easily be transformed into a
 reusable abstract aspect.
\end_layout

\begin_layout Subsection
Variables
\end_layout

\begin_layout Description
get
\series medium
(
\emph on
pointcut
\emph default
)
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
get@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{get()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pointcut function!get@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{get()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hfill 
\end_layout

\end_inset

N
\begin_inset Formula $_{V}$
\end_inset


\begin_inset Formula $\rightarrow$
\end_inset

C
\begin_inset Formula $_{G}$
\end_inset


\begin_inset Newline newline
\end_inset

returns all code join points where a global variable or data member in 
\shape italic
pointcut
\shape default
 is read.
 The get join points are located at implicit lvalue-to-rvalue conversions
 according to the C++ standard.
 In addition, the get join points are located within all built-in compound-assig
nment operators, and within the built-in increment and decrement operators.
\end_layout

\begin_layout Description
set
\series medium
(
\emph on
pointcut
\emph default
)
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
set@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{set()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pointcut function!set@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{set()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hfill 
\end_layout

\end_inset

N
\begin_inset Formula $_{V}$
\end_inset


\begin_inset Formula $\rightarrow$
\end_inset

C
\begin_inset Formula $_{S}$
\end_inset


\begin_inset Newline newline
\end_inset

returns all code join points where a global variable or data member in 
\shape italic
pointcut
\shape default
 is modified.
 The set join points are located within all built-in assignment operators,
 and within the built-in increment and decrement operators.
 The initialization of a global variable or data member provides no set
 join point.
\end_layout

\begin_layout Description
ref
\series medium
(
\emph on
pointcut
\emph default
)
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
ref@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{ref()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pointcut function!ref@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{ref()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hfill 
\end_layout

\end_inset

N
\begin_inset Formula $_{V}$
\end_inset


\begin_inset Formula $\rightarrow$
\end_inset

C
\begin_inset Formula $_{R}$
\end_inset


\begin_inset Newline newline
\end_inset

provides all join points where a reference (reference type or pointer) to
 a global variable or data member in the 
\emph on
pointcut
\emph default
 is created.
 The ref join points are located within the built-in address-of operator
 
\family typewriter
&
\family default
, if the operand is a global variable or data member.
 In addition, the ref join points are located before the initialization
 of a variable of reference type, including return values.
 Moreover, the binding of a reference parameter of a function, including
 default values, provides ref join points.
 The ref join points are also located within implicit array-to-pointer conversio
ns according to the C++ standard.
\end_layout

\begin_layout Subsubsection*
Example: variable matching
\begin_inset CommandInset label
LatexCommand label
name "exa:variable-matching"

\end_inset


\end_layout

\begin_layout Standard
The following aspect observes the modification of all variables (in any
 scope) of the type 
\family typewriter
int
\family default
.
 When such an integer variable is modified, the aspect reports the name
 of the variable and its new value, obtained by 
\family typewriter
*tjp->entity()
\family default
.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},breaklines=true,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

aspect IntegerModification {
\end_layout

\begin_layout Plain Layout

  advice set("int ...::%") : after() {
\end_layout

\begin_layout Plain Layout

    cout << "Setting variable "
\end_layout

\begin_layout Plain Layout

         << tjp->signature() << " to "
\end_layout

\begin_layout Plain Layout

         << *tjp->entity() << endl;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

};
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Limitations
\end_layout

\begin_layout Standard
The get and set pointcut functions cover variables of fundamental type,
 such as integer and floating-point types, and arrays thereof.
 Variables of any pointer type and arrays of pointers are also supported.
 The get and set pointcut functions do not support 
\series bold
variables of class type, unions, enumerations, bitfields, and references
\series default
.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

The get, set, and ref pointcut functions match only if the variable is accessed
 directly by its name.
 
\series bold
Indirect variable access via pointer or reference
\series default
 does not match.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

The get, set, and ref pointcut functions do not match for 
\series bold
local variables
\series default
.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

The get, set, and ref joinpoints are not located within 
\series bold
constant expressions
\series default
, such as the built-in operator 
\family typewriter
sizeof
\family default
.
\end_layout

\begin_layout Subsubsection
Compatibility
\end_layout

\begin_layout Standard
The get, set, and ref pointcut functions are new features that were introduced
 in version 2.0 and are therefore not enabled by default to avoid compatibility
 issues (e.g., if someone named a pointcut 
\begin_inset Quotes eld
\end_inset

get
\begin_inset Quotes erd
\end_inset

).
 The 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{{-}{-}data
\backslash
_joinpoints} 
\end_layout

\end_inset

 command-line argument enables the described functionality.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:context"

\end_inset

Context
\end_layout

\begin_layout Description
that
\series medium
(
\emph on
type
\begin_inset space ~
\end_inset

pattern
\emph default
)
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
that@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{that()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pointcut function!that@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{that()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hfill 
\end_layout

\end_inset

N
\begin_inset Formula $_{T}$
\end_inset


\begin_inset Formula $\rightarrow$
\end_inset

C
\begin_inset Newline newline
\end_inset

returns all code join points where the current C++ 
\family typewriter
this
\family default
 pointer refers to an object which is an instance of a type that is compatible
 to the type described by 
\shape italic
type pattern
\end_layout

\begin_layout Description
target
\series medium
(
\emph on
type
\begin_inset space ~
\end_inset

pattern
\emph default
)
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
target@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{target()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pointcut function!target@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{target()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hfill 
\end_layout

\end_inset

N
\begin_inset Formula $_{T}$
\end_inset


\begin_inset Formula $\rightarrow$
\end_inset

C
\begin_inset Newline newline
\end_inset

returns all code join points where the target object of a call/set/get is
 an instance of a type that is compatible to the type described by 
\shape italic
type pattern
\end_layout

\begin_layout Description
result
\series medium
(
\emph on
type
\begin_inset space ~
\end_inset

pattern
\emph default
)
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
result@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{result()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pointcut function!base@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{base()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hfill 
\end_layout

\end_inset

N
\begin_inset Formula $_{T}$
\end_inset


\begin_inset Formula $\rightarrow$
\end_inset

C
\begin_inset Newline newline
\end_inset

returns all code join points where the type of the return value of a call/builti
n/execution/get is matched by 
\shape italic
type pattern
\end_layout

\begin_layout Description
args
\series medium
(
\emph on
type
\begin_inset space ~
\end_inset

pattern
\emph default
,
\begin_inset space ~
\end_inset

...)
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
args@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{args()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pointcut function!args@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{args()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hfill 
\end_layout

\end_inset

(N
\begin_inset Formula $_{T}$
\end_inset

,...)
\begin_inset Formula $\rightarrow$
\end_inset

C
\begin_inset Newline newline
\end_inset

returns all code join points where the types of the arguments of a call/builtin/
execution/set are matched by the corresponding 
\shape italic
type pattern
\shape default
s.
 
\begin_inset Note Comment
status open

\begin_layout Plain Layout
The argument list of 
\series bold
args
\series default
 contains type patterns that are used to filter all join points, e.g.
 calls to functions or function executions, with a matching signature.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Instead of the type pattern it is also possible here to pass the name of
 a variable to which the context information is bound (a 
\series bold
context variable
\series default
).
 In this case the type of the variable is used for the type matching.
 Context variables must be declared in the argument list of 
\series bold
before()
\series default
, 
\series bold
after()
\series default
, or 
\series bold
around()
\series default
 and can be used like a function parameter in the advice body.
\end_layout

\begin_layout Standard
The 
\series bold
that()
\series default
 and 
\series bold
target()
\series default
 pointcut functions are special, because they might cause a runtime type
 check.
 The 
\series bold
args()
\series default
 and 
\series bold
result()
\series default
 functions are evaluated at compile time.
 Exception: If a short-circuit argument is bound with the args pointcut
 function, then the result of args depends on the runtime availability of
 the bound argument.
\end_layout

\begin_layout Subsubsection*
Example: context matching
\begin_inset CommandInset label
LatexCommand label
name "exa:context-matching"

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Algebraic-Operators"

\end_inset

Algebraic Operators
\end_layout

\begin_layout Description

\series medium
\emph on
pointcut
\series default
\emph default

\begin_inset space ~
\end_inset

&&
\series medium
\emph on

\begin_inset space ~
\end_inset

pointcut
\series default
\emph default
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hfill 
\end_layout

\end_inset

(N,N)
\begin_inset Formula $\rightarrow$
\end_inset

N, (C,C)
\begin_inset Formula $\rightarrow$
\end_inset

C
\begin_inset Newline newline
\end_inset

returns the intersection of the join points in the 
\shape italic
pointcut
\shape default
s
\end_layout

\begin_layout Description

\series medium
\emph on
pointcut
\series default
\emph default

\begin_inset space ~
\end_inset

||
\series medium
\emph on

\begin_inset space ~
\end_inset

pointcut
\series default
\emph default
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hfill 
\end_layout

\end_inset

(N,N)
\begin_inset Formula $\rightarrow$
\end_inset

N, (C,C)
\begin_inset Formula $\rightarrow$
\end_inset

C
\begin_inset Newline newline
\end_inset

returns the union of the join points in the 
\shape italic
pointcut
\shape default
s
\end_layout

\begin_layout Description
!
\series medium
\emph on

\begin_inset space ~
\end_inset

pointcut
\series default
\emph default
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hfill 
\end_layout

\end_inset

N
\begin_inset Formula $\rightarrow$
\end_inset

N, C
\begin_inset Formula $\rightarrow$
\end_inset

C
\begin_inset Newline newline
\end_inset

returns all name resp.
 code join points that are not included in 
\shape italic
pointcut
\shape default

\begin_inset Note Comment
status open

\begin_layout Plain Layout
 exclusion of the join points in the pointcut
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Example: 
\begin_inset CommandInset label
LatexCommand label
name "exa:combining-pointcut"

\end_inset

combining pointcut expressions
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pointcut function
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

)
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pointcut!function
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Attributes
\begin_inset CommandInset label
LatexCommand label
name "sec:attributes"

\end_inset


\end_layout

\begin_layout Standard
Attributes are a language element, which AspectC++ developers can use for
 user-defined annotations.
 An attribute provides additional information about a join point that aspects
 can exploit for collecting or filtering pointcuts.
 The attribute syntax is based on the attribute syntax of C++11 (and following
 standards).
 However, AspectC++ provides this mechanism even if the selected language
 standard is older than C++11.
 In this case no attributes from the namespaces 
\family typewriter
gnu
\family default
 or 
\family typewriter
clang
\family default
 or the global scope must be used.
\end_layout

\begin_layout Subsection
Attribute declarations
\end_layout

\begin_layout Standard
Attributes must be declared 
\emph on
before
\emph default
 being used in a pointcut expression.
 An attribute that is used for annotating a join point must be declared,
 but it is 
\emph on
not
\emph default
 required that the declaration is seen by the parser 
\emph on
before
\emph default
 the annotation location.
 The following example shows such a declaration using the keyword 
\family typewriter
attribute
\family default
.
\end_layout

\begin_layout Subsubsection*
Example: attribute declaration
\begin_inset CommandInset label
LatexCommand label
name "exa:attribute-declaration"

\end_inset


\end_layout

\begin_layout LyX-Code
attribute myAttr();
\end_layout

\begin_layout Standard
To avoid naming conflicts, attributes can be declared inside of namespaces,
 classes, or aspects.
 User-defined attributes shall neither be declared in the global scope nor
 in the scope of backend compiler attributes, such as 
\family typewriter
gnu
\family default
 or 
\family typewriter
clang
\family default
.
 The current version of AspectC++ supports only empty argument lists.
 To annotate an element of the program code, the attribute has to be referenced
 by its fully-qualified name.
 The following example illustrates this:
\end_layout

\begin_layout Subsubsection*
Example: using attributes to annotate program elements
\begin_inset CommandInset label
LatexCommand label
name "exa:attribute-qualified"

\end_inset


\end_layout

\begin_layout LyX-Code
namespace attrib {
\end_layout

\begin_layout LyX-Code
  attribute myFuncAttr();
\end_layout

\begin_layout LyX-Code
  attribute otherAttr();
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
[[attrib::myFuncAttr, attrib::otherAttr()]] void myFunc();
\end_layout

\begin_layout Standard
To be compatible with C++11 attributes, it is not necessary to specify parameter
s if the argument list of an attribute is empty.
 Furthermore, it is possible to use several attributes in a pair of brackets
 separated by commas or several pairs of brackets behind each other.
 For more information about attribute-syntax in C++11 consult the C++11
 standard.
\end_layout

\begin_layout Standard
Attributes from the namespaces 
\family typewriter
gnu
\family default
 and  
\family typewriter
clang
\family default
 and the global scope are evaluated by AspectC++ and passed through to the
 backend compiler.
 All other attributes are only evaluated by AspectC++ and hidden from the
 backend compiler.
\end_layout

\begin_layout Subsection
Supported code-elements
\end_layout

\begin_layout Standard
Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:attributes-code-elements"

\end_inset

 shows the code elements, for which annotations with attributes are supported,
 and the possible attribute locations.
 Positions of attributes are marked by 
\family typewriter
[[..]].
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features islongtable="true" longtabularalignment="center">
<column alignment="center" valignment="top" width="0cm">
<column alignment="center" valignment="top" width="0cm">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Code-Element
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Positions
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
namespaces
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
namespace [[...]] myNamespace {}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
classes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
class [[...]] myClass {};
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
functions
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
[[...]] void myFunc [[...]] ();
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
variables
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
[[...]] int myVar [[...]];
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:attributes-code-elements"

\end_inset

attributes - code-elements and positions
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
If a namespace is opened more than once, all enclosed elements belong semantical
ly to the same namespace.
 In this case, all attributes of that namespace must be present at its 
\emph on
first
\emph default
 definition.
 In subsequent definitions they can be present as well, but don't have to.
 It is forbidden to add an attribute in a subsequent definition, which was
 not present in the first.
 A similar rule is applied for classes, functions, and variables, which
 can have multiple forward declarations.
 In this case, all attributes must be present at the 
\emph on
first
\emph default
 declaration and can be omitted later on.
\end_layout

\begin_layout Subsection
Attributes and pointcut expressions
\end_layout

\begin_layout Standard
Attributes can be used in pointcut expressions where they are interpreted
 similar to named pointcuts.
 They can be combined with logical operators like other pointcut expressions
 and can be used in pointcut declarations.
 Thereby, the usual C++ name lookup rules are also applicable for attributes.
 The following example shows how to use attributes in pointcut expressions.
\end_layout

\begin_layout Subsubsection*
Example: using attributes in pointcut expressions
\begin_inset CommandInset label
LatexCommand label
name "exa:attribute-pointcut-expression"

\end_inset


\end_layout

\begin_layout LyX-Code
struct [[output::myAttr]] myStruct {
\end_layout

\begin_layout LyX-Code
  [[output::myAttr]] void myFunc() {};
\end_layout

\begin_layout LyX-Code
};
\end_layout

\begin_layout LyX-Code
aspect output {
\end_layout

\begin_layout LyX-Code
  attribute myAttr();
\end_layout

\begin_layout LyX-Code
  pointcut all() = myAttr();
\end_layout

\begin_layout LyX-Code
};
\end_layout

\begin_layout Standard
If multiple name joinpoints, such as the namespace N and the class C, are
 annotated by an attribute A, the meaning of A() in a pointcut expression
 is equivalent to 
\begin_inset Quotes eld
\end_inset

N
\begin_inset Quotes erd
\end_inset

||
\begin_inset Quotes erd
\end_inset

C
\begin_inset Quotes erd
\end_inset

.
 This means that also nested entities within N and C are matched.
\end_layout

\begin_layout Section
Slices
\end_layout

\begin_layout Standard
This section defines the syntax and semantics of slice declarations.
 The next section will describe how slices can be used by advice in order
 to introduce code.
 Currently, only class slices are defined in AspectC++.
\end_layout

\begin_layout Subsection
Class Slice Declarations
\end_layout

\begin_layout Standard
Class slices may be declared in any class or namespace scope.
 They may be defined only once, but there may be an arbitrary number of
 forward declarations.
 A qualified name may be used if a class slice that is already declared
 in a certain scope is redeclared or defined as shown in the following example:
\end_layout

\begin_layout LyX-Code
slice class ASlice;
\end_layout

\begin_layout LyX-Code
namespace N {
\end_layout

\begin_layout LyX-Code
 slice class ASlice; // a different slice!
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
slice class ASlice { // definition of the ::ASlice
\end_layout

\begin_layout LyX-Code
  int elem;
\end_layout

\begin_layout LyX-Code
};
\end_layout

\begin_layout LyX-Code
slice class N::ASlice { // definition of the N::ASlice
\end_layout

\begin_layout LyX-Code
  long elem;
\end_layout

\begin_layout LyX-Code
};
\end_layout

\begin_layout Standard
If a class slice only defines a base class, an abbreviated syntax may be
 used:
\end_layout

\begin_layout LyX-Code
slice class Chained : public Chain;
\end_layout

\begin_layout Standard
Class slices may be anonymous.
 However, this only makes sense as part of an advice declaration.
 A class slice may also be declared with the 
\family typewriter
aspect
\family default
 or 
\family typewriter
struct
\family default
 keyword instead of 
\family typewriter
class
\family default
.
 While there is no difference between class and aspect slices, the default
 access rights to the elements of a struct slice in the target classes are
 public instead of private.
 It is forbidden to declare aspects, pointcuts, advice, or slices as members
 of a class slice.
\end_layout

\begin_layout Standard
Class slices may have members that are not defined within the body of a
 class slice declaration, e.g.
 static member variable or non-inline functions:
\end_layout

\begin_layout LyX-Code
slice class SL {
\end_layout

\begin_layout LyX-Code
  static int answer;
\end_layout

\begin_layout LyX-Code
  void f();
\end_layout

\begin_layout LyX-Code
};
\end_layout

\begin_layout LyX-Code
//...
\end_layout

\begin_layout LyX-Code
slice int SL::answer = 42;
\end_layout

\begin_layout LyX-Code
slice void SL::f() { ...
 }
\end_layout

\begin_layout Standard
These external member declarations have to appear after the corresponding
 slice declaration in the source code.
\end_layout

\begin_layout Section
Advice
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
advice!declaration
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

(
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This section describes the different types of advice offered by AspectC++.
 Advice are categorized in advice for join points in the dynamic control
 flow of the running program, e.
 g.
 function call or executions, and advice for static join points like introductio
ns into classes.
\end_layout

\begin_layout Standard
In either case the compiler makes sure that the code of the aspect header
 file, which contains the advice definition (if this is the case), is compiled
 prior to the affected join point location.
\end_layout

\begin_layout Subsection
Advice for Dynamic Join Points
\end_layout

\begin_layout Description
before
\series medium
(...)
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
before
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
advice!before
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

the advice code is executed before the join points in the pointcut
\end_layout

\begin_layout Description
after
\series medium
(...)
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
after
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
advice!after
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

the advice code is executed after the join points in the pointcut
\end_layout

\begin_layout Description
around
\series medium
(...)
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
around
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
advice!around
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

the advice code is executed in place of the join points in the pointcut
\end_layout

\begin_layout Subsection
Advice for Static Join Points
\end_layout

\begin_layout Standard
Static join points in AspectC++ are classes or aspects.
 Advice for classes or aspects can introduce new members or add a base class.
 Whether the new member or base class becomes 
\series bold
private
\series default
, 
\series bold
protected
\series default
, or 
\series bold
public
\series default
 in the target class depends on the protection in the advice declaration
 in the aspect.
\end_layout

\begin_layout Description
baseclass
\series medium
(
\emph on
classname
\emph default
)
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
baseclass
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
advice!baseclass
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

a new base class is introduced to the classes in the pointcut 
\end_layout

\begin_layout Description

\emph on
introduction
\begin_inset space ~
\end_inset

declaration
\emph default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
introduction declaration
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
advice!introduction declaration
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

a new member variable, member function, or type is introduced
\end_layout

\begin_layout Standard
Introduction declarations are only semantically analyzed in the context
 of the target.
 Therefore, the declaration may refer, for instance, to types or constants,
 which are not known in the aspect definition, but only in the target class
 or classes.
 To introduce a constructor or destructor the name of the aspect, to which
 the introduction belongs, has to be taken as the constructor/destructor
 name.
\end_layout

\begin_layout Standard

\emph on
Non-inline introductions
\emph default
 can be used for introductions of static member variables or member function
 introduction with separate declaration an definition.
 The name of the introduced member has to be a qualified name in which the
 nested name specifier is the name of the aspect to which the introduction
 belongs.
\end_layout

\begin_layout Subsubsection*
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
advice!declaration
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

)
\end_layout

\end_inset


\end_layout

\begin_layout Section

\family typewriter
JoinPoint
\family default
 API
\family typewriter

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}|(
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
runtime support!JoinPoint@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}|(
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The following sections provide a complete description of the 
\family typewriter
JoinPoint
\family default
 API.
 
\end_layout

\begin_layout Subsection
API for Dynamic Join Points
\end_layout

\begin_layout Standard
The JoinPoint-API for dynamic join points can be used within the body of
 advice code.
 
\end_layout

\begin_layout Subsubsection
Types and Constants
\end_layout

\begin_layout Description

\family typewriter
\series medium
Result
\family default
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Result@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{Result}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}!Result@
\backslash
texttt{Result}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

result type of a function
\end_layout

\begin_layout Description

\family typewriter
\series medium
Res::Type, Res::ReferredType
\family default
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Res::Type@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{Res::Type}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}!Res::Type@
\backslash
texttt{Res::Type}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Res::ReferredType@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{Res::ReferredType}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}!Res::ReferredType@
\backslash
texttt{Res::ReferredType}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

result type of the affected function or entity access
\end_layout

\begin_layout Description

\family typewriter
\series medium
Arg<i>::Type, Arg<i>::ReferredType
\family default
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Arg<i>::Type@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{Arg<i>::Type}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}!arg<i>::Type@
\backslash
texttt{Arg<i>::Type}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Arg<i>::ReferredType@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{Arg<i>::ReferredType}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}!Arg<i>::ReferredType@
\backslash
texttt{Arg<i>::ReferredType}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

type of the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

$i^{
\backslash
,th}$
\end_layout

\end_inset

 argument of the affected join point (with 
\begin_inset ERT
status open

\begin_layout Plain Layout

$0 
\backslash
leq i < ARGS$
\end_layout

\end_inset

)
\end_layout

\begin_layout Description

\family typewriter
\series medium
ARGS
\family default
\series default
 
\begin_inset space ~
\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
ARGS@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{ARGS}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}!ARGS@
\backslash
texttt{ARGS}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

number of arguments
\end_layout

\begin_layout Description

\family typewriter
\series medium
That
\family default
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
That@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{That}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}!That@
\backslash
texttt{That}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

object type (object initiating a call)
\end_layout

\begin_layout Description

\family typewriter
\series medium
Target
\family default
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Target@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{Target}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}!Target@
\backslash
texttt{Target}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

target object type (target object of a call)
\end_layout

\begin_layout Description

\family typewriter
\series medium
Entity
\family default
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Entity@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{Entity}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}!Entity@
\backslash
texttt{Entity}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

type of the primary referenced entity (function or variable)
\end_layout

\begin_layout Description

\family typewriter
\series medium
MemberPtr
\family default
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
MemberPtr@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{MemberPtr}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}!MemberPtr@
\backslash
texttt{MemberPtr}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

type of the member pointer for entity or 
\family typewriter
void *
\family default
 for nonmembers
\end_layout

\begin_layout Description

\family typewriter
\series medium
Array
\family default
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
MemberPtr@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{Array}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}!Array@
\backslash
texttt{Array}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

type of the accessed array
\end_layout

\begin_layout Description

\family typewriter
\series medium
Dim<i>::Idx
\family default
\series default
 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Idx@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{Idx}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}!Idx@
\backslash
texttt{Idx}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

type of the 
\emph on
i
\emph default
th dimension of the accessed array (with 
\begin_inset ERT
status open

\begin_layout Plain Layout

$0 
\backslash
leq i < DIMS$
\end_layout

\end_inset

)
\end_layout

\begin_layout Description

\family typewriter
\series medium
Dim<i>::Size
\family default
\series default
 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Size@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{Size}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}!Size@
\backslash
texttt{Size}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

size of the 
\emph on
i
\emph default
th dimension of the accessed array (with 
\begin_inset ERT
status open

\begin_layout Plain Layout

$0 
\backslash
leq i < DIMS$
\end_layout

\end_inset

)
\end_layout

\begin_layout Description

\family typewriter
\series medium
DIMS
\family default
\series default
 
\begin_inset space ~
\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
DIMS@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{DIMS}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}!DIMS@
\backslash
texttt{DIMS}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

number of dimensions of an accessed array or 0 otherwise
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{comment}
\end_layout

\end_inset


\end_layout

\begin_layout Description

\family typewriter
\series medium
Aspect
\family default
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Aspect@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{Aspect}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}!Aspect@
\backslash
texttt{Aspect}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

type of the aspect (only available in introductions)
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{comment}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Example: type usage
\begin_inset CommandInset label
LatexCommand label
name "exa:type-usage"

\end_inset


\end_layout

\begin_layout Subsubsection
Functions
\end_layout

\begin_layout Description

\family typewriter
\series medium
static
\begin_inset space ~
\end_inset

AC::Type
\emph on

\begin_inset space ~
\end_inset


\emph default
type()
\family default
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
type@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{type()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}!type@
\backslash
texttt{type()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

returns the encoded type for the join point conforming with the C++ ABI
 V3 specification
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "http://www.codesourcery.com/cxx-abi/abi.html\\#mangling"
target "http://www.codesourcery.com/cxx-abi/abi.html\\#mangling"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Description

\family typewriter
\series medium
static
\begin_inset space ~
\end_inset

int
\emph on

\begin_inset space ~
\end_inset


\emph default
args()
\family default
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
args@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{args()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}!args@
\backslash
texttt{args()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

returns the number of arguments of a function for call and execution join
 points
\end_layout

\begin_layout Description

\family typewriter
\series medium
static
\begin_inset space ~
\end_inset

AC::Type
\emph on

\begin_inset space ~
\end_inset


\emph default
argtype(int
\series default

\begin_inset space ~
\end_inset


\series medium
number)
\family default
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
argtype@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{argtype()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}!argtype@
\backslash
texttt{argtype()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

returns the encoded type of an argument conforming with the C++ ABI V3 specifica
tion
\end_layout

\begin_layout Description

\family typewriter
\series medium
static
\begin_inset space ~
\end_inset

const
\begin_inset space ~
\end_inset

char
\series default
\emph on

\begin_inset space ~
\end_inset


\series medium
\emph default
*signature()
\family default
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
signature@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{signature()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}!signature@
\backslash
texttt{signature()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

gives a textual description of the join point (function name, class name,
 ...)
\end_layout

\begin_layout Description

\family typewriter
\series medium
static
\begin_inset space ~
\end_inset

unsigned
\begin_inset space ~
\end_inset

int
\series default
\emph on

\begin_inset space ~
\end_inset


\series medium
\emph default
id()
\family default
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
id@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{id()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}!id@
\backslash
texttt{id()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

returns a unique numeric identifier for this join point
\end_layout

\begin_layout Description

\family typewriter
\series medium
static
\begin_inset space ~
\end_inset

const
\begin_inset space ~
\end_inset

char
\series default
\emph on

\begin_inset space ~
\end_inset


\series medium
\emph default
*filename()
\family default
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
filename@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{filename()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}!filename@
\backslash
texttt{filename()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

returns the name of the file in which the join point (shadow) is located
\end_layout

\begin_layout Description

\family typewriter
\series medium
static
\begin_inset space ~
\end_inset

int
\series default
\emph on

\begin_inset space ~
\end_inset


\series medium
\emph default
line()
\family default
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
line@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{line()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}!line@
\backslash
texttt{line()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

the number of the line in which the join point (shadow) is located
\end_layout

\begin_layout Description

\family typewriter
\series medium
static
\begin_inset space ~
\end_inset

AC::Type
\emph on

\begin_inset space ~
\end_inset


\emph default
resulttype()
\family default
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
resulttype@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{resulttype()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}!resulttype@
\backslash
texttt{resulttype()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

returns the encoded type of the result type conforming with the C++ ABI
 V3 specification
\end_layout

\begin_layout Description

\family typewriter
\series medium
static
\begin_inset space ~
\end_inset

AC::JPType
\emph on

\begin_inset space ~
\end_inset


\emph default
jptype()
\family default
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
jptype@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{jptype()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}!jptype@
\backslash
texttt{jptype()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

returns a unique identifier describing the type of the join point
\end_layout

\begin_layout Subsubsection*
Example: static function usage
\begin_inset CommandInset label
LatexCommand label
name "exa:static-function-usage"

\end_inset


\end_layout

\begin_layout Description

\family typewriter
\series medium
void
\begin_inset space ~
\end_inset

*arg(int
\series default

\begin_inset space ~
\end_inset


\series medium
number)
\family default
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
arg@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{arg()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}!arg@
\backslash
texttt{arg()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

returns a pointer to the memory position holding the argument value with
 index 
\family typewriter
number
\end_layout

\begin_layout Description

\family typewriter
\series medium
Result
\emph on

\begin_inset space ~
\end_inset


\emph default
*result()
\family default
\series default
 
\family typewriter

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
result@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{result()}
\end_layout

\end_inset


\end_layout

\end_inset


\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}!result@
\backslash
texttt{result()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

returns a pointer to the memory location designated for the result value
 or 0 if the function has no result value
\end_layout

\begin_layout Description

\family typewriter
\series medium
That
\begin_inset space ~
\end_inset

*that()
\family default
\series default
 
\family typewriter

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
that@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{that()}
\end_layout

\end_inset


\end_layout

\end_inset


\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}!that@
\backslash
texttt{that()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

returns a pointer to the object initiating a call or 0 if it is a static
 method or a global function
\end_layout

\begin_layout Description

\family typewriter
\series medium
Target
\begin_inset space ~
\end_inset

*target()
\family default
\series default
 
\family typewriter

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
target@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{target()}
\end_layout

\end_inset


\end_layout

\end_inset


\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}!target@
\backslash
texttt{target()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

returns a pointer to the object that is the target of a call or 0 if it
 is a static method or a global function
\end_layout

\begin_layout Description

\family typewriter
\series medium
Entity
\begin_inset space ~
\end_inset

*entity()
\family default
\series default
 
\family typewriter

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
entity@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{entity()}
\end_layout

\end_inset


\end_layout

\end_inset


\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}!entity@
\backslash
texttt{entity()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

returns a pointer to the accessed entity (function or variable) or 0 for
 member functions or builtin operators
\end_layout

\begin_layout Description

\family typewriter
\series medium
MemberPtr
\begin_inset space ~
\end_inset

*memberptr()
\family default
\series default
 
\family typewriter

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
memberptr@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{memberptr()}
\end_layout

\end_inset


\end_layout

\end_inset


\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}!memberptr@
\backslash
texttt{memberptr()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

returns a member pointer to entity or 0 for nonmembers
\end_layout

\begin_layout Description

\family typewriter
\series medium
Array
\begin_inset space ~
\end_inset

*array()
\family default
\series default
 
\family typewriter

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
array@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{array()}
\end_layout

\end_inset


\end_layout

\end_inset


\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}!array@
\backslash
texttt{array()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

returns a typed pointer to the accessed array
\end_layout

\begin_layout Description

\family typewriter
\series medium
Dim<i>::Idx
\begin_inset space ~
\end_inset

idx<i>() 
\series default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
idc@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{idx()}
\end_layout

\end_inset


\end_layout

\end_inset


\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}!idx@
\backslash
texttt{idx()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

returns the value of the 
\emph on
i
\emph default
th index used for the array access
\end_layout

\begin_layout Description

\family typewriter
\series medium
void
\begin_inset space ~
\end_inset

proceed()
\family default
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
proceed@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{proceed()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}!proceed()@
\backslash
texttt{proceed()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

executes the original join point code in an around advice by calling 
\family typewriter
action().trigger()
\end_layout

\begin_layout Description

\family typewriter
\series medium
AC::Action
\begin_inset space ~
\end_inset

&action()
\family default
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
action@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{action()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}!action@
\backslash
texttt{action()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

returns the runtime action object containing the execution environment to
 execute the original functionality encapsulated by an around advice
\end_layout

\begin_layout Subsubsection*
Example: 
\begin_inset CommandInset label
LatexCommand label
name "exa:non-static-function-usage"

\end_inset

non-static function usage
\family typewriter

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}|)
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
runtime support!JoinPoint@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}|)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
API for Static Join Points
\end_layout

\begin_layout Standard
The JoinPoint-API for static join points can be used within the definition
 of a slice and describes the state of target class 
\emph on
before
\emph default
 the introduction took place.
 It is accessed through the built-in type 
\family typewriter
JoinPoint
\family default
 (e.g.
 
\family typewriter
JoinPoint::signature()
\family default
) and provides the following functions, types, and constants:
\begin_inset Note Note
status open

\begin_layout Plain Layout
index entries missing here
\end_layout

\end_inset


\end_layout

\begin_layout Description

\family typewriter
\series medium
static
\begin_inset space ~
\end_inset

const
\begin_inset space ~
\end_inset

char
\begin_inset space ~
\end_inset

*signature()
\family default
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
signature@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{signature()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}!signature@
\backslash
texttt{signature()}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

returns the target class name as a string
\end_layout

\begin_layout Description

\family typewriter
\series medium
That
\family default
\series default
 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

The (incomplete) target type of the introduction
\end_layout

\begin_layout Description

\family typewriter
\series medium
HASHCODE
\family default
\series default
 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

integer hash value of the target type
\end_layout

\begin_layout Description

\family typewriter
\series medium
BASECLASSES
\family default
\series default
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
BASECLASSES@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{BASECLASSES}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
JoinPoint@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{JoinPoint}!BASECLASSES@
\backslash
texttt{BASECLASSES}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

number of base classes of the target class
\end_layout

\begin_layout Description

\family typewriter
\series medium
BaseClass<I>::Type
\family default
\series default
 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

type of the 
\begin_inset ERT
status open

\begin_layout Plain Layout

$I^{
\backslash
,th}$
\end_layout

\end_inset

 base class
\end_layout

\begin_layout Description

\family typewriter
\series medium
BaseClass<I>::prot,
\begin_inset space ~
\end_inset

BaseClass<I>::spec
\family default
\series default
 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

Protection level (AC::PROT_NONE /PRIVATE /PROTECTED /PUBLIC) and additional
 specifiers (AC::SPEC_NONE /VIRTUAL) of the 
\begin_inset ERT
status open

\begin_layout Plain Layout

$I^{
\backslash
,th}$
\end_layout

\end_inset

 base class
\end_layout

\begin_layout Description

\family typewriter
\series medium
MEMBERS
\family default
\series default
 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

number of data members of the target class
\end_layout

\begin_layout Description

\family typewriter
\series medium
Member<I>::Type,
\series default

\begin_inset space ~
\end_inset


\series medium
Member<I>::ReferredType
\family default
\series default
 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

type of the 
\begin_inset ERT
status open

\begin_layout Plain Layout

$I^{
\backslash
,th}$
\end_layout

\end_inset

 member variable of the target class
\end_layout

\begin_layout Description

\family typewriter
\series medium
Member<I>::prot,
\begin_inset space ~
\end_inset

Member<I>::spec
\family default
\series default
 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

Protection level (see BaseClass<I>::prot) and additional member variable
 specifiers (AC::SPEC_NONE /STATIC /MUTABLE)
\end_layout

\begin_layout Description

\family typewriter
\series medium
static
\begin_inset space ~
\end_inset

ReferredType
\begin_inset space ~
\end_inset

*Member<I>::
\emph on
pointer(
\emph default
T
\begin_inset space ~
\end_inset

*obj=0
\emph on
)
\family default
\series default
\emph default
 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

returns a typed pointer to the 
\begin_inset ERT
status open

\begin_layout Plain Layout

$I^{
\backslash
,th}$
\end_layout

\end_inset

 member variable (obj is needed for non-static member variables)
\end_layout

\begin_layout Description

\family typewriter
\series medium
static
\begin_inset space ~
\end_inset

const
\begin_inset space ~
\end_inset

char
\begin_inset space ~
\end_inset

*Member<I>::
\emph on
name
\emph default
()
\family default
\series default
 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

returns the name of the 
\begin_inset ERT
status open

\begin_layout Plain Layout

$I^{
\backslash
,th}$
\end_layout

\end_inset

 member variable
\end_layout

\begin_layout Description

\family typewriter
\series medium
FUNCTIONS
\family default
\series default
 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

number of member functions of the target class
\end_layout

\begin_layout Description

\family typewriter
\series medium
Function<I>::prot,
\begin_inset space ~
\end_inset

Function<I>::spec
\family default
\series default
 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

Protection level (see BaseClass<I>::prot) and additional member variable
 specifiers (AC::SPEC_NONE /STATIC /VIRTUAL)
\end_layout

\begin_layout Description

\family typewriter
\series medium
CONSTRUCTORS
\family default
\series default
 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

number of user-defined constructors of the target class
\end_layout

\begin_layout Description

\family typewriter
\series medium
Constructor<I>::prot,
\begin_inset space ~
\end_inset

Constructor<I>::spec
\family default
\series default
 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

Protection level (see BaseClass<I>::prot) and additional member variable
 specifiers (AC::SPEC_NONE)
\end_layout

\begin_layout Description

\family typewriter
\series medium
DESTRUCTORS
\family default
\series default
 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

number (zero or one) of user-defined destructors of the target class
\end_layout

\begin_layout Description

\family typewriter
\series medium
Destructor<I>::prot,
\begin_inset space ~
\end_inset

Destructor<I>::spec
\family default
\series default
 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

Protection level (see BaseClass<I>::prot) and additional member variable
 specifiers (AC::SPEC_NONE /VIRTUAL)
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:ordering"

\end_inset

Advice Ordering
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
advice!ordering
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

(
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:aspect-precedence"

\end_inset

Aspect Precedence
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
precedence!of aspects
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

(
\end_layout

\end_inset


\end_layout

\begin_layout Standard
AspectC++ provides a very flexible mechanism to define aspect precedence.
 The precedence is used to determine the execution order of advice code
 if more than one aspect affects the same join point.
 The precedence in AspectC++ is a member of a join point.
 This means that the precedence relationship between two aspects might vary
 in different parts of the system.
 The compiler checks the following conditions to determine the precedence
 of aspects:
\end_layout

\begin_layout Description
order
\begin_inset space ~
\end_inset

declaration: if the programmer provides an order declaration, which defines
 the precedence relationship between two aspects for a join point, the compiler
 will obey this definition or abort with a compile-time error if there is
 a cycle in the precedence graph.
 Order declarations have the following syntax:
\family typewriter
\series bold

\begin_inset Newline newline
\end_inset

advice
\family default
\series default
 
\emph on
pointcut-expr
\emph default
 : 
\family typewriter
\series bold
order
\family default
\series default
 
\family typewriter
\series bold
(
\family default
\series default
 
\emph on
high
\family typewriter
\series bold
\emph default
,
\family default
\series default
 ...
\emph on
low
\emph default
 
\family typewriter
\series bold
)
\begin_inset Newline newline
\end_inset


\family default
\series default
The argument list of 
\family typewriter
order
\family default
 has to contain at least two elements.
 Each element is a pointcut expression, which describes a set of aspects.
 Each aspect in a certain set has a higher precedence than all aspects,
 which are part of a set following later in the list (on the right hand
 side).
 For example '
\family typewriter
("A1"||"A2","A3"||"A4")
\family default
' means that 
\family typewriter
A1
\family default
 has precedence over 
\family typewriter
A3
\family default
 and 
\family typewriter
A4
\family default
 and that 
\family typewriter
A2
\family default
 has precedence over 
\family typewriter
A3
\family default
 and 
\family typewriter
A4
\family default
.
 This order directive does 
\emph on
not
\emph default
 define the relation between 
\family typewriter
A1
\family default
 and 
\family typewriter
A2
\family default
 or 
\family typewriter
A3
\family default
 and 
\family typewriter
A4
\family default
.
 Of course, the pointcut expressions in the argument list of 
\family typewriter
order
\family default
 may contain named pointcuts and even pure virtual pointcuts.
\end_layout

\begin_layout Description
inheritance
\begin_inset space ~
\end_inset

relation: if there is no order declaration given and one aspect has a base
 aspect the derived aspect has a higher precedence than the base aspect.
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
precedence!of aspects
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:advice-precedence"

\end_inset

Advice Precedence
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
precedence!of advice
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

(
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The precedence of advice is determined with a very simple scheme:
\end_layout

\begin_layout Itemize
if two advice declarations belong to different aspects and there is a precedence
 relation between these aspects (see section 
\begin_inset CommandInset ref
LatexCommand vref
reference "subsec:aspect-precedence"

\end_inset

) the same relation will be assumed for the advice.
\end_layout

\begin_layout Itemize
if two advice declarations belong to the same aspect the one that is declared
 first has the higher precedence.
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
precedence!of advice
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Effects of Advice Precedence
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
precedence!effects
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

(
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Only advice precedence has an effect on the generated code.
 The effect depends on the kind of join point, which is affected by two
 advice declarations.
\end_layout

\begin_layout Subsubsection*
Class Join Points
\end_layout

\begin_layout Standard
Advice on class join points can extend the member variable list or base
 class list.
 If advice has a higher precedence than another it will be handled first.
 For example, an introduced new base class of advice with a high precedence
 will appear in the base class list on the left side of a base class, which
 was inserted by advice with lower precedence.
 This means that the execution order of the constructors of introduced base
 classes can be influenced, for instance, by order declarations.
\end_layout

\begin_layout Standard
The order of introduced member variables also has an impact on the constructor/d
estructor execution order as well as the object layout.
\end_layout

\begin_layout Subsubsection*
Code Join Points
\end_layout

\begin_layout Standard
Advice on code join points can be 
\family typewriter
before
\family default
, 
\family typewriter
after
\family default
, or 
\family typewriter
around
\family default
 advice.
 For 
\family typewriter
before
\family default
 and 
\family typewriter
around
\family default
 advice a higher precedence means that the corresponding advice code will
 be run first.
 For 
\family typewriter
after
\family default
 advice a higher precedence means that the advice code will be run later.
\end_layout

\begin_layout Standard
If 
\family typewriter
around
\family default
 advice code does not call 
\family typewriter
tjp->proceed()
\family default
 or 
\family typewriter
trigger()
\family default
 on the action object no advice code with lower precedence will be run.
 The execution of advice with higher precedence is not affected by 
\family typewriter
around
\family default
 advice with lower precedence.
\end_layout

\begin_layout Standard
For example, consider an aspect that defines advice
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
BE is 
\family typewriter
before
\family default
 advice, AF 
\family typewriter
after
\family default
 advice, and AR 
\family typewriter
around
\family default
 advice
\end_layout

\end_inset

 in the following order: BE1, AF1, AF2, AR1, BE2, AR2, AF3.
 As described in section 
\begin_inset CommandInset ref
LatexCommand vref
reference "subsec:advice-precedence"

\end_inset

 the declaration order also defines the precedence: BE1 has the highest
 and AF3 the lowest.
 The result is the following advice code execution sequence:
\end_layout

\begin_layout Enumerate
BE1 (highest precedence)
\end_layout

\begin_layout Enumerate
AR1 (the indented advice will only be executed if 
\family typewriter
proceed()
\family default
 is called!)
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
BE2 (before AR2, buts depends on AR1)
\end_layout

\begin_layout Enumerate
AR2 (the indented code will only be executed if 
\family typewriter
proceed()
\family default
 is called!)
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
original code under the join point
\end_layout

\begin_layout Enumerate
AF3
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
AF2 (does not depend on AR1 and AR2, because of higher precedence)
\end_layout

\begin_layout Enumerate
AF1 (run after AF2, because it has a higher precedence)
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
precedence!effects
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

)
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
advice!ordering
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

|
\end_layout

\end_inset

)
\end_layout

\end_inset


\end_layout

\begin_layout Section
List of Examples
\end_layout

\begin_layout Standard
\noindent
match expressions (name pointcuts), 
\begin_inset CommandInset ref
LatexCommand pageref
reference "exa:match-expressions"

\end_inset


\end_layout

\begin_layout Standard
\noindent
pointcut expressions, 
\begin_inset CommandInset ref
LatexCommand pageref
reference "exa:pointcut-expressions"

\end_inset


\end_layout

\begin_layout Standard
\noindent
pointcut declaration, 
\begin_inset CommandInset ref
LatexCommand pageref
reference "exa:pointcut-declaration"

\end_inset


\end_layout

\begin_layout Standard
\noindent
pure virtual pointcut declaration, 
\begin_inset CommandInset ref
LatexCommand pageref
reference "exa:pure-virtual"

\end_inset


\end_layout

\begin_layout Standard
\noindent
class slice declaration, 
\begin_inset CommandInset ref
LatexCommand pageref
reference "exa:class-slice-declaration"

\end_inset


\end_layout

\begin_layout Standard
\noindent
advice declaration, 
\begin_inset CommandInset ref
LatexCommand pageref
reference "exa:advice-declaration"

\end_inset


\end_layout

\begin_layout Standard
\noindent
advice declaration with access to context information, 
\begin_inset CommandInset ref
LatexCommand pageref
reference "exa:advice-declaration-with"

\end_inset


\end_layout

\begin_layout Standard
\noindent
introductions, 
\begin_inset CommandInset ref
LatexCommand pageref
reference "exa:introductions"

\end_inset


\end_layout

\begin_layout Standard
\noindent
base class introduction, 
\begin_inset CommandInset ref
LatexCommand pageref
reference "exa:base-class-intro"

\end_inset


\end_layout

\begin_layout Standard
\noindent
advice ordering, 
\begin_inset CommandInset ref
LatexCommand pageref
reference "exa:order"

\end_inset


\end_layout

\begin_layout Standard
\noindent
aspect declaration, 
\begin_inset CommandInset ref
LatexCommand pageref
reference "exa:aspect-decl"

\end_inset


\end_layout

\begin_layout Standard
\noindent
abstract aspect, 
\begin_inset CommandInset ref
LatexCommand pageref
reference "exa:abstract-aspect"

\end_inset


\end_layout

\begin_layout Standard
\noindent
reused abstract aspect, 
\begin_inset CommandInset ref
LatexCommand pageref
reference "exa:reused-abstract"

\end_inset


\end_layout

\begin_layout Standard
\noindent
aspect instantiation using 
\family typewriter
aspectof
\family default
, 
\begin_inset CommandInset ref
LatexCommand pageref
reference "exa:aspect-aspectof"

\end_inset


\end_layout

\begin_layout Standard
\noindent
re-usable trace aspect, 
\begin_inset CommandInset ref
LatexCommand pageref
reference "exa:re-usable-trace"

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{comment}
\end_layout

\end_inset

static type identification using introductions, 
\begin_inset CommandInset ref
LatexCommand pageref
reference "exa:static-type-id"

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{comment}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{comment}
\end_layout

\end_inset

extended thread counting, 
\begin_inset CommandInset ref
LatexCommand pageref
reference "exa:extended-thread"

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{comment}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
type, scope, and name parts of a function match expression, 
\begin_inset CommandInset ref
LatexCommand pageref
reference "exa:match-expr-parts-functions"

\end_inset


\end_layout

\begin_layout Standard
\noindent
simple name patterns, 
\begin_inset CommandInset ref
LatexCommand pageref
reference "exa:match-name-patterns"

\end_inset


\end_layout

\begin_layout Standard
\noindent
operator name patterns, 
\begin_inset CommandInset ref
LatexCommand pageref
reference "exa:match-operator-name-patterns"

\end_inset


\end_layout

\begin_layout Standard
\noindent
conversion function name patterns, 
\begin_inset CommandInset ref
LatexCommand pageref
reference "exa:match-conversion-function-name-patterns"

\end_inset


\end_layout

\begin_layout Standard
\noindent
scope patterns, 
\begin_inset CommandInset ref
LatexCommand pageref
reference "exa:match-scope-patterns"

\end_inset


\end_layout

\begin_layout Standard
\noindent
type patterns with the wildcard character, 
\begin_inset CommandInset ref
LatexCommand pageref
reference "exa:match-type-patterns-wildcard"

\end_inset


\end_layout

\begin_layout Standard
\noindent
type patterns with 
\family typewriter
const
\family default
 and 
\family typewriter
volatile
\family default
, 
\begin_inset CommandInset ref
LatexCommand pageref
reference "exa:match-type-patterns-cv"

\end_inset


\end_layout

\begin_layout Standard
\noindent
type patterns with 
\family typewriter
virtual
\family default
, 
\begin_inset CommandInset ref
LatexCommand pageref
reference "exa:match-type-patterns-virtual"

\end_inset


\end_layout

\begin_layout Standard
\noindent
type matching, 
\begin_inset CommandInset ref
LatexCommand pageref
reference "exa:type-matching"

\end_inset


\end_layout

\begin_layout Standard
\noindent
control flow dependant advice activation, 
\begin_inset CommandInset ref
LatexCommand pageref
reference "exa:control-flow"

\end_inset


\end_layout

\begin_layout Standard
\noindent
matching in scopes, 
\begin_inset CommandInset ref
LatexCommand pageref
reference "exa:matching-in-scopes"

\end_inset


\end_layout

\begin_layout Standard
\noindent
function matching, 
\begin_inset CommandInset ref
LatexCommand pageref
reference "exa:function-matching"

\end_inset


\end_layout

\begin_layout Standard
\noindent
instance counting
\begin_inset CommandInset label
LatexCommand label
name "exa:instance-counting-1"

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{comment}
\end_layout

\end_inset

member variable matching, 
\begin_inset CommandInset ref
LatexCommand pageref
reference "exa:variable-matching"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{comment}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
context matching, 
\begin_inset CommandInset ref
LatexCommand pageref
reference "exa:context-matching"

\end_inset


\end_layout

\begin_layout Standard
\noindent
combining pointcut expressions, 
\begin_inset CommandInset ref
LatexCommand pageref
reference "exa:combining-pointcut"

\end_inset


\end_layout

\begin_layout Standard
\noindent
attribute declaration, 
\begin_inset CommandInset ref
LatexCommand pageref
reference "exa:attribute-declaration"

\end_inset


\end_layout

\begin_layout Standard
\noindent
using attributes to annotate program elements, 
\begin_inset CommandInset ref
LatexCommand pageref
reference "exa:attribute-qualified"

\end_inset


\end_layout

\begin_layout Standard
\noindent
using attributes in pointcut expressions, 
\begin_inset CommandInset ref
LatexCommand pageref
reference "exa:attribute-pointcut-expression"

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\noindent
advice placement, 
\begin_inset CommandInset ref
LatexCommand pageref
reference "exa:advice-placement"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
type usage, 
\begin_inset CommandInset ref
LatexCommand pageref
reference "exa:type-usage"

\end_inset


\end_layout

\begin_layout Standard
\noindent
static function usage, 
\begin_inset CommandInset ref
LatexCommand pageref
reference "exa:static-function-usage"

\end_inset


\end_layout

\begin_layout Standard
\noindent
non-static function usage, 
\begin_inset CommandInset ref
LatexCommand pageref
reference "exa:non-static-function-usage"

\end_inset


\end_layout

\begin_layout Section
\start_of_appendix
Grammar
\begin_inset Index idx
status open

\begin_layout Plain Layout
grammar
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The AspectC++ syntax is an extension to the C++ syntax.
 It adds five new keywords to the C++ language: 
\family typewriter
aspect
\family default
, 
\family typewriter
advice
\family default
, 
\family typewriter
slice
\family default
, 
\family typewriter
pointcut
\family default
, and 
\family typewriter
attribute
\family default
.
 Additionally it extends the C++ language by advice and pointcut declarations.
 In contrast to pointcut declarations, advice declarations may only occur
 in aspect declarations.
 
\end_layout

\begin_layout Description

\series medium
\shape italic
class-key:
\series default
\shape default
 
\series bold

\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\family typewriter
\series default
aspect
\end_layout

\begin_layout Description

\series medium
\shape italic
declaration:
\series default
\shape default
 
\shape italic

\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

pointcut-declaration
\begin_inset Newline newline
\end_inset

slice-declaration
\begin_inset Newline newline
\end_inset

advice-declaration
\begin_inset Newline newline
\end_inset

attribute-declaration
\end_layout

\begin_layout Description

\series medium
\shape italic
member-declaration:
\series default
\shape default
 
\shape italic

\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

pointcut-declaration
\begin_inset Newline newline
\end_inset

slice-declaration
\begin_inset Newline newline
\end_inset

advice-declaration
\begin_inset Newline newline
\end_inset

attribute-declaration
\end_layout

\begin_layout Description

\series medium
\shape italic
pointcut-declaration:
\series default
\shape default
 
\shape italic
\emph on

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pointcut!declaration
\end_layout

\end_inset


\emph default

\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\family typewriter
\shape default
pointcut
\family default
 
\shape italic

\begin_inset space ~
\end_inset

declaration
\end_layout

\begin_layout Description

\series medium
\shape italic
pointcut-expression:
\series default
\shape default
 
\series medium
\shape italic

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pointcut!expression
\end_layout

\end_inset


\series default

\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

constant-expression
\end_layout

\begin_layout Description

\series medium
\shape italic
advice-declaration:
\series default
\shape default
 
\shape italic

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
advice!declaration
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\family typewriter
\shape default
advice
\family default
 
\shape italic

\begin_inset space ~
\end_inset

pointcut-expression
\begin_inset space ~
\end_inset


\shape default
 
\series bold
:
\series default
 
\shape italic

\begin_inset space ~
\end_inset

order-declaration
\begin_inset Newline newline
\end_inset


\family typewriter
\shape default
advice
\family default
 
\shape italic

\begin_inset space ~
\end_inset

pointcut-expression
\begin_inset space ~
\end_inset


\shape default
 
\series bold
:
\series default
 
\shape italic

\begin_inset space ~
\end_inset

slice-reference
\begin_inset Newline newline
\end_inset


\family typewriter
\shape default
advice
\family default
 
\shape italic

\begin_inset space ~
\end_inset

pointcut-expression
\begin_inset space ~
\end_inset


\shape default
 
\series bold
:
\series default
 
\shape italic

\begin_inset space ~
\end_inset

declaration
\end_layout

\begin_layout Description

\series medium
\shape italic
order-declaration:
\series default
\shape default
 
\shape italic

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
order!declaration
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\family typewriter
\shape default
order (
\family default
 
\shape italic

\begin_inset space ~
\end_inset

pointcur-expression-seq
\begin_inset space ~
\end_inset


\family typewriter
\shape default
)
\end_layout

\begin_layout Description

\series medium
\shape italic
slice-reference:
\series default
\shape default
 
\shape italic

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
slice!reference
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\family typewriter
\shape default
slice
\begin_inset space ~
\end_inset

::
\family default
\shape italic

\begin_inset Formula $_{\textrm{opt}}$
\end_inset


\begin_inset space ~
\end_inset

nested-name-specifier
\begin_inset Formula $_{\textrm{opt}}$
\end_inset

 unqualified-id
\begin_inset space ~
\end_inset


\family typewriter
\series bold
\emph on
;
\end_layout

\begin_layout Description

\series medium
\shape italic
slice-declaration:
\series default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
slice!declaration
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\family typewriter
\emph on
slice
\family default
\shape default
\emph default
 
\series medium
\shape italic
declaration
\end_layout

\begin_layout Description

\series medium
\shape italic
attribute-declaration:
\series default
\shape default
 
\shape italic
\emph on

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
attribute!declaration
\end_layout

\end_inset


\emph default

\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\family typewriter
\shape default
attribute
\family default
 
\shape italic

\begin_inset space ~
\end_inset

unqualified-id
\emph on

\begin_inset space ~
\end_inset


\family typewriter
(
\begin_inset space ~
\end_inset

)
\begin_inset space ~
\end_inset

;
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Match-Expression-Grammar"

\end_inset

Match Expression Grammar
\begin_inset Index idx
status open

\begin_layout Plain Layout
match expression!grammar
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
match expression grammar
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Match expression in AspectC++ are used to define a type pattern and an optional
 object name pattern to select a subset of the known program entities like
 functions, member variables, or argument/result types.
 The grammar is very similar to the grammar of C++ declarations.
 Any rules, which are referenced here but not defined, should be looked
 up in the ISO C++ standard.
\end_layout

\begin_layout Description

\series medium
\shape italic
match-expression:
\series default
\shape default
 
\series bold

\begin_inset space ~
\end_inset


\series default
 
\family typewriter

\begin_inset Newline newline
\end_inset


\family default
\shape italic
match-declaration
\end_layout

\begin_layout Description

\series medium
\emph on
match-id:
\series default
\emph default
 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\family typewriter
%
\family default

\begin_inset Newline newline
\end_inset


\emph on
nondigit
\emph default

\begin_inset Newline newline
\end_inset


\emph on
match-id
\emph default
 
\family typewriter
%
\family default

\begin_inset Newline newline
\end_inset


\emph on
match-id nondigit
\emph default

\begin_inset Newline newline
\end_inset


\emph on
match-id digit
\end_layout

\begin_layout Description

\series medium
\emph on
match-declaration:
\series default
\emph default
 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\emph on
match-decl-specifier-seq
\begin_inset Formula $_{\textrm{opt}}$
\end_inset

 match-declarator
\end_layout

\begin_layout Description

\series medium
\emph on
match-decl-specifier-seq:
\series default
\emph default
 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\emph on
match-decl-specifier-seq
\begin_inset Formula $_{\textrm{opt}}$
\end_inset

 match-decl-specifier
\end_layout

\begin_layout Description

\series medium
\emph on
match-decl-specifier:
\series default
\emph default
 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\emph on
nested-match-name-specifier
\begin_inset Formula $_{\textrm{opt}}$
\end_inset

 match-id
\begin_inset Newline newline
\end_inset

cv-qualifier
\begin_inset Newline newline
\end_inset

match-function-specifier
\begin_inset Newline newline
\end_inset


\family typewriter
\emph default
char
\begin_inset Newline newline
\end_inset

wchar_t
\begin_inset Newline newline
\end_inset

bool
\begin_inset Newline newline
\end_inset

short
\begin_inset Newline newline
\end_inset

int
\begin_inset Newline newline
\end_inset

long
\begin_inset Newline newline
\end_inset

signed
\begin_inset Newline newline
\end_inset

unsigned
\begin_inset Newline newline
\end_inset

float
\begin_inset Newline newline
\end_inset

double
\begin_inset Newline newline
\end_inset

void
\end_layout

\begin_layout Description

\series medium
\emph on
match-function-specifier:
\series default
\emph default
 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\family typewriter
virtual
\begin_inset Newline newline
\end_inset

static
\end_layout

\begin_layout Description

\series medium
\emph on
nested-match-name-specifier:
\series default
\emph default
 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\emph on
match-id
\family typewriter
\emph default

\begin_inset space ~
\end_inset

::
\begin_inset space ~
\end_inset


\family default
\emph on
nested-match-name-specifier
\begin_inset Formula $_{\textrm{opt}}$
\end_inset


\begin_inset Newline newline
\end_inset


\family typewriter
\emph default
...
\begin_inset space ~
\end_inset

::
\begin_inset space ~
\end_inset


\family default
\emph on
nested-match-name-specifier
\begin_inset Formula $_{\textrm{opt}}$
\end_inset


\end_layout

\begin_layout Description

\series medium
\emph on
match-declarator
\series default
\emph default
: 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\emph on
direct-match-declarator
\begin_inset Newline newline
\end_inset

match-ptr-declarator match-declarator
\end_layout

\begin_layout Description

\series medium
\emph on
abstract-match-declarator
\series default
\emph default
: 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\emph on
direct-abstract-match-declarator
\begin_inset Newline newline
\end_inset

match-ptr-declarator abstract-match-declarator
\end_layout

\begin_layout Description

\series medium
\emph on
direct-match-declarator:
\series default
\emph default
 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\emph on
match-declarator-id
\begin_inset Newline newline
\end_inset

direct-match-declarator
\emph default
 
\family typewriter
(
\family default
 
\emph on
match-parameter-declaration-clause
\emph default
 
\family typewriter
)
\family default
 
\emph on
cv-qualifier-seq
\begin_inset Formula $_{\textrm{opt}}$
\end_inset


\begin_inset Newline newline
\end_inset

direct-match-declarator
\emph default
 
\family typewriter
[
\family default
 
\emph on
match-array-size
\emph default
 
\family typewriter
]
\end_layout

\begin_layout Description

\series medium
\emph on
direct-abstract-match-declarator:
\series default
\emph default
 
\begin_inset space ~
\end_inset


\emph on

\begin_inset Newline newline
\end_inset

direct-abstract-match-declarator
\emph default
 
\family typewriter
(
\family default
 
\emph on
match-parameter-declaration-clause
\emph default
 
\family typewriter
)
\family default
 
\emph on
cv-qualifier-seq
\begin_inset Formula $_{\textrm{opt}}$
\end_inset


\begin_inset Newline newline
\end_inset

direct-abstract-match-declarator
\emph default
 
\family typewriter
[
\family default
 
\emph on
match-array-size
\emph default
 
\family typewriter
]
\end_layout

\begin_layout Description

\series medium
\emph on
match-array-size:
\series default
\emph default
 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\family typewriter
%
\family default

\begin_inset Newline newline
\end_inset


\emph on
decimal-literal
\end_layout

\begin_layout Description

\series medium
\emph on
match-ptr-operator:
\series default
\emph default
 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\family typewriter
*
\family default
 
\emph on
cv-qualifier-seq
\begin_inset Formula $_{\textrm{opt}}$
\end_inset


\emph default

\begin_inset Newline newline
\end_inset


\family typewriter
&
\family default

\begin_inset Newline newline
\end_inset


\emph on
nested-match-name-specifier
\emph default
 
\family typewriter
*
\family default
 
\emph on
cv-qualifier-seq
\begin_inset Formula $_{\textrm{opt}}$
\end_inset


\end_layout

\begin_layout Description

\series medium
\emph on
match-parameter-declaration-clause:
\series default
\emph default
 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\family typewriter
\emph on
...
\family default

\begin_inset Newline newline
\end_inset

match-parameter-declaration-list
\begin_inset Formula $_{\textrm{opt}}$
\end_inset


\begin_inset Newline newline
\end_inset

match-parameter-declaration-list
\emph default
 
\family typewriter
\emph on
, ...
\end_layout

\begin_layout Description

\series medium
\emph on
match-parameter-declaration-list:
\series default
\emph default
 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\emph on
match-parameter-declaration
\begin_inset Newline newline
\end_inset

match-parameter-declaration-list
\emph default
 
\family typewriter
\emph on
,
\family default
\emph default
 
\emph on
match-parameter-declaration
\end_layout

\begin_layout Description

\series medium
\emph on
match-parameter-declaration:
\series default
\emph default
 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\emph on
matct-decl-specifier-seq match-abstract-declarator
\begin_inset Formula $_{\textrm{opt}}$
\end_inset


\end_layout

\begin_layout Description

\series medium
\emph on
match-declarator-id:
\series default
\emph default
 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\emph on
nested-match-name-specifier
\begin_inset Formula $_{\textrm{opt}}$
\end_inset

 match-id
\begin_inset Newline newline
\end_inset

nested-match-name-specifier
\begin_inset Formula $_{\textrm{opt}}$
\end_inset

 match-operator-function-id
\begin_inset Newline newline
\end_inset

nested-match-name-specifier
\begin_inset Formula $_{\textrm{opt}}$
\end_inset

 match-conversion-function-id
\end_layout

\begin_layout Description

\series medium
\emph on
match-operator-function-id:
\series default
\emph default
 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\family typewriter
operator %
\family default

\begin_inset Newline newline
\end_inset


\family typewriter
operator
\family default
 
\emph on
match-operator
\end_layout

\begin_layout Description

\series medium
\emph on
match-operator:
\series default
\emph default
 one of
\begin_inset Newline newline
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="13">
<features tabularvalignment="middle">
<column alignment="block" valignment="top" width="0.6cm">
<column alignment="block" valignment="top" width="0.6cm">
<column alignment="block" valignment="top" width="0.6cm">
<column alignment="block" valignment="top" width="0.6cm">
<column alignment="block" valignment="top" width="0.6cm">
<column alignment="block" valignment="top" width="0.6cm">
<column alignment="block" valignment="top" width="0.6cm">
<column alignment="block" valignment="top" width="0.6cm">
<column alignment="block" valignment="top" width="0.6cm">
<column alignment="block" valignment="top" width="0.6cm">
<column alignment="block" valignment="top" width="0.6cm">
<column alignment="block" valignment="top" width="0.6cm">
<column alignment="block" valignment="top" width="0.6cm">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
new
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
delete
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
new[]
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
delete[]
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
+
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
-
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
*
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
/
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
%%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
^
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
&
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
~
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
<
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
+=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
-=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
*=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
/=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
%%=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
^=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
&=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
|=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
<<
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
>>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
>>=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
<<=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
==
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
!=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
<=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
>=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
&&
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
||
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
++
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
--
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
,
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.*
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
->*
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
->
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
[]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
?:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Description

\series medium
\emph on
match-conversion-function-id:
\series default
\emph default
 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\family typewriter
operator
\family default
 
\emph on
match-conversion-type-id
\end_layout

\begin_layout Description

\series medium
\emph on
match-conversion-type-id:
\series default
\emph default
 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\emph on
match-type-specifier-seq match-conversion-declarator
\begin_inset Formula $_{\textrm{opt}}$
\end_inset


\end_layout

\begin_layout Description

\series medium
\emph on
match-conversion-declarator:
\series default
\emph default
 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\emph on
match-ptr-operator match-conversion-declarator
\begin_inset Formula $_{\textrm{opt}}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:appendix:projectmodel_structure"

\end_inset

Structure Of The Project Repository
\begin_inset Index idx
status open

\begin_layout Plain Layout
project repository
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:acpp_structure_big"

\end_inset

 shows the internal structure of the AspectC++ model and the AspectC++ project
 repository.
 The distinction between name and code join points and also the inheritance
 hierarchy is visible.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/acmodel-rotated90.pdf
	width 9.6cm
	scaleBeforeRotation
	rotateOrigin leftTop

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:acpp_structure_big"

\end_inset

Structure of the AspectC++ project repository
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Project-Repository-File"

\end_inset

Project Repository File For Example 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "exa:shape_example_code"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
project repository
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},breaklines=true,showstringspaces=false,tabsize=2"
inline false
status open

\begin_layout Plain Layout

<?xml version="1.0"?>
\end_layout

\begin_layout Plain Layout

<ac-model version="1.2" ids="7">
\end_layout

\begin_layout Plain Layout

  <files>
\end_layout

\begin_layout Plain Layout

    <TUnit filename="shape.cpp" len="42" time="1442951698" id="0"/>
\end_layout

\begin_layout Plain Layout

  </files>
\end_layout

\begin_layout Plain Layout

  <root>
\end_layout

\begin_layout Plain Layout

    <Namespace name="::">
\end_layout

\begin_layout Plain Layout

      <children>
\end_layout

\begin_layout Plain Layout

        <Class name="Shape" id="1">
\end_layout

\begin_layout Plain Layout

          <children>
\end_layout

\begin_layout Plain Layout

            <Function kind="8" cv_qualifiers="0" name="~Shape" builtin="true">
\end_layout

\begin_layout Plain Layout

              <children>
\end_layout

\begin_layout Plain Layout

                <Destruction/>
\end_layout

\begin_layout Plain Layout

              </children>
\end_layout

\begin_layout Plain Layout

            </Function>
\end_layout

\begin_layout Plain Layout

            <Function kind="7" cv_qualifiers="0" name="Shape" builtin="true">
\end_layout

\begin_layout Plain Layout

              <children>
\end_layout

\begin_layout Plain Layout

                <Construction/>
\end_layout

\begin_layout Plain Layout

              </children>
\end_layout

\begin_layout Plain Layout

            </Function>
\end_layout

\begin_layout Plain Layout

            <Function kind="7" cv_qualifiers="0" name="Shape" builtin="true">
\end_layout

\begin_layout Plain Layout

              <arg_types>
\end_layout

\begin_layout Plain Layout

                <Type signature="const Shape &amp;"/>
\end_layout

\begin_layout Plain Layout

              </arg_types>
\end_layout

\begin_layout Plain Layout

              <children>
\end_layout

\begin_layout Plain Layout

                <Construction/>
\end_layout

\begin_layout Plain Layout

              </children>
\end_layout

\begin_layout Plain Layout

            </Function>
\end_layout

\begin_layout Plain Layout

          </children>
\end_layout

\begin_layout Plain Layout

          <source>
\end_layout

\begin_layout Plain Layout

            <Source kind="1" file="0" line="1" len="1"/>
\end_layout

\begin_layout Plain Layout

            <Source kind="2" file="0" line="1" len="1"/>
\end_layout

\begin_layout Plain Layout

          </source>
\end_layout

\begin_layout Plain Layout

        </Class>
\end_layout

\begin_layout Plain Layout

        <Namespace name="Circle">
\end_layout

\begin_layout Plain Layout

          <children>
\end_layout

\begin_layout Plain Layout

            <Class bases="1" name="S_Circle" id="4">
\end_layout

\begin_layout Plain Layout

              <children>
\end_layout

\begin_layout Plain Layout

                <Function kind="7" cv_qualifiers="0" name="S_Circle" builtin="tr
ue">
\end_layout

\begin_layout Plain Layout

                  <children>
\end_layout

\begin_layout Plain Layout

                    <Construction/>
\end_layout

\begin_layout Plain Layout

                  </children>
\end_layout

\begin_layout Plain Layout

                </Function>
\end_layout

\begin_layout Plain Layout

                <Function kind="7" cv_qualifiers="0" name="S_Circle" builtin="tr
ue">
\end_layout

\begin_layout Plain Layout

                  <arg_types>
\end_layout

\begin_layout Plain Layout

                    <Type signature="const Circle::S_Circle &amp;"/>
\end_layout

\begin_layout Plain Layout

                  </arg_types>
\end_layout

\begin_layout Plain Layout

                  <children>
\end_layout

\begin_layout Plain Layout

                    <Construction/>
\end_layout

\begin_layout Plain Layout

                  </children>
\end_layout

\begin_layout Plain Layout

                </Function>
\end_layout

\begin_layout Plain Layout

                <Variable kind="3" name="m_radius">
\end_layout

\begin_layout Plain Layout

                  <type>
\end_layout

\begin_layout Plain Layout

                    <Type signature="int"/>
\end_layout

\begin_layout Plain Layout

                  </type>
\end_layout

\begin_layout Plain Layout

                  <source>
\end_layout

\begin_layout Plain Layout

                    <Source kind="1" file="0" line="8" len="1"/>
\end_layout

\begin_layout Plain Layout

                  </source>
\end_layout

\begin_layout Plain Layout

                </Variable>
\end_layout

\begin_layout Plain Layout

                <Function kind="3" cv_qualifiers="0" name="radius" id="3">
\end_layout

\begin_layout Plain Layout

                  <result_type>
\end_layout

\begin_layout Plain Layout

                    <Type signature="void"/>
\end_layout

\begin_layout Plain Layout

                  </result_type>
\end_layout

\begin_layout Plain Layout

                  <arg_types>
\end_layout

\begin_layout Plain Layout

                    <Type signature="int"/>
\end_layout

\begin_layout Plain Layout

                  </arg_types>
\end_layout

\begin_layout Plain Layout

                  <children>
\end_layout

\begin_layout Plain Layout

                    <Execution/>
\end_layout

\begin_layout Plain Layout

                    <Builtin target="2" lid="0">
\end_layout

\begin_layout Plain Layout

                      <source>
\end_layout

\begin_layout Plain Layout

                        <Source kind="0" file="0" line="11" len="1"/>
\end_layout

\begin_layout Plain Layout

                      </source>
\end_layout

\begin_layout Plain Layout

                    </Builtin>
\end_layout

\begin_layout Plain Layout

                  </children>
\end_layout

\begin_layout Plain Layout

                  <source>
\end_layout

\begin_layout Plain Layout

                    <Source kind="1" file="0" line="10" len="3"/>
\end_layout

\begin_layout Plain Layout

                  </source>
\end_layout

\begin_layout Plain Layout

                </Function>
\end_layout

\begin_layout Plain Layout

                <Function kind="8" cv_qualifiers="0" name="~S_Circle">
\end_layout

\begin_layout Plain Layout

                  <children>
\end_layout

\begin_layout Plain Layout

                    <Destruction/>
\end_layout

\begin_layout Plain Layout

                  </children>
\end_layout

\begin_layout Plain Layout

                  <source>
\end_layout

\begin_layout Plain Layout

                    <Source kind="1" file="0" line="13" len="1"/>
\end_layout

\begin_layout Plain Layout

                  </source>
\end_layout

\begin_layout Plain Layout

                </Function>
\end_layout

\begin_layout Plain Layout

              </children>
\end_layout

\begin_layout Plain Layout

              <source>
\end_layout

\begin_layout Plain Layout

                <Source kind="1" file="0" line="7" len="8"/>
\end_layout

\begin_layout Plain Layout

                <Source kind="2" file="0" line="7" len="1"/>
\end_layout

\begin_layout Plain Layout

              </source>
\end_layout

\begin_layout Plain Layout

            </Class>
\end_layout

\begin_layout Plain Layout

            <Function kind="1" cv_qualifiers="0" name="draw" id="6">
\end_layout

\begin_layout Plain Layout

              <result_type>
\end_layout

\begin_layout Plain Layout

                <Type signature="void"/>
\end_layout

\begin_layout Plain Layout

              </result_type>
\end_layout

\begin_layout Plain Layout

              <arg_types>
\end_layout

\begin_layout Plain Layout

                <Type signature="int"/>
\end_layout

\begin_layout Plain Layout

              </arg_types>
\end_layout

\begin_layout Plain Layout

              <children>
\end_layout

\begin_layout Plain Layout

                <Execution/>
\end_layout

\begin_layout Plain Layout

                <Call target="3" lid="0" target_class="4">
\end_layout

\begin_layout Plain Layout

                  <source>
\end_layout

\begin_layout Plain Layout

                    <Source kind="0" file="0" line="18" len="1"/>
\end_layout

\begin_layout Plain Layout

                  </source>
\end_layout

\begin_layout Plain Layout

                </Call>
\end_layout

\begin_layout Plain Layout

                <Call target="5" lid="1">
\end_layout

\begin_layout Plain Layout

                  <source>
\end_layout

\begin_layout Plain Layout

                    <Source kind="0" file="0" line="19" len="1"/>
\end_layout

\begin_layout Plain Layout

                  </source>
\end_layout

\begin_layout Plain Layout

                </Call>
\end_layout

\begin_layout Plain Layout

              </children>
\end_layout

\begin_layout Plain Layout

              <source>
\end_layout

\begin_layout Plain Layout

                <Source kind="1" file="0" line="16" len="5"/>
\end_layout

\begin_layout Plain Layout

              </source>
\end_layout

\begin_layout Plain Layout

            </Function>
\end_layout

\begin_layout Plain Layout

          </children>
\end_layout

\begin_layout Plain Layout

          <source>
\end_layout

\begin_layout Plain Layout

            <Source kind="0" file="0" line="4" len="18"/>
\end_layout

\begin_layout Plain Layout

          </source>
\end_layout

\begin_layout Plain Layout

        </Namespace>
\end_layout

\begin_layout Plain Layout

        <Function kind="1" cv_qualifiers="0" name="draw" id="5">
\end_layout

\begin_layout Plain Layout

          <result_type>
\end_layout

\begin_layout Plain Layout

            <Type signature="void"/>
\end_layout

\begin_layout Plain Layout

          </result_type>
\end_layout

\begin_layout Plain Layout

          <arg_types>
\end_layout

\begin_layout Plain Layout

            <Type signature="Shape &amp;"/>
\end_layout

\begin_layout Plain Layout

          </arg_types>
\end_layout

\begin_layout Plain Layout

          <children>
\end_layout

\begin_layout Plain Layout

            <Execution/>
\end_layout

\begin_layout Plain Layout

          </children>
\end_layout

\begin_layout Plain Layout

          <source>
\end_layout

\begin_layout Plain Layout

            <Source kind="1" file="0" line="2" len="1"/>
\end_layout

\begin_layout Plain Layout

          </source>
\end_layout

\begin_layout Plain Layout

        </Function>
\end_layout

\begin_layout Plain Layout

        <Function kind="1" cv_qualifiers="0" name="operator =" builtin="true"
 tunits="0" id="2">
\end_layout

\begin_layout Plain Layout

          <result_type>
\end_layout

\begin_layout Plain Layout

            <Type signature="int &amp;"/>
\end_layout

\begin_layout Plain Layout

          </result_type>
\end_layout

\begin_layout Plain Layout

          <arg_types>
\end_layout

\begin_layout Plain Layout

            <Type signature="int &amp;"/>
\end_layout

\begin_layout Plain Layout

            <Type signature="int"/>
\end_layout

\begin_layout Plain Layout

          </arg_types>
\end_layout

\begin_layout Plain Layout

        </Function>
\end_layout

\begin_layout Plain Layout

        <Function kind="1" cv_qualifiers="0" name="main">
\end_layout

\begin_layout Plain Layout

          <result_type>
\end_layout

\begin_layout Plain Layout

            <Type signature="int"/>
\end_layout

\begin_layout Plain Layout

          </result_type>
\end_layout

\begin_layout Plain Layout

          <children>
\end_layout

\begin_layout Plain Layout

            <Execution/>
\end_layout

\begin_layout Plain Layout

            <Call target="6" lid="0">
\end_layout

\begin_layout Plain Layout

              <source>
\end_layout

\begin_layout Plain Layout

                <Source kind="0" file="0" line="24" len="1"/>
\end_layout

\begin_layout Plain Layout

              </source>
\end_layout

\begin_layout Plain Layout

            </Call>
\end_layout

\begin_layout Plain Layout

          </children>
\end_layout

\begin_layout Plain Layout

          <source>
\end_layout

\begin_layout Plain Layout

            <Source kind="1" file="0" line="23" len="4"/>
\end_layout

\begin_layout Plain Layout

          </source>
\end_layout

\begin_layout Plain Layout

        </Function>
\end_layout

\begin_layout Plain Layout

      </children>
\end_layout

\begin_layout Plain Layout

    </Namespace>
\end_layout

\begin_layout Plain Layout

  </root>
\end_layout

\begin_layout Plain Layout

</ac-model>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset index_print
LatexCommand printindex
type "idx"

\end_inset


\end_layout

\end_body
\end_document
