.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.47.4.
.TH LTL2TGBA "1" "September 2019" "ltl2tgba (spot) 2.8.2" "User Commands"
.SH NAME
ltl2tgba \- translate LTL/PSL formulas into Büchi automata
.SH SYNOPSIS
.B ltl2tgba
[\fI\,OPTION\/\fR...] [\fI\,FORMULA\/\fR...]
.SH DESCRIPTION
Translate linear\-time formulas (LTL/PSL) into various types of automata.
.PP
By default it will apply all available optimizations to output the smallest
Transition\-based Generalized Büchi Automata, output in the HOA format.
If multiple formulas are supplied, several automata will be output.
.TP
\fB\-\-negate\fR
negate each formula
.SS "Input options:"
.TP
\fB\-f\fR, \fB\-\-formula\fR=\fI\,STRING\/\fR
process the formula STRING
.TP
\fB\-F\fR, \fB\-\-file\fR=\fI\,FILENAME\/\fR[\fI\,/COL\/\fR]\fI\,\/\fR
process each line of FILENAME as a formula; if COL
is a positive integer, assume a CSV file and read
column COL; use a negative COL to drop the first
line of the CSV file
.TP
\fB\-\-lbt\-input\fR
read all formulas using LBT's prefix syntax
.TP
\fB\-\-lenient\fR
parenthesized blocks that cannot be parsed as
subformulas are considered as atomic properties
.SS "Output automaton type:"
.TP
\fB\-B\fR, \fB\-\-ba\fR
Büchi Automaton (implies \fB\-S\fR)
.TP
\fB\-\-cobuchi\fR, \fB\-\-coBuchi\fR
automaton with co\-Büchi acceptance (will
recognize a superset of the input language if not
co\-Büchi realizable)
.TP
\fB\-C\fR, \fB\-\-complete\fR
output a complete automaton
.TP
\fB\-G\fR, \fB\-\-generic\fR
any acceptance condition is allowed
.TP
\fB\-M\fR, \fB\-\-monitor\fR
Monitor (accepts all finite prefixes of the given
property)
.HP
\fB\-p\fR, \fB\-\-colored\-parity\fR[\fI\,\/\fR=\fI\,any\/\fR|\fI\,min\/\fR|\fI\,max\/\fR|\fI\,odd\/\fR|\fI\,even\/\fR|\fI\,min\/\fR odd|min even|max odd|max
.TP
even]
colored automaton with parity acceptance
.TP
\fB\-P\fR, \fB\-\-parity\fR[\fI\,\/\fR=\fI\,any\/\fR|\fI\,min\/\fR|\fI\,max\/\fR|\fI\,odd\/\fR|\fI\,even\/\fR|\fI\,min\/\fR odd|min even|max odd|max even]
automaton with parity acceptance
.TP
\fB\-S\fR, \fB\-\-state\-based\-acceptance\fR, \fB\-\-sbacc\fR
define the acceptance using states
.TP
\fB\-\-tgba\fR
Transition\-based Generalized Büchi Automaton
(default)
.TP
\fB\-U\fR, \fB\-\-unambiguous\fR
output unambiguous automata
.SS "Output format:"
.TP
\fB\-8\fR, \fB\-\-utf8\fR
enable UTF\-8 characters in output (ignored with
\fB\-\-lbtt\fR or \fB\-\-spin\fR)
.TP
\fB\-\-check\fR[=\fI\,PROP\/\fR]
test for the additional property PROP and output
the result in the HOA format (implies \fB\-H\fR).  PROP
may be any prefix of 'all' (default),
\&'unambiguous', 'stutter\-invariant', or 'strength'.
.TP
\fB\-d\fR, \fB\-\-dot\fR[=\fI\,1\/\fR|\fI\,a\/\fR|\fI\,A\/\fR|\fI\,b\/\fR|\fI\,B\/\fR|\fI\,c\/\fR|\fI\,C(COLOR)\/\fR|\fI\,e\/\fR|\fI\,f(FONT)\/\fR|\fI\,h\/\fR|\fI\,k\/\fR|\fI\,K\/\fR|\fI\,n\/\fR|\fI\,N\/\fR|\fI\,o\/\fR|\fI\,r\/\fR|\fI\,R\/\fR|\fI\,s\/\fR|\fI\,t\/\fR|\fI\,u\/\fR|\fI\,v\/\fR|\fI\,y\/\fR|\fI\,+INT\/\fR|\fI\,<INT\/\fR|\fI\,#\/\fR]
GraphViz's format.
Add letters for (1) force numbered states, (a)
show acceptance condition (default), (A) hide
acceptance condition, (b) acceptance sets as
bullets, (B) bullets except for Büchi/co\-Büchi
automata, (c) force circular nodes, (C) color
nodes with COLOR, (d) show origins when known, (e)
force elliptic nodes, (f(FONT)) use FONT, (g) hide
edge labels, (h) horizontal layout, (k) use state
labels when possible, (K) use transition labels
(default), (n) show name, (N) hide name, (o)
ordered transitions, (r) rainbow colors for
acceptance sets, (R) color acceptance sets by
Inf/Fin, (s) with SCCs, (t) force transition\-based
acceptance, (u) hide true states, (v) vertical
layout, (y) split universal edges by color, (+INT)
add INT to all set numbers, (<INT) display at most
INT states, (#) show internal edge numbers
.TP
\fB\-H\fR, \fB\-\-hoaf\fR[=\fI\,1.1\/\fR|\fI\,i\/\fR|\fI\,k\/\fR|\fI\,l\/\fR|\fI\,m\/\fR|\fI\,s\/\fR|\fI\,t\/\fR|\fI\,v\/\fR]
Output the automaton in HOA format
(default).  Add letters to select (1.1) version
1.1 of the format, (i) use implicit labels for
complete deterministic automata, (s) prefer
state\-based acceptance when possible [default],
(t) force transition\-based acceptance, (m) mix
state and transition\-based acceptance, (k) use
state labels when possible, (l) single\-line
output, (v) verbose properties
.TP
\fB\-\-lbtt\fR[=\fI\,t\/\fR]
LBTT's format (add =t to force transition\-based
acceptance even on Büchi automata)
.TP
\fB\-\-name\fR=\fI\,FORMAT\/\fR
set the name of the output automaton
.TP
\fB\-o\fR, \fB\-\-output\fR=\fI\,FORMAT\/\fR
send output to a file named FORMAT instead of
standard output.  The first automaton sent to a
file truncates it unless FORMAT starts with '>>'.
.TP
\fB\-q\fR, \fB\-\-quiet\fR
suppress all normal output
.TP
\fB\-s\fR, \fB\-\-spin\fR[=\fI\,6\/\fR|\fI\,c\/\fR]
Spin neverclaim (implies \fB\-\-ba\fR).  Add letters to
select (6) Spin's 6.2.4 style, (c) comments on
states
.TP
\fB\-\-stats\fR=\fI\,FORMAT\/\fR, \fB\-\-format\fR=\fI\,FORMAT\/\fR
output statistics about the automaton
.SS "Any FORMAT string may use the following interpreted sequences:"
.TP
%<
the part of the line before the formula if it
comes from a column extracted from a CSV file
.TP
%>
the part of the line after the formula if it comes
from a column extracted from a CSV file
.TP
%%
a single %
.TP
%a
number of acceptance sets
.TP
%c, %[LETTERS]c
number of SCCs; you may filter the SCCs to count
using the following LETTERS, possibly
concatenated: (a) accepting, (r) rejecting, (c)
complete, (v) trivial, (t) terminal, (w) weak,
(iw) inherently weak. Use uppercase letters to
negate them.
.TP
%d
1 if the output is deterministic, 0 otherwise
.TP
%e
number of reachable edges
.TP
%f
the formula, in Spot's syntax
.TP
%F
name of the input file
.TP
%g, %[LETTERS]g
acceptance condition (in HOA syntax); add brackets
to print an acceptance name instead and LETTERS to
tweak the format: (0) no parameters, (a)
accentuated, (b) abbreviated, (d) style used in
dot output, (g) no generalized parameter, (l)
recognize Street\-like and Rabin\-like, (m) no main
parameter, (p) no parity parameter, (o) name
unknown acceptance as 'other', (s) shorthand for
\&'lo0'.
.TP
%h
the automaton in HOA format on a single line (use
%[opt]h to specify additional options as in
\fB\-\-hoa\fR=\fI\,opt)\/\fR
.TP
%L
location in the input file
.TP
%m
name of the automaton
.TP
%n
number of nondeterministic states in output
.TP
%p
1 if the output is complete, 0 otherwise
.TP
%r
wall\-clock time elapsed in seconds (excluding
parsing)
.TP
%R, %[LETTERS]R
CPU time (excluding parsing), in seconds; Add
LETTERS to restrict to(u) user time, (s) system
time, (p) parent process, or (c) children
processes.
.TP
%s
number of reachable states
.TP
%t
number of reachable transitions
.TP
%u, %[e]u
number of states (or [e]dges) with universal
branching
.TP
%u, %[LETTER]u
1 if the automaton contains some universal
branching (or a number of [s]tates or [e]dges with
universal branching)
.TP
%w
one word accepted by the output automaton
.TP
%x, %[LETTERS]x
number of atomic propositions declared in the
automaton;  add LETTERS to list atomic
propositions with (n) no quoting, (s) occasional
double\-quotes with C\-style escape, (d)
double\-quotes with C\-style escape, (c)
double\-quotes with CSV\-style escape, (p) between
parentheses, any extra non\-alphanumeric character
will be used to separate propositions
.SS "Simplification goal:"
.TP
\fB\-a\fR, \fB\-\-any\fR
no preference, do not bother making it small or
deterministic
.TP
\fB\-D\fR, \fB\-\-deterministic\fR
prefer deterministic automata (combine with
\fB\-\-generic\fR to be sure to obtain a deterministic
automaton)
.TP
\fB\-\-small\fR
prefer small automata (default)
.SS "Simplification level:"
.TP
\fB\-\-high\fR
all available optimizations (slow, default)
.TP
\fB\-\-low\fR
minimal optimizations (fast)
.TP
\fB\-\-medium\fR
moderate optimizations
.SS "Miscellaneous options:"
.TP
\fB\-x\fR, \fB\-\-extra\-options\fR=\fI\,OPTS\/\fR
fine\-tuning options (see spot\-x (7))
.TP
\fB\-\-help\fR
print this help
.TP
\fB\-\-version\fR
print program version
.PP
Mandatory or optional arguments to long options are also mandatory or optional
for any corresponding short options.
.SH "NOTE ON TGBA"
TGBA stands for Transition-based Generalized Büchi Automaton.  The
name was coined by Dimitra Giannakopoulou and Flavio Lerda in their
FORTE'02 paper (From States to Transitions: Improving Translation of
LTL Formulae to Büchi Automata), although similar automata have been
used under different names long before that.
.PP
As its name implies a TGBA uses a generalized Büchi acceptance
condition, meanings that a run of the automaton is accepted iff it
visits ininitely often multiple acceptance sets, and it also uses
transition-based acceptance, i.e., those acceptance sets are sets of
transitions.  TGBA are often more consise than traditional Büchi
automata.  For instance the LTL formula \f(CWGFa & GFb\fR can be
translated into a single-state TGBA while a traditional Büchi
automaton would need 3 states.  Compare
.PP
.in +4n
.nf
.ft C
% ltl2tgba 'GFa & GFb'
.fi
.PP
with
.PP
.in +4n
.ft C
.nf
% ltl2tgba --ba 'GFa & GFb'
.fi
.PP
In the dot output produced by the above commands, the membership of
the transitions to the various acceptance sets is denoted using names
in braces.  The actuall names do not really matter as they may be
produced by the translation algorithm or altered by any latter
postprocessing.
.PP
When the \fB\-\-ba\fR option is used to request a Büchi automaton, Spot
builds a TGBA with a single acceptance set, and in which for any state
either all outgoing transitions are accepting (this is equivalent to
the state being accepting) or none of them are.  Double circles are
used to highlight accepting states in the output, but the braces
denoting the accepting transitions are still shown because the
underling structure really is a TGBA.
.SH "NOTE ON LBTT'S FORMAT"
.UR http://www.tcs.hut.fi/Software/lbtt/doc/html/Format-for-automata.html
LBTT's format
.UE
has support for both transition-based and state based generalized acceptance.
.PP
Because Spot uses transition-based generalized Büchi automata
internally, it will normally use the transition-based flavor of that
format, indicated with a 't' flag after the number of acceptance sets.
For instance:
.PP
.in +4n
.ft C
.nf
% ltl2tgba --lbtt 'GFp0 & GFp1 & FGp2'
2 2t                   // 2 states, 2 transition-based acceptance sets
0 1                    // state 0: initial
0 -1 t                 //   trans. to state 0, no acc., label: true
1 -1 | & p0 p2 & p1 p2 //   trans. to state 1, no acc., label: (p0&p2)|(p1&p2)
-1                     // end of state 0
1 0                    // state 1: not initial
1 0 1 -1 & & p0 p1 p2  //   trans. to state 1, acc. 0 and 1, label: p0&p1&p2
1 0 -1 & & p1 p2 ! p0  //   trans. to state 1, acc. 0, label: !p0&p1&p2
1 1 -1 & & p0 p2 ! p1  //   trans. to state 1, acc. 1, label: p0&!p1&p2
1 -1 & & p2 ! p0 ! p1  //   trans. to state 1, no acc., label: !p0&!p1&p2
-1                     // end if state 1
.fi
.PP
Here, the two acceptance sets are represented by the numbers 0 and 1,
and they each contain two transitions (the first transition of state 1
belongs to both sets).
.PP
When both \fB\-\-ba\fR and \fB\-\-lbtt\fR options are used,
the state-based flavor of
the format is used instead.  Note that the LBTT format supports
generalized acceptance conditions on states, but Spot only use this
format for Büchi automata, where there is always only one acceptance
set.  Unlike in the LBTT documentation, we do not use the
optional '\fBs\fR' flag to indicate the state-based acceptance, this way our
output is also compatible with that of
.UR http://www.tcs.hut.fi/Software/maria/tools/lbt/
LBT
.UE .
.PP
.in +4n
.ft C
.nf
% ltl2tgba --ba --lbtt FGp0
2 1                 // 2 states, 1 (state-based) accepance set
0 1 -1              // state 0: initial, non-accepting
0 t                 //   trans. to state 0, label: true
1 p0                //   trans. to state 1, label: p0
-1                  // end of state 0
1 0 0 -1            // state 1: not initial, in acceptance set 0
1 p0                //   trans. to state 0, label: p0
-1                  // end if state 1
.fi
.PP
You can force ltl2tgba to use the transition-based flavor of the
format even for Büchi automaton using \fB\-\-lbtt=t\fR.
.PP
.in +4n
.ft C
.nf
% ltl2tgba --ba --lbtt=t FGp0
2 1t                // 2 states, 1 transition-based accepance set.
0 1                 // state 0: initial
0 -1 t              //   trans. to state 0, no acc., label: true
1 -1 p0             //   trans. to state 1, no acc., label: p0
-1                  // end of state 0
1 0                 // state 1: not initial
1 0 -1 p0           //   trans. to state 1, acc. 0, label: p0
-1                  // end if state 1
.fi
.PP
When representing a Büchi automaton using transition-based acceptance,
all transitions leaving accepting states are put into the acceptance set.
.PP
A final note concerns the name of the atomic propositions.  The
original LBTT and LBT formats require these atomic propositions to
have names such as '\fBp0\fR', '\fBp32\fR', ...  We extend the format to accept
atomic proposition with arbitrary names that do not conflict with
LBT's operators (e.g. '\fBi\fR' is the symbol of the implication operator so
it may not be used as an atomic proposition), or as double-quoted
strings.  Spot will always output atomic-proposition that do not match
\fBp[0-9]+\fR as double-quoted strings.
.PP
.in +4n
.ft C
.nf
% ltl2tgba --lbtt 'GFa & GFb'
1 2t
0 1
0 0 1 -1 & "a" "b"
0 0 -1 & "b" ! "a"
0 1 -1 & "a" ! "b"
0 -1 & ! "b" ! "a"
-1
.fi
.SH "NOTE ON GENERATING MONITORS"
The monitors generated with option \fB\-M\fR are finite state automata
used to reject finite words that cannot be extended to infinite words
compatible with the supplied formula.  The idea is that the monitor
should progress alongside the system, and can only make decisions
based on the finite prefix read so far.
.PP
Monitors can be seen as Büchi automata in which all recognized runs are
accepting.  As such, the only infinite words they can reject are those
are not recognized, i.e., infinite words that start with a bad prefix.
.PP
Because of this limited expressiveness, a monitor for some given LTL
or PSL formula may accept a larger language than the one specified by
the formula.  For instance a monitor for the LTL formula \f(CWa U b\fR
will reject (for instance) any word starting with \f(CW!a&!b\fR as
there is no way such a word can validate the formula, but it will not
reject a finite prefix repeating only \f(CWa&!b\fR as such a prefix
could be extented in a way that is comptible with \f(CWa U b\fR.
.PP
For more information about monitors, we refer the readers to the
following two papers (the first paper describes the construction of
the second paper in a more concise way):
.TP
\(bu
Deian Tabakov and Moshe Y. Vardi: Optimized Temporal Monitors for SystemC.
Proceedings of RV'10.  LNCS 6418.
.TP
\(bu
Marcelo d'Amorim and Grigoire Roşu: Efficient monitoring of
ω-languages.  Proceedings of CAV'05.  LNCS 3576.
.SH BIBLIOGRAPHY
If you would like to give a reference to this tool in an article,
we suggest you cite one of the following papers:
.TP
\(bu
Alexandre Duret-Lutz: LTL translation improvements in Spot 1.0.
Int. J. on Critical Computer-Based Systems, 5(1/2):31--54, March 2014.
.TP
\(bu
Alexandre Duret-Lutz: Manipulating LTL formulas using Spot 1.0.
Proceedings of ATVA'13.  LNCS 8172.
.TP
\(bu
Tomáš Babiak, Thomas Badie, Alexandre Duret-Lutz, Mojmír Křetínský,
and Jan Strejček: Compositional approach to suspension and other
improvements to LTL translation.  Proceedings of SPIN'13.  LNCS 7976.
.TP
\(bu
Souheib Baarir and Alexandre Duret-Lutz: Mechanizing the minimization
of deterministic generalized Büchi automata.  Proceedings of FORTE'14.
LNCS 8461.
.SH "REPORTING BUGS"
Report bugs to <spot@lrde.epita.fr>.
.SH COPYRIGHT
Copyright \(co 2019  Laboratoire de Recherche et Développement de l'Epita.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.
.br
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
.SH "SEE ALSO"
.BR spot-x (7)
