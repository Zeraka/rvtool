<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-09-27 Fri 20:08 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Explicit vs. on-the-fly: two interfaces for exploring automata</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="root" />
<meta name="description" content="Explanation of the explicit and on-the-fly automata interfaces in Spot"
 />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="spot.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="tut.html"> UP </a>
 |
 <a accesskey="H" href="index.html"> HOME </a>
</div><div id="content">
<h1 class="title">Explicit vs. on-the-fly: two interfaces for exploring automata</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#explicit-interface">The explicit interface</a>
<ul>
<li><a href="#orged23273">How this interface works</a></li>
<li><a href="#org5d95b07">Recursive DFS</a></li>
<li><a href="#org1040ed9">Iterative DFS (two versions)</a></li>
</ul>
</li>
<li><a href="#on-the-fly-interface">The on-the-fly <code>twa</code> interface</a>
<ul>
<li><a href="#org8cf3d34">How this interface works</a></li>
<li><a href="#org82c3ef3">Recursive DFS (v1)</a></li>
<li><a href="#orgb9f4829">Recursive DFS (v2)</a></li>
<li><a href="#org971b014">Iterative DFS</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div class="figure">
<p><object type="image/svg+xml" data="spot2.svg" class="org-svg" id="spotlogo">
Sorry, your browser does not support SVG.</object>
</p>
</div>
<p>
When exploring automata (i.e., following its transition structure),
there are two different interfaces that can be used:
</p>
<ol class="org-ol">
<li>the <b>on-the-fly</b> <code>twa</code> interface, and</li>
<li>the <b>explicit</b> <code>twa_graph</code> interface.</li>
</ol>

<p>
To demonstrate the difference between the two interfaces, we will
write an small depth-first search that prints all states accessible
from the initial state of an automaton.
</p>

<div id="outline-container-org52dd60a" class="outline-2">
<h2 id="explicit-interface"><a id="org52dd60a"></a>The explicit interface</h2>
<div class="outline-text-2" id="text-explicit-interface">
<p>
The explicit interface can only be used on <code>twa_graph</code> objects.  In
this interface, states and edges are referred to by numbers that are
indices into state and edge vectors (the <a href="https://spot.lrde.epita.fr/ipynb/satmin.html"><code>twagraph-internals.ipynb</code></a>
notebook shows these vectors graphically).  This interface is
lightweight, and is the preferred interface for writing most automata
algorithms in Spot.
</p>
</div>

<div id="outline-container-orged23273" class="outline-3">
<h3 id="orged23273">How this interface works</h3>
<div class="outline-text-3" id="text-orged23273">
<p>
The picture below gives a partial view of the classes involved:
</p>


<div class="figure">
<p><object type="image/svg+xml" data="uml-explicit-classes.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>


<p>
An ω-automaton can be defined as a labeled directed graph, plus an
initial state and an acceptance condition.  The <code>twa_graph</code> of Spot
stores exactly these three components: the transition structure is
stored as an instance of <code>digraph</code> (directed graph), the initial state
is just a number, and the acceptance condition is an instance of
<code>acc_cond</code> which is actually inherited from the <code>twa</code> parent.  You can
ignore the <code>twa</code> inheritance for now, we will discuss it when we talk
about <a href="#on-the-fly-interface">the on-the-fly interface in the next section</a>.
</p>

<p>
In this section we are discussing the "explicit interface", which is a
way of exploring the stored graph directly.
</p>

<p>
The <code>digraph</code> template class in Spot is parameterized by classes
representing additional data to store on state, and on edges.  In the
case of a <code>twa_graph</code>, these extra data are implemented as
<code>twa_graph_state</code> (but we won't be concerned about this type) and
<code>twa_graph_edge_data</code>.  The class <code>twa_graph_edge_data</code> has two
fields: <code>cond</code> is a BDD representing the label of the edge, and
<code>acc</code> represents the acceptance sets to which the edge belong.
</p>

<p>
The <code>digraph</code> stores a vector of states, and a vector of edges, but
both states and edges need to be equipped with field necessary to
represent the graph structure.  In particular, a state holds two edges
numbers representing the first (<code>succ</code>) and last (<code>succ_tail</code>) edges
exiting the state (that "last edge" is only useful to append new
transitions, it is not used for iteration), and each edge has three
additional fields: <code>src</code> (the source state), <code>dst</code> (the destination
state), and <code>next_succ</code> (the index of the next edge leaving <code>src</code>, in
the edge vector).  By way of template inheritance, these
<code>digraph</code>-fields are combined with the <code>twa_graph</code> specific fields, so
that all edges can be represented by an instance of
<code>std::vector&lt;internal::edge_storage&lt;twa_graph_edges_data&gt;&gt;</code>: each
element of this vector acts as a structure with 5 fields; likewise for
the state vector.
</p>

<p>
Calling <code>get_init_state_number()</code> will return a state number which is
just an index into the state vector of the underlying graph.
</p>

<p>
From a state number <code>s</code>, it is possible to iterate over all successors
by doing a <code>for</code> loop on <code>out(s)</code>, as in:
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;spot/twa/twagraph.hh&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;spot/tl/parse.hh&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;spot/twaalgos/translate.hh&gt;</span>

<span class="org-type">void</span> <span class="org-function-name">example</span>(<span class="org-constant">spot</span>::<span class="org-type">const_twa_graph_ptr</span> <span class="org-variable-name">aut</span>)
{
  <span class="org-type">unsigned</span> <span class="org-variable-name">s</span> = aut-&gt;get_init_state_number();
  <span class="org-keyword">for</span> (<span class="org-keyword">auto</span>&amp; <span class="org-variable-name">e</span>: aut-&gt;out(s))
    <span class="org-constant">std</span>::cout &lt;&lt; e.src &lt;&lt; <span class="org-string">"-&gt;"</span> &lt;&lt; e.dst &lt;&lt; <span class="org-string">'\n'</span>;
}

<span class="org-type">int</span> <span class="org-function-name">main</span>()
{
  <span class="org-comment-delimiter">// </span><span class="org-comment">Create a small example automaton</span>
  <span class="org-constant">spot</span>::<span class="org-type">parsed_formula</span> <span class="org-variable-name">pf</span> = <span class="org-constant">spot</span>::parse_infix_psl(<span class="org-string">"FGa | FGb"</span>);
  <span class="org-keyword">if</span> (pf.format_errors(<span class="org-constant">std</span>::cerr))
    <span class="org-keyword">return</span> 1;
  example(<span class="org-constant">spot</span>::translator().run(pf.f));
}
</pre>
</div>

<pre class="example">
0-&gt;0
0-&gt;1
0-&gt;2

</pre>

<p>
In the above lines, <code>aut-&gt;out(s)</code> delegates to
<code>aut-&gt;get_graphs().out(s)</code> and returns a <code>state_out&lt;graph_t&gt;</code>
instance, which is a small temporary object masquerading as an STL
container with <code>begin()</code> and <code>end()</code> methods.  The ranged-for loop
syntax of C++ works exactly as if we had typed
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">You could write this, but why not let the compiler do it for you?</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">In any case, do not spell out the types of tmp and i, as those</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">should be considered internal details.</span>
<span class="org-type">void</span> <span class="org-function-name">example</span>(<span class="org-constant">spot</span>::<span class="org-type">const_twa_graph_ptr</span> <span class="org-variable-name">aut</span>)
{
  <span class="org-type">unsigned</span> <span class="org-variable-name">s</span> = aut-&gt;get_init_state_number();
  <span class="org-keyword">auto</span> <span class="org-variable-name">tmp</span> = aut-&gt;get_graph().out(s);
  <span class="org-keyword">for</span> (<span class="org-keyword">auto</span> <span class="org-variable-name">i</span> = tmp.begin(), <span class="org-variable-name">end</span> = tmp.end(); i != end; ++i)
    <span class="org-constant">std</span>::cout &lt;&lt; i-&gt;src &lt;&lt; <span class="org-string">"-&gt;"</span> &lt;&lt; i-&gt;dst &lt;&lt; <span class="org-string">'\n'</span>;
}
</pre>
</div>

<p>
In the above <code>example()</code> function, the iterators <code>i</code> and <code>end</code> are
instances of the <code>internal::edge_iterator&lt;spot::twa_graph::graph_t&gt;</code>
class, which redefines enough operators to act like an STL Foward
Iterator over all outgoing edges of <code>s</code>.  Note that the <code>tmp</code> and <code>i</code>
objects hold a pointer to the graph, but it does not really matter
because the compiler will optimize this away.
</p>

<p>
In fact after operators are inlined and useless temporary variables
removed, the above loop compiles to something equivalent to this:
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">You could also write this lower-level version, and that sometimes</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">helps (e.g., if you want to pause the loop and then resume it, as</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">we will do later).</span>
<span class="org-type">void</span> <span class="org-function-name">example</span>(<span class="org-constant">spot</span>::<span class="org-type">const_twa_graph_ptr</span> <span class="org-variable-name">aut</span>)
{
  <span class="org-type">unsigned</span> <span class="org-variable-name">s</span> = aut-&gt;get_init_state_number();
  <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">g</span> = aut-&gt;get_graph();
  <span class="org-type">unsigned</span> <span class="org-variable-name">b</span> = g.state_storage(s).succ; <span class="org-comment-delimiter">// </span><span class="org-comment">first edge of state s</span>
  <span class="org-keyword">while</span> (b)
    {
      <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">e</span> = g.edge_storage(b);
      <span class="org-constant">std</span>::cout &lt;&lt; e.src &lt;&lt; <span class="org-string">"-&gt;"</span> &lt;&lt; e.dst &lt;&lt; <span class="org-string">'\n'</span>;
      b = e.next_succ;
    }
}
</pre>
</div>

<p>
Note that <code>next_succ==0</code> marks the last edge in a successor group;
this is why edge numbers start at 1.
</p>

<p>
Despite the various levels of abstractions, these three loops compile
to exactly the same machine code.
</p>
</div>
</div>

<div id="outline-container-org5d95b07" class="outline-3">
<h3 id="org5d95b07">Recursive DFS</h3>
<div class="outline-text-3" id="text-org5d95b07">
<p>
Let us write a DFS using this interface.  A recursive version is easy:
we call <code>dfs_rec()</code> from the initial state, that function updates a
vector of visited states in order to not visit them twice, and recurse
on all successors of the given state.
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;spot/twa/twagraph.hh&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;spot/tl/parse.hh&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;spot/twaalgos/translate.hh&gt;</span>

<span class="org-type">void</span> <span class="org-function-name">dfs_rec</span>(<span class="org-constant">spot</span>::<span class="org-type">const_twa_graph_ptr</span> <span class="org-variable-name">aut</span>, <span class="org-type">unsigned</span> <span class="org-variable-name">state</span>, <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">bool</span>&gt;&amp; <span class="org-variable-name">seen</span>)
{
  seen[state] = <span class="org-constant">true</span>;
  <span class="org-keyword">for</span> (<span class="org-keyword">auto</span>&amp; <span class="org-variable-name">e</span>: aut-&gt;out(state))
    {
       <span class="org-constant">std</span>::cout &lt;&lt; e.src &lt;&lt; <span class="org-string">"-&gt;"</span> &lt;&lt; e.dst &lt;&lt; <span class="org-string">'\n'</span>;
       <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>seen[e.dst])
         dfs_rec(aut, e.dst, seen);
    }
}

<span class="org-type">void</span> <span class="org-function-name">dfs</span>(<span class="org-constant">spot</span>::<span class="org-type">const_twa_graph_ptr</span> <span class="org-variable-name">aut</span>)
{
  <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">bool</span>&gt; <span class="org-variable-name">seen</span>(aut-&gt;num_states());
  dfs_rec(aut, aut-&gt;get_init_state_number(), seen);
}

<span class="org-type">int</span> <span class="org-function-name">main</span>()
{
  <span class="org-comment-delimiter">// </span><span class="org-comment">Create a small example automaton</span>
  <span class="org-constant">spot</span>::<span class="org-type">parsed_formula</span> <span class="org-variable-name">pf</span> = <span class="org-constant">spot</span>::parse_infix_psl(<span class="org-string">"FGa | FGb"</span>);
  <span class="org-keyword">if</span> (pf.format_errors(<span class="org-constant">std</span>::cerr))
    <span class="org-keyword">return</span> 1;
  dfs(<span class="org-constant">spot</span>::translator().run(pf.f));
}
</pre>
</div>

<pre class="example">
0-&gt;0
0-&gt;1
1-&gt;1
0-&gt;2
2-&gt;2

</pre>
</div>
</div>

<div id="outline-container-org1040ed9" class="outline-3">
<h3 id="org1040ed9">Iterative DFS (two versions)</h3>
<div class="outline-text-3" id="text-org1040ed9">
<p>
Recursive graph algorithms are usually avoided, especially if large
graphs should be processed.
</p>

<p>
By maintaining a stack of states to process, we can visit all
accessible transitions in a "DFS-ish" way, but without producing
exactly the same output as above.
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stack&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;spot/twa/twagraph.hh&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;spot/tl/parse.hh&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;spot/twaalgos/translate.hh&gt;</span>

<span class="org-type">void</span> <span class="org-function-name">almost_dfs</span>(<span class="org-constant">spot</span>::<span class="org-type">const_twa_graph_ptr</span> <span class="org-variable-name">aut</span>)
{
  <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">bool</span>&gt; <span class="org-variable-name">seen</span>(aut-&gt;num_states());
  <span class="org-constant">std</span>::<span class="org-type">stack</span>&lt;<span class="org-type">unsigned</span>&gt; <span class="org-variable-name">todo</span>;
  <span class="org-keyword">auto</span> <span class="org-variable-name">push_state</span> = [&amp;](<span class="org-type">unsigned</span> <span class="org-variable-name">state</span>)
    {
      todo.push(state);
      seen[state] = <span class="org-constant">true</span>;
    };
  push_state(aut-&gt;get_init_state_number());
  <span class="org-keyword">while</span> (<span class="org-negation-char">!</span>todo.empty())
    {
      <span class="org-type">unsigned</span> <span class="org-variable-name">s</span> = todo.top();
      todo.pop();
      <span class="org-keyword">for</span> (<span class="org-keyword">auto</span>&amp; <span class="org-variable-name">e</span>: aut-&gt;out(s))
        {
           <span class="org-constant">std</span>::cout &lt;&lt; e.src &lt;&lt; <span class="org-string">"-&gt;"</span> &lt;&lt; e.dst &lt;&lt; <span class="org-string">'\n'</span>;
           <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>seen[e.dst])
             push_state(e.dst);
        }
    }
}

<span class="org-type">int</span> <span class="org-function-name">main</span>()
{
  <span class="org-comment-delimiter">// </span><span class="org-comment">Create a small example automaton</span>
  <span class="org-constant">spot</span>::<span class="org-type">parsed_formula</span> <span class="org-variable-name">pf</span> = <span class="org-constant">spot</span>::parse_infix_psl(<span class="org-string">"FGa | FGb"</span>);
  <span class="org-keyword">if</span> (pf.format_errors(<span class="org-constant">std</span>::cerr))
    <span class="org-keyword">return</span> 1;
  almost_dfs(<span class="org-constant">spot</span>::translator().run(pf.f));
}
</pre>
</div>

<pre class="example">
0-&gt;0
0-&gt;1
0-&gt;2
2-&gt;2
1-&gt;1

</pre>

<p>
So this still prints all accessible edges, but not in the same order
as our recursive DFS.  This is because this version prints all the
outgoing edges of one state before processing the successors.
</p>

<p>
For many algorithms, this different ordering makes no difference, and
this order should even be preferred: groups of transitions leaving
the same state are usually stored consecutively in memory, so they
are better processed in chain, rather than trying to follow exactly
the order we would get from a recursive DFS, which will jump at
random places in the edge vector.
</p>

<p>
In fact writing the iterative equivalent of the recursive <code>dfs()</code> is
a bit challenging if we do not want to be wasteful.  Clearly, we
can no longer use the ranged-for loop, because we need to process
one edge, save the current iterator on a stack to process the
successor, and finally advance the iterator once we pop back to it.
</p>

<p>
Given the above data structure, it is tempting to use a
<code>std::stack&lt;spot::internal::edge_iterator&lt;spot::twa_graph::graph_t&gt;&gt;</code>,
but that is a bad idea.  Remember that those <code>internal::edge_iterator</code>
are meant to be short-lived temporary objects, and they all store a
pointer to graph.  We do not want to store multiple copies of this
pointer on our stack.  Besides, <b>you</b> do not want to ever write
<code>spot::internal</code> in your code.
</p>

<p>
So a better implementation (better than the
<code>std::stack&lt;spot::internal::edge_iterator&lt;...&gt;&gt;</code> suggestion) would be
to maintain a stack of edge numbers.  Indeed, each edge
stores the number of the next edge leaving the same source
state, so this is enough to remember where we are.
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stack&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;spot/twa/twagraph.hh&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;spot/tl/parse.hh&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;spot/twaalgos/translate.hh&gt;</span>

<span class="org-type">void</span> <span class="org-function-name">dfs</span>(<span class="org-constant">spot</span>::<span class="org-type">const_twa_graph_ptr</span> <span class="org-variable-name">aut</span>)
{
  <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">bool</span>&gt; <span class="org-variable-name">seen</span>(aut-&gt;num_states());
  <span class="org-constant">std</span>::<span class="org-type">stack</span>&lt;<span class="org-type">unsigned</span>&gt; <span class="org-variable-name">todo</span>;    <span class="org-comment-delimiter">// </span><span class="org-comment">Now storing edges numbers</span>
  <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">gr</span> = aut-&gt;get_graph();
  <span class="org-keyword">auto</span> <span class="org-variable-name">push_state</span> = [&amp;](<span class="org-type">unsigned</span> <span class="org-variable-name">state</span>)
    {
      todo.push(gr.state_storage(state).succ);
      seen[state] = <span class="org-constant">true</span>;
    };
  push_state(aut-&gt;get_init_state_number());
  <span class="org-keyword">while</span> (<span class="org-negation-char">!</span>todo.empty())
    {
      <span class="org-type">unsigned</span> <span class="org-variable-name">edge</span> = todo.top();
      todo.pop();
      <span class="org-keyword">if</span> (edge == 0U)           <span class="org-comment-delimiter">// </span><span class="org-comment">No more outgoing edge</span>
        <span class="org-keyword">continue</span>;
      <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">e</span> = gr.edge_storage(edge);
      todo.push(e.next_succ); <span class="org-comment-delimiter">// </span><span class="org-comment">Prepare next sibling edge.</span>
      <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>seen[e.dst])
         push_state(e.dst);
      <span class="org-constant">std</span>::cout &lt;&lt; e.src &lt;&lt; <span class="org-string">"-&gt;"</span> &lt;&lt; e.dst &lt;&lt; <span class="org-string">'\n'</span>;
    }
}

<span class="org-type">int</span> <span class="org-function-name">main</span>()
{
  <span class="org-comment-delimiter">// </span><span class="org-comment">Create a small example automaton</span>
  <span class="org-constant">spot</span>::<span class="org-type">parsed_formula</span> <span class="org-variable-name">pf</span> = <span class="org-constant">spot</span>::parse_infix_psl(<span class="org-string">"FGa | FGb"</span>);
  <span class="org-keyword">if</span> (pf.format_errors(<span class="org-constant">std</span>::cerr))
    <span class="org-keyword">return</span> 1;
  dfs(<span class="org-constant">spot</span>::translator().run(pf.f));
}
</pre>
</div>

<pre class="example">
0-&gt;0
0-&gt;1
1-&gt;1
0-&gt;2
2-&gt;2

</pre>

<p>
This version is functionally equivalent to the recursive one, but its
implementation requires more knowledge of the graph data structure
than both the recursive and the <code>almost_dfs()</code> version.
</p>
</div>
</div>
</div>

<div id="outline-container-org4a8a8a1" class="outline-2">
<h2 id="on-the-fly-interface"><a id="org4a8a8a1"></a>The on-the-fly <code>twa</code> interface</h2>
<div class="outline-text-2" id="text-on-the-fly-interface">
<p>
The <code>twa</code> class defines an abstract interface suitable for on-the-fly
exploration of an automaton.  Subclasses of <code>twa</code> need not represent
the entire automaton in memory; if they prefer, they can compute it as
it is explored.
</p>

<p>
Naturally <code>twa_graph</code>, even if it stores the automaton graph
explicitly, is a subclasse of <code>twa</code>, so it also implements the
on-the-fly interface but without computing anything.
</p>
</div>

<div id="outline-container-org8cf3d34" class="outline-3">
<h3 id="org8cf3d34">How this interface works</h3>
<div class="outline-text-3" id="text-org8cf3d34">
<p>
The following class diagram has two classes in common with the
previous one: <code>twa</code> and <code>twa_graph</code>, but this time the focus is on the
abstract interface defined in <code>twa</code>, not in the explicit interface
defined in <code>twa_graph</code>.
</p>


<div class="figure">
<p><object type="image/svg+xml" data="uml-otf-classes.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>


<p>
To explore a <code>twa</code>, one would first call <code>twa::get_init_state()</code>,
which returns a pointer to a <code>state</code>.  Then, calling
<code>twa::succ_iter()</code> on this <code>state</code> will return a <code>twa_succ_iterator</code>
that allows iterating over all successors.
</p>

<p>
Different subclasses of <code>twa</code> will instantiate different subclasses of
<code>state</code> and <code>twa_succ_iterator</code> .  In the case of <code>twa_graph</code>, the
subclasses used are <code>twa_graph_succ_iterator</code> and <code>twa_graph_state</code>,
but you can ignore that until you have to write your own <code>twa</code>
subclass.
</p>

<p>
The interface puts few requirement on memory management: we want to be
able to write automata that can forget about their states (and
recompute them), so there is no guarantee that reaching the same state
twice will return the same pointer twice.  Even calling
<code>get_init_state()</code> twice could return two different pointers.  The
only way to decide whether two <code>state*</code> <code>s1</code> and <code>s2</code> represent the
same state is to check that <code>s1-&gt;compare(s2) == 0</code>.
</p>

<p>
As far as memory management goes, there are roughly two types of <code>twa</code>
subclasses: those that always create new <code>state</code> instances, and those
that reuse <code>state</code> instances (either because they have a cache, or
because, as in the case of <code>twa_graph</code>, they know the entire graph).
</p>

<p>
From the user's perspective, <code>state</code> should never be passed to
<code>delete</code> (their protected destructor will prevent that).  Instead, we
should call <code>state::destroy()</code>.  Doing so allows each subclass to
override the default behavior of <code>destroy()</code> (which is to call
<code>delete</code>).  States can be cloned using the <code>state::clone()</code> method, in
which case each copy has to be destroyed.
</p>

<p>
<code>twa_succ_iterator</code> instances are allocated and should be deleted once
done, but to save some work, they can also be returned to the
automaton with <code>twa::release_iter</code>.  By default, this method stores the
last iterator received to recycle it in the next call to <code>succ_iter()</code>,
saving a <code>delete</code> and <code>new</code> pair.
</p>

<p>
To summarize, here is a crude loop over the successors of the initial
state:
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;spot/twa/twa.hh&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;spot/tl/parse.hh&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;spot/twaalgos/translate.hh&gt;</span>

<span class="org-type">void</span> <span class="org-function-name">example</span>(<span class="org-constant">spot</span>::<span class="org-type">const_twa_ptr</span> <span class="org-variable-name">aut</span>)
{
  <span class="org-keyword">const</span> <span class="org-constant">spot</span>::<span class="org-type">state</span>* <span class="org-variable-name">s</span> = aut-&gt;get_init_state();
  <span class="org-constant">spot</span>::<span class="org-type">twa_succ_iterator</span>* <span class="org-variable-name">i</span> = aut-&gt;succ_iter(s);
  <span class="org-keyword">for</span> (i-&gt;first(); <span class="org-negation-char">!</span>i-&gt;done(); i-&gt;next())
    {
       <span class="org-keyword">const</span> <span class="org-constant">spot</span>::<span class="org-type">state</span>* <span class="org-variable-name">dst</span> = i-&gt;dst();
       <span class="org-constant">std</span>::cout &lt;&lt; aut-&gt;format_state(s) &lt;&lt; <span class="org-string">"-&gt;"</span>
                 &lt;&lt; aut-&gt;format_state(dst) &lt;&lt; <span class="org-string">'\n'</span>;
       dst-&gt;destroy();
    }
  aut-&gt;release_iter(i); <span class="org-comment-delimiter">// </span><span class="org-comment">"delete i;" is OK too, but inferior</span>
  s-&gt;destroy();
}

<span class="org-type">int</span> <span class="org-function-name">main</span>()
{
  <span class="org-comment-delimiter">// </span><span class="org-comment">Create a small example automaton</span>
  <span class="org-constant">spot</span>::<span class="org-type">parsed_formula</span> <span class="org-variable-name">pf</span> = <span class="org-constant">spot</span>::parse_infix_psl(<span class="org-string">"FGa | FGb"</span>);
  <span class="org-keyword">if</span> (pf.format_errors(<span class="org-constant">std</span>::cerr))
    <span class="org-keyword">return</span> 1;
  example(<span class="org-constant">spot</span>::translator().run(pf.f));
}
</pre>
</div>

<pre class="example">
0-&gt;0
0-&gt;1
0-&gt;2

</pre>

<p>
Notice that a <code>twa_succ_iterator</code> allows iterating over outgoing
edges, but only offers access to <code>dst()</code>, <code>acc()</code>, and <code>cond()</code> for
this edge.  The source state is not available from the iterator.  This
is usually not a problem: since the iterator was created from this
state, it is <i>usually</i> known.
</p>

<p>
Let us improve the above loop.  In the previous example, each of
<code>first()</code>, <code>done()</code>, <code>next()</code> is a virtual method call.  So if there
are \(n\) successors, there will be \(1\) call to <code>first()</code>, \(n\) calls to
<code>next()</code>, and \(n+1\) calls to <code>done()</code>, so a total of \(2n+2\) virtual
method calls.
</p>

<p>
However <code>first()</code> and <code>next()</code> also return a Boolean stating whether
the loop could continue.  This allows rewriting the above code as
follows:
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">void</span> <span class="org-function-name">example</span>(<span class="org-constant">spot</span>::<span class="org-type">const_twa_ptr</span> <span class="org-variable-name">aut</span>)
{
  <span class="org-keyword">const</span> <span class="org-constant">spot</span>::<span class="org-type">state</span>* <span class="org-variable-name">s</span> = aut-&gt;get_init_state();
  <span class="org-constant">spot</span>::<span class="org-type">twa_succ_iterator</span>* <span class="org-variable-name">i</span> = aut-&gt;succ_iter(s);
  <span class="org-keyword">if</span> (i-&gt;first())
    <span class="org-keyword">do</span>
      {
         <span class="org-keyword">const</span> <span class="org-constant">spot</span>::<span class="org-type">state</span>* <span class="org-variable-name">dst</span> = i-&gt;dst();
         <span class="org-constant">std</span>::cout &lt;&lt; aut-&gt;format_state(s) &lt;&lt; <span class="org-string">"-&gt;"</span>
                   &lt;&lt; aut-&gt;format_state(dst) &lt;&lt; <span class="org-string">'\n'</span>;
         dst-&gt;destroy();
      }
    <span class="org-keyword">while</span>(i-&gt;next());
  aut-&gt;release_iter(i);
  s-&gt;destroy();
}
</pre>
</div>

<p>
Now we have only \(1\) call to <code>first()</code> and \(n\) calls to <code>next()</code>,
so we halved to number of virtual calls.
</p>

<p>
Using C++11's ranged <code>for</code> loop, this example can be reduced to the
following equivalent code:
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;spot/twa/twa.hh&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;spot/tl/parse.hh&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;spot/twaalgos/translate.hh&gt;</span>

<span class="org-type">void</span> <span class="org-function-name">example</span>(<span class="org-constant">spot</span>::<span class="org-type">const_twa_ptr</span> <span class="org-variable-name">aut</span>)
{
  <span class="org-keyword">const</span> <span class="org-constant">spot</span>::<span class="org-type">state</span>* <span class="org-variable-name">s</span> = aut-&gt;get_init_state();
  <span class="org-keyword">for</span> (<span class="org-keyword">auto</span> <span class="org-variable-name">i</span>: aut-&gt;succ(s))
    {
       <span class="org-keyword">const</span> <span class="org-constant">spot</span>::<span class="org-type">state</span>* <span class="org-variable-name">dst</span> = i-&gt;dst();
       <span class="org-constant">std</span>::cout &lt;&lt; aut-&gt;format_state(s) &lt;&lt; <span class="org-string">"-&gt;"</span>
                 &lt;&lt; aut-&gt;format_state(dst) &lt;&lt; <span class="org-string">'\n'</span>;
       dst-&gt;destroy();
    }
  s-&gt;destroy();
}

<span class="org-type">int</span> <span class="org-function-name">main</span>()
{
  <span class="org-comment-delimiter">// </span><span class="org-comment">Create a small example automaton</span>
  <span class="org-constant">spot</span>::<span class="org-type">parsed_formula</span> <span class="org-variable-name">pf</span> = <span class="org-constant">spot</span>::parse_infix_psl(<span class="org-string">"FGa | FGb"</span>);
  <span class="org-keyword">if</span> (pf.format_errors(<span class="org-constant">std</span>::cerr))
    <span class="org-keyword">return</span> 1;
  example(<span class="org-constant">spot</span>::translator().run(pf.f));
}
</pre>
</div>

<pre class="example">
0-&gt;0
0-&gt;1
0-&gt;2

</pre>

<p>
This works in a similar way as <code>out(s)</code> in the explicit interface.
Calling <code>aut-&gt;succ(s)</code> creates a fake container
(<code>internal::succ_iterable</code>) with <code>begin()</code> and <code>end()</code> methods that
return STL-like iterators (<code>internal::succ_iterator</code>).  Incrementing
the <code>internal::succ_iterator</code> will actually increment the
<code>twa_succ_iterator</code> they hold.  Upon completion of the loop, the
temporary <code>internal::succ_iterable</code> is destroyed and its destructor
passes the iterator back to <code>aut-&gt;release_iter()</code> for recycling.
</p>
</div>
</div>

<div id="outline-container-org82c3ef3" class="outline-3">
<h3 id="org82c3ef3">Recursive DFS (v1)</h3>
<div class="outline-text-3" id="text-org82c3ef3">
<p>
We can now write a recursive DFS easily.  The only pain is to keep
track of the states to <code>destroy()</code> them only after we do not need them
anymore.  This tracking can be done using the data structure we use to
remember what states we have already seen.
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;unordered_set&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;spot/twa/twa.hh&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;spot/tl/parse.hh&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;spot/twa/twaproduct.hh&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;spot/twaalgos/translate.hh&gt;</span>

<span class="org-keyword">typedef</span> <span class="org-constant">std</span>::<span class="org-type">unordered_set</span>&lt;<span class="org-keyword">const</span> <span class="org-constant">spot</span>::<span class="org-type">state</span>*,
                           <span class="org-constant">spot</span>::state_ptr_hash,
                           <span class="org-constant">spot</span>::state_ptr_equal&gt; <span class="org-type">seen_t</span>;

<span class="org-type">void</span> <span class="org-function-name">dfs_rec</span>(<span class="org-constant">spot</span>::<span class="org-type">const_twa_ptr</span> <span class="org-variable-name">aut</span>, <span class="org-keyword">const</span> <span class="org-constant">spot</span>::<span class="org-type">state</span>* <span class="org-variable-name">s</span>, <span class="org-type">seen_t</span>&amp; <span class="org-variable-name">seen</span>)
{
  <span class="org-keyword">if</span> (seen.insert(s).second == <span class="org-constant">false</span>)
    {
      s-&gt;destroy();
      <span class="org-keyword">return</span>;
    }
  <span class="org-keyword">for</span> (<span class="org-keyword">auto</span> <span class="org-variable-name">i</span>: aut-&gt;succ(s))
    {
       <span class="org-keyword">const</span> <span class="org-constant">spot</span>::<span class="org-type">state</span>* <span class="org-variable-name">dst</span> = i-&gt;dst();
       <span class="org-constant">std</span>::cout &lt;&lt; aut-&gt;format_state(s) &lt;&lt; <span class="org-string">"-&gt;"</span>
                 &lt;&lt; aut-&gt;format_state(dst) &lt;&lt; <span class="org-string">'\n'</span>;
       dfs_rec(aut, dst, seen);
       <span class="org-comment-delimiter">// </span><span class="org-comment">Do not destroy dst, as it is either destroyed by dfs_rec()</span>
       <span class="org-comment-delimiter">// </span><span class="org-comment">or stored in seen.</span>
    }
}

<span class="org-type">void</span> <span class="org-function-name">dfs</span>(<span class="org-constant">spot</span>::<span class="org-type">const_twa_ptr</span> <span class="org-variable-name">aut</span>)
{
  <span class="org-type">seen_t</span> <span class="org-variable-name">seen</span>;
  dfs_rec(aut, aut-&gt;get_init_state(), seen);

  <span class="org-comment-delimiter">// </span><span class="org-comment">Do not forget to destroy all states in seen.</span>
  <span class="org-keyword">for</span> (<span class="org-keyword">auto</span> <span class="org-variable-name">s</span>: seen)
    s-&gt;destroy();
}

<span class="org-type">int</span> <span class="org-function-name">main</span>()
{
  <span class="org-comment-delimiter">// </span><span class="org-comment">Create a small example automaton</span>
  <span class="org-constant">spot</span>::<span class="org-type">parsed_formula</span> <span class="org-variable-name">pf</span> = <span class="org-constant">spot</span>::parse_infix_psl(<span class="org-string">"FGa | FGb"</span>);
  <span class="org-keyword">if</span> (pf.format_errors(<span class="org-constant">std</span>::cerr))
    <span class="org-keyword">return</span> 1;
  dfs(<span class="org-constant">spot</span>::translator().run(pf.f));
}
</pre>
</div>

<pre class="example">
0-&gt;0
0-&gt;1
1-&gt;1
0-&gt;2
2-&gt;2

</pre>
</div>
</div>

<div id="outline-container-orgb9f4829" class="outline-3">
<h3 id="orgb9f4829">Recursive DFS (v2)</h3>
<div class="outline-text-3" id="text-orgb9f4829">
<p>
Using a hash map to keep a unique pointer to each state is quite
common.  The class <code>spot::state_unicity_table</code> can be used for this
purpose.  <code>spot::state_unicity_table::operator()</code> inputs a <code>state*</code>,
and returns either the same state, or the first equal state seen
previously (in that case the passed state is destroyed).  The
<code>spot::state_unicity_table::is_new()</code> behaves similarly, but returns
<code>nullptr</code> for states that already exist.
</p>

<p>
With this class, the recursive code can be simplified down to this:
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;spot/twa/twa.hh&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;spot/tl/parse.hh&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;spot/twa/twaproduct.hh&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;spot/twaalgos/translate.hh&gt;</span>

<span class="org-type">void</span> <span class="org-function-name">dfs_rec</span>(<span class="org-constant">spot</span>::<span class="org-type">const_twa_ptr</span> <span class="org-variable-name">aut</span>, <span class="org-keyword">const</span> <span class="org-constant">spot</span>::<span class="org-type">state</span>* <span class="org-variable-name">s</span>,
             <span class="org-constant">spot</span>::<span class="org-type">state_unicity_table</span>&amp; <span class="org-variable-name">seen</span>)
{
  <span class="org-keyword">if</span> (seen.is_new(s))
    <span class="org-keyword">for</span> (<span class="org-keyword">auto</span> <span class="org-variable-name">i</span>: aut-&gt;succ(s))
      {
        <span class="org-keyword">const</span> <span class="org-constant">spot</span>::<span class="org-type">state</span>* <span class="org-variable-name">dst</span> = i-&gt;dst();
        <span class="org-constant">std</span>::cout &lt;&lt; aut-&gt;format_state(s) &lt;&lt; <span class="org-string">"-&gt;"</span>
                  &lt;&lt; aut-&gt;format_state(dst) &lt;&lt; <span class="org-string">'\n'</span>;
        dfs_rec(aut, dst, seen);
      }
}

<span class="org-type">void</span> <span class="org-function-name">dfs</span>(<span class="org-constant">spot</span>::<span class="org-type">const_twa_ptr</span> <span class="org-variable-name">aut</span>)
{
  <span class="org-constant">spot</span>::<span class="org-type">state_unicity_table</span> <span class="org-variable-name">seen</span>;
  dfs_rec(aut, aut-&gt;get_init_state(), seen);
}

<span class="org-type">int</span> <span class="org-function-name">main</span>()
{
  <span class="org-comment-delimiter">// </span><span class="org-comment">Create a small example automaton</span>
  <span class="org-constant">spot</span>::<span class="org-type">parsed_formula</span> <span class="org-variable-name">pf</span> = <span class="org-constant">spot</span>::parse_infix_psl(<span class="org-string">"FGa | FGb"</span>);
  <span class="org-keyword">if</span> (pf.format_errors(<span class="org-constant">std</span>::cerr))
    <span class="org-keyword">return</span> 1;
  dfs(<span class="org-constant">spot</span>::translator().run(pf.f));
}
</pre>
</div>

<pre class="example">
0-&gt;0
0-&gt;1
1-&gt;1
0-&gt;2
2-&gt;2

</pre>

<p>
Note how this completely hides all the calls to <code>state::destroy()</code>.
They are performed in <code>state_unicity_table::is_new()</code> and in
<code>state_unicity_table::~state_unicity_table()</code>.
</p>
</div>
</div>

<div id="outline-container-org971b014" class="outline-3">
<h3 id="org971b014">Iterative DFS</h3>
<div class="outline-text-3" id="text-org971b014">
<p>
For a non-recursive version, let us use a stack of
<code>twa_succ_iterator</code>.  However these iterators do not know their
source, so we better store that in the stack as well if we want to
print it.
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stack&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;spot/twa/twa.hh&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;spot/tl/parse.hh&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;spot/twa/twaproduct.hh&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;spot/twaalgos/translate.hh&gt;</span>

<span class="org-type">void</span> <span class="org-function-name">dfs</span>(<span class="org-constant">spot</span>::<span class="org-type">const_twa_ptr</span> <span class="org-variable-name">aut</span>)
{
  <span class="org-constant">spot</span>::<span class="org-type">state_unicity_table</span> <span class="org-variable-name">seen</span>;
  <span class="org-constant">std</span>::<span class="org-type">stack</span>&lt;<span class="org-constant">std</span>::<span class="org-type">pair</span>&lt;<span class="org-keyword">const</span> <span class="org-constant">spot</span>::<span class="org-type">state</span>*,
                       <span class="org-constant">spot</span>::<span class="org-type">twa_succ_iterator</span>*&gt;&gt; <span class="org-variable-name">todo</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">push receives a newly-allocated state and immediately store it in</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">seen.  Therefore any state on todo is already in seen and does</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">not need to be destroyed.</span>
  <span class="org-keyword">auto</span> <span class="org-variable-name">push</span> = [&amp;](<span class="org-keyword">const</span> <span class="org-constant">spot</span>::<span class="org-type">state</span>* <span class="org-variable-name">s</span>)
    {
       <span class="org-keyword">if</span> (seen.is_new(s))
         {
           <span class="org-constant">spot</span>::<span class="org-type">twa_succ_iterator</span>* <span class="org-variable-name">it</span> = aut-&gt;succ_iter(s);
           <span class="org-keyword">if</span> (it-&gt;first())
             todo.emplace(s, it);
           <span class="org-keyword">else</span>                 <span class="org-comment-delimiter">// </span><span class="org-comment">No successor for s</span>
             aut-&gt;release_iter(it);
         }
    };
  push(aut-&gt;get_init_state());
  <span class="org-keyword">while</span> (<span class="org-negation-char">!</span>todo.empty())
    {
       <span class="org-keyword">const</span> <span class="org-constant">spot</span>::<span class="org-type">state</span>* <span class="org-variable-name">src</span> = todo.top().first;
       <span class="org-constant">spot</span>::<span class="org-type">twa_succ_iterator</span>* <span class="org-variable-name">srcit</span> = todo.top().second;
       <span class="org-keyword">const</span> <span class="org-constant">spot</span>::<span class="org-type">state</span>* <span class="org-variable-name">dst</span> = srcit-&gt;dst();
       <span class="org-constant">std</span>::cout &lt;&lt; aut-&gt;format_state(src) &lt;&lt; <span class="org-string">"-&gt;"</span>
                 &lt;&lt; aut-&gt;format_state(dst) &lt;&lt; <span class="org-string">'\n'</span>;
       <span class="org-comment-delimiter">// </span><span class="org-comment">Advance the iterator, and maybe release it.</span>
       <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>srcit-&gt;next())
         {
            aut-&gt;release_iter(srcit);
            todo.pop();
         }
       push(dst);
    }
}

<span class="org-type">int</span> <span class="org-function-name">main</span>()
{
  <span class="org-comment-delimiter">// </span><span class="org-comment">Create a small example automaton</span>
  <span class="org-constant">spot</span>::<span class="org-type">parsed_formula</span> <span class="org-variable-name">pf</span> = <span class="org-constant">spot</span>::parse_infix_psl(<span class="org-string">"FGa | FGb"</span>);
  <span class="org-keyword">if</span> (pf.format_errors(<span class="org-constant">std</span>::cerr))
    <span class="org-keyword">return</span> 1;
  dfs(<span class="org-constant">spot</span>::translator().run(pf.f));
}
</pre>
</div>

<pre class="example">
0-&gt;0
0-&gt;1
1-&gt;1
0-&gt;2
2-&gt;2

</pre>
</div>
</div>
</div>
</div>
</body>
</html>
