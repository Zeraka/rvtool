<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Fri Sep 27 20:04:28 2019 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>AUTFILT</title>

 <LINK REL="stylesheet" TYPE="text/css" HREF="../spot.css">
 <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body class="man"><div id="org-div-home-and-up"><a accesskey="h" href="../tools.html"> UP </a>| <a accesskey="H" href="../index.html"> HOME </a></div>

<h1 align="center">AUTFILT</h1>

<div id="table-of-contents"><h2>Table of Contents</h2><div id="text-table-of-contents"><ul>
<li><a href="#NAME">NAME</a></li>
<li><a href="#SYNOPSIS">SYNOPSIS</a></li>
<li><a href="#DESCRIPTION">DESCRIPTION</a></li>
<li><a href="#OPTIONS FOR SAT-MINIMIZATION">OPTIONS FOR SAT-MINIMIZATION</a></li>
<li><a href="#BIBLIOGRAPHY">BIBLIOGRAPHY</a></li>
<li><a href="#REPORTING BUGS">REPORTING BUGS</a></li>
<li><a href="#COPYRIGHT">COPYRIGHT</a></li>
<li><a href="#SEE ALSO">SEE ALSO</a></li>
</ul></div></div>


<div class="outline-2"><h2>NAME
<a name="NAME"></a>
</h2></div>


<p style="margin-left:11%; margin-top: 1em">autfilt -
filter, convert, and transform omega-automata</p>

<div class="outline-2"><h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2></div>


<p style="margin-left:11%; margin-top: 1em"><b>autfilt</b>
[<i>OPTION</i>...] [<i>FILENAME</i>[<i>/COL</i>]...]</p>

<div class="outline-2"><h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2></div>


<p style="margin-left:11%; margin-top: 1em">Convert,
transform, and filter omega-automata.</p>

<h3 style="margin-left:11%">Input:</h3><p style="margin-left:11%"><b>
-F</b>, <b>--file</b>=<i>FILENAME</i></p>

<p style="margin-left:22%;">process the automaton in
FILENAME</p>


<p style="margin-left:11%;"><b>--trust-hoa</b>=<i>BOOL</i></p>

<p style="margin-left:22%;">If False, properties listed in
HOA files are ignored, unless they can be easily verified.
If True (the default) any supported property is trusted.</p>

<h3 style="margin-left:11%">Output
automaton type:</h3><p style="margin-left:11%"><b>
-B</b>, <b>--ba</b></p>

<p style="margin-left:22%;">B&uuml;chi Automaton (with
state-based acceptance)</p>

<p style="margin-left:11%;"><b>--cobuchi</b>,
<b>--coBuchi</b></p>

<p style="margin-left:22%;">automaton with co-B&uuml;chi
acceptance (will recognize a superset of the input language
if not co-B&uuml;chi realizable)</p>

<p style="margin-left:11%;"><b>-C</b>,
<b>--complete</b></p>

<p style="margin-left:22%;">output a complete automaton</p>

<p style="margin-left:11%;"><b>-G</b>, <b>--generic</b></p>

<p style="margin-left:22%;">any acceptance is allowed
(default)</p>

<p style="margin-left:11%;"><b>-M</b>, <b>--monitor</b></p>

<p style="margin-left:22%;">Monitor (accepts all finite
prefixes of the given property)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>-p</b>,
<b>--colored-parity</b>[=<i>any</i>|<i>min</i>|<i>max</i>|<i>odd</i>|<i>even</i>|<i>min</i>
odd|min even|max odd|max</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em">even]</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">colored
automaton with parity acceptance</p>

<p style="margin-left:11%;"><b>-P</b>,
<b>--parity</b>[=<i>any</i>|<i>min</i>|<i>max</i>|<i>odd</i>|<i>even</i>|<i>min</i>
odd|min even|max odd|max even]</p>

<p style="margin-left:22%;">automaton with parity
acceptance</p>

<p style="margin-left:11%;"><b>-S</b>,
<b>--state-based-acceptance</b>, <b>--sbacc</b></p>

<p style="margin-left:22%;">define the acceptance using
states</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>--tgba</b></p></td>
<td width="2%"></td>
<td width="67%">


<p>Transition-based Generalized B&uuml;chi Automaton</p></td>
<td width="11%">
</td></tr>
</table>

<h3 style="margin-left:11%">Output
format:</h3><p style="margin-left:11%"><b>
-8</b>, <b>--utf8</b></p>

<p style="margin-left:22%;">enable UTF-8 characters in
output (ignored with <b>--lbtt</b> or <b>--spin</b>)</p>

<p style="margin-left:11%;"><b>-c</b>, <b>--count</b></p>

<p style="margin-left:22%;">print only a count of matched
automata</p>


<p style="margin-left:11%;"><b>--check</b>[=<i>PROP</i>]</p>

<p style="margin-left:22%;">test for the additional
property PROP and output the result in the HOA format
(implies <b>-H</b>). PROP may be any prefix of
&rsquo;all&rsquo; (default), &rsquo;unambiguous&rsquo;,
&rsquo;stutter-invariant&rsquo;, or
&rsquo;strength&rsquo;.</p>

<p style="margin-left:11%;"><b>-d</b>, <b><br>

--dot</b>[=<i>1</i>|<i>a</i>|<i>A</i>|<i>b</i>|<i>B</i>|<i>c</i>|<i>C(COLOR)</i>|<i>e</i>|<i>f(FONT)</i>|<i>h</i>|<i>k</i>|<i>K</i>|<i>n</i>|<i>N</i>|<i>o</i>|<i>r</i>|<i>R</i>|<i>s</i>|<i>t</i>|<i>u</i>|<i>v</i>|<i>y</i>|<i>+INT</i>|<i>&lt;INT</i>|<i>#</i>]</p>

<p style="margin-left:22%;">GraphViz&rsquo;s format. Add
letters for (1) force numbered states, (a) show acceptance
condition (default), (A) hide acceptance condition, (b)
acceptance sets as bullets, (B) bullets except for
B&uuml;chi/co-B&uuml;chi automata, (c) force circular nodes,
(C) color nodes with COLOR, (d) show origins when known, (e)
force elliptic nodes, (f(FONT)) use FONT, (g) hide edge
labels, (h) horizontal layout, (k) use state labels when
possible, (K) use transition labels (default), (n) show
name, (N) hide name, (o) ordered transitions, (r) rainbow
colors for acceptance sets, (R) color acceptance sets by
Inf/Fin, (s) with SCCs, (t) force transition-based
acceptance, (u) hide true states, (v) vertical layout, (y)
split universal edges by color, (+INT) add INT to all set
numbers, (&lt;INT) display at most INT states, (#) show
internal edge numbers</p>

<p style="margin-left:11%;"><b>-H</b>,
<b>--hoaf</b>[=<i>1.1</i>|<i>i</i>|<i>k</i>|<i>l</i>|<i>m</i>|<i>s</i>|<i>t</i>|<i>v</i>]</p>

<p style="margin-left:22%;">Output the automaton in HOA
format (default). Add letters to select (1.1) version 1.1 of
the format, (i) use implicit labels for complete
deterministic automata, (s) prefer state-based acceptance
when possible [default], (t) force transition-based
acceptance, (m) mix state and transition-based acceptance,
(k) use state labels when possible, (l) single-line output,
(v) verbose properties</p>

<p style="margin-left:11%;"><b>--lbtt</b>[=<i>t</i>]</p>

<p style="margin-left:22%;">LBTT&rsquo;s format (add =t to
force transition-based acceptance even on B&uuml;chi
automata)</p>

<p style="margin-left:11%;"><b>-n</b>,
<b>--max-count</b>=<i>NUM</i></p>

<p style="margin-left:22%;">output at most NUM automata</p>


<p style="margin-left:11%;"><b>--name</b>=<i>FORMAT</i></p>

<p style="margin-left:22%;">set the name of the output
automaton</p>

<p style="margin-left:11%;"><b>-o</b>,
<b>--output</b>=<i>FORMAT</i></p>

<p style="margin-left:22%;">send output to a file named
FORMAT instead of standard output. The first automaton sent
to a file truncates it unless FORMAT starts with
&rsquo;&gt;&gt;&rsquo;.</p>

<p style="margin-left:11%;"><b>-q</b>, <b>--quiet</b></p>

<p style="margin-left:22%;">suppress all normal output</p>

<p style="margin-left:11%;"><b>-s</b>,
<b>--spin</b>[=<i>6</i>|<i>c</i>]</p>

<p style="margin-left:22%;">Spin neverclaim (implies
<b>--ba</b>). Add letters to select (6) Spin&rsquo;s 6.2.4
style, (c) comments on states</p>

<p style="margin-left:11%;"><b>--stats</b>=<i>FORMAT</i>,
<b>--format</b>=<i>FORMAT</i></p>

<p style="margin-left:22%;">output statistics about the
automaton</p>

<p style="margin-left:11%; margin-top: 1em">Any FORMAT
string may use the following interpreted sequences (capitals
for input, minuscules for output):</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>%%</p></td>
<td width="2%"></td>
<td width="78%">


<p>a single %</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>%&lt;</p></td>
<td width="2%"></td>
<td width="78%">


<p>the part of the line before the automaton if it comes
from a column extracted from a CSV file</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>%&gt;</p></td>
<td width="2%"></td>
<td width="78%">


<p>the part of the line after the automaton if it comes
from a column extracted from a CSV file</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>%A, %a</p></td>
<td width="2%"></td>
<td width="78%">


<p>number of acceptance sets</p></td></tr>
</table>

<p style="margin-left:11%;">%C, %c, %[LETTERS]C,
%[LETTERS]c</p>

<p style="margin-left:22%;">number of SCCs; you may filter
the SCCs to count using the following LETTERS, possibly
concatenated: (a) accepting, (r) rejecting, (c) complete,
(v) trivial, (t) terminal, (w) weak, (iw) inherently weak.
Use uppercase letters to negate them.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>%D, %d</p></td>
<td width="2%"></td>
<td width="73%">


<p>1 if the automaton is deterministic, 0 otherwise</p></td>
<td width="5%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>%E, %e</p></td>
<td width="2%"></td>
<td width="73%">


<p>number of reachable edges</p></td>
<td width="5%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>%F</p></td>
<td width="2%"></td>
<td width="73%">


<p>name of the input file</p></td>
<td width="5%">
</td></tr>
</table>

<p style="margin-left:11%;">%G, %g, %[LETTERS]G,
%[LETTERS]g</p>

<p style="margin-left:22%;">acceptance condition (in HOA
syntax); add brackets to print an acceptance name instead
and LETTERS to tweak the format: (0) no parameters, (a)
accentuated, (b) abbreviated, (d) style used in dot output,
(g) no generalized parameter, (l) recognize Street-like and
Rabin-like, (m) no main parameter, (p) no parity parameter,
(o) name unknown acceptance as &rsquo;other&rsquo;, (s)
shorthand for &rsquo;lo0&rsquo;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>%H, %h</p></td>
<td width="2%"></td>
<td width="78%">


<p>the automaton in HOA format on a single line (use
%[opt]H or %[opt]h to specify additional options as in
<b>--hoa</b>=<i>opt)</i></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>%L</p></td>
<td width="2%"></td>
<td width="78%">


<p>location in the input file</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>%M, %m</p></td>
<td width="2%"></td>
<td width="78%">


<p>name of the automaton</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>%N, %n</p></td>
<td width="2%"></td>
<td width="78%">


<p>number of nondeterministic states</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>%P, %p</p></td>
<td width="2%"></td>
<td width="78%">


<p>1 if the automaton is complete, 0 otherwise</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>%r</p></td>
<td width="2%"></td>
<td width="78%">


<p>wall-clock time elapsed in seconds (excluding
parsing)</p> </td></tr>
</table>

<p style="margin-left:11%;">%R, %[LETTERS]R</p>

<p style="margin-left:22%;">CPU time (excluding parsing),
in seconds; Add LETTERS to restrict to(u) user time, (s)
system time, (p) parent process, or (c) children
processes.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>%S, %s</p></td>
<td width="2%"></td>
<td width="47%">


<p>number of reachable states</p></td>
<td width="31%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>%T, %t</p></td>
<td width="2%"></td>
<td width="47%">


<p>number of reachable transitions</p></td>
<td width="31%">
</td></tr>
</table>

<p style="margin-left:11%;">%U, %u, %[LETTER]U,
%[LETTER]u</p>

<p style="margin-left:22%;">1 if the automaton contains
some universal</p>

<p style="margin-left:11%;">branching (or a number of
[s]tates or [e]dges with</p>

<p style="margin-left:22%;">universal branching)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>%W, %w</p></td>
<td width="2%"></td>
<td width="52%">


<p>one word accepted by the automaton</p></td>
<td width="26%">
</td></tr>
</table>

<p style="margin-left:11%;">%X, %x, %[LETTERS]X,
%[LETTERS]x</p>

<p style="margin-left:22%;">number of atomic propositions
declared in the automaton; add LETTERS to list atomic
propositions with (n) no quoting, (s) occasional
double-quotes with C-style escape, (d) double-quotes with
C-style escape, (c) double-quotes with CSV-style escape, (p)
between parentheses, any extra non-alphanumeric character
will be used to separate propositions</p>

<h3 style="margin-left:11%">Filtering
options:</h3><p style="margin-left:11%"><b>
--acc-sccs</b>=<i>RANGE</i>,
<b>--accepting-sccs</b>=<i>RANGE</i></p>

<p style="margin-left:22%;">keep automata whose number of
non-trivial accepting SCCs is in RANGE</p>


<p style="margin-left:11%;"><b>--acc-sets</b>=<i>RANGE</i></p>

<p style="margin-left:22%;">keep automata whose number of
acceptance sets is in RANGE</p>


<p style="margin-left:11%;"><b>--accept-word</b>=<i>WORD</i></p>

<p style="margin-left:22%;">keep automata that accept
WORD</p>


<p style="margin-left:11%;"><b>--acceptance-is</b>=<i>NAME</i>|<i>FORMULA</i></p>

<p style="margin-left:22%;">match automata with given
accetance condition</p>

<p style="margin-left:11%;"><b>--ap</b>=<i>RANGE</i></p>

<p style="margin-left:22%;">match automata with a number of
(declared) atomic propositions in RANGE</p>


<p style="margin-left:11%;"><b>--are-isomorphic</b>=<i>FILENAME</i></p>

<p style="margin-left:22%;">keep automata that are
isomorphic to the automaton in FILENAME</p>


<p style="margin-left:11%;"><b>--edges</b>=<i>RANGE</i></p>

<p style="margin-left:22%;">keep automata whose number of
edges is in RANGE</p>


<p style="margin-left:11%;"><b>--equivalent-to</b>=<i>FILENAME</i></p>

<p style="margin-left:22%;">keep automata that are
equivalent (language-wise) to the automaton in FILENAME</p>


<p style="margin-left:11%;"><b>--has-exist-branching</b></p>

<p style="margin-left:22%;">keep automata that use
existential branching (i.e., make non-deterministic
choices)</p>


<p style="margin-left:11%;"><b>--has-univ-branching</b></p>

<p style="margin-left:22%;">keep alternating automata that
use universal branching</p>


<p style="margin-left:11%;"><b>--included-in</b>=<i>FILENAME</i>
keep automata whose languages are included in <br>
that</p>

<p style="margin-left:22%;">of the automaton from
FILENAME</p>


<p style="margin-left:11%;"><b>--inherently-weak-sccs</b>=<i>RANGE</i></p>

<p style="margin-left:22%;">keep automata whose number of
accepting inherently-weak SCCs is in RANGE. An accepting SCC
is inherently weak if it does not have a rejecting
cycle.</p>


<p style="margin-left:11%;"><b>--intersect</b>=<i>FILENAME</i></p>

<p style="margin-left:22%;">keep automata whose languages
have an non-empty intersection with the automaton from
FILENAME</p>

<p style="margin-left:11%;"><b>--is-alternating</b></p>

<p style="margin-left:22%;">keep only automata using
universal branching</p>

<p style="margin-left:11%;"><b>--is-colored</b></p>

<p style="margin-left:22%;">keep colored automata (i.e.,
exactly one acceptance mark per transition or state)</p>

<p style="margin-left:11%;"><b>--is-complete</b></p>

<p style="margin-left:22%;">keep complete automata</p>

<p style="margin-left:11%;"><b>--is-deterministic</b></p>

<p style="margin-left:22%;">keep deterministic automata</p>

<p style="margin-left:11%;"><b>--is-empty</b></p>

<p style="margin-left:22%;">keep automata with an empty
language</p>


<p style="margin-left:11%;"><b>--is-inherently-weak</b></p>

<p style="margin-left:22%;">keep only inherently weak
automata</p>


<p style="margin-left:11%;"><b>--is-semi-deterministic</b></p>

<p style="margin-left:22%;">keep semi-deterministic
automata</p>

<p style="margin-left:11%;"><b>--is-stutter-invariant</b>
keep automata representing stutter-invariant</p>

<p style="margin-left:22%;">properties</p>

<p style="margin-left:11%;"><b>--is-terminal</b></p>

<p style="margin-left:22%;">keep only terminal automata</p>

<p style="margin-left:11%;"><b>--is-unambiguous</b></p>

<p style="margin-left:22%;">keep only unambiguous
automata</p>

<p style="margin-left:11%;"><b>--is-very-weak</b></p>

<p style="margin-left:22%;">keep only very-weak
automata</p>

<p style="margin-left:11%;"><b>--is-weak</b></p>

<p style="margin-left:22%;">keep only weak automata</p>


<p style="margin-left:11%;"><b>--nondet-states</b>=<i>RANGE</i></p>

<p style="margin-left:22%;">keep automata whose number of
nondeterministic states is in RANGE</p>


<p style="margin-left:11%;"><b>--rej-sccs</b>=<i>RANGE</i>,
<b>--rejecting-sccs</b>=<i>RANGE</i></p>

<p style="margin-left:22%;">keep automata whose number of
non-trivial rejecting SCCs is in RANGE</p>


<p style="margin-left:11%;"><b>--reject-word</b>=<i>WORD</i></p>

<p style="margin-left:22%;">keep automata that reject
WORD</p>

<p style="margin-left:11%;"><b>--sccs</b>=<i>RANGE</i></p>

<p style="margin-left:22%;">keep automata whose number of
SCCs is in RANGE</p>


<p style="margin-left:11%;"><b>--states</b>=<i>RANGE</i></p>

<p style="margin-left:22%;">keep automata whose number of
states is in RANGE</p>


<p style="margin-left:11%;"><b>--terminal-sccs</b>=<i>RANGE</i></p>

<p style="margin-left:22%;">keep automata whose number of
accepting terminal SCCs is in RANGE. Terminal SCCs are weak
and complete.</p>


<p style="margin-left:11%;"><b>--triv-sccs</b>=<i>RANGE</i>,
<b>--trivial-sccs</b>=<i>RANGE</i></p>

<p style="margin-left:22%;">keep automata whose number of
trivial SCCs is in RANGE</p>


<p style="margin-left:11%;"><b>--unused-ap</b>=<i>RANGE</i></p>

<p style="margin-left:22%;">match automata with a number of
declared, but unused atomic propositions in RANGE</p>


<p style="margin-left:11%;"><b>--used-ap</b>=<i>RANGE</i></p>

<p style="margin-left:22%;">match automata with a number of
used atomic propositions in RANGE</p>

<p style="margin-left:11%;"><b>-u</b>, <b>--unique</b></p>

<p style="margin-left:22%;">do not output the same
automaton twice (same in the sense that they are
isomorphic)</p>

<p style="margin-left:11%;"><b>-v</b>,
<b>--invert-match</b></p>

<p style="margin-left:22%;">select non-matching
automata</p>


<p style="margin-left:11%;"><b>--weak-sccs</b>=<i>RANGE</i></p>

<p style="margin-left:22%;">keep automata whose number of
accepting weak SCCs is in RANGE. In a weak SCC, all
transitions belong to the same acceptance sets.</p>

<p style="margin-left:11%; margin-top: 1em">RANGE may have
one of the following forms: &rsquo;INT&rsquo;,
&rsquo;INT..INT&rsquo;, &rsquo;..INT&rsquo;, or
&rsquo;INT..&rsquo;</p>

<p style="margin-left:11%; margin-top: 1em">WORD is
lasso-shaped and written as
&rsquo;BF;BF;...;BF;cycle{BF;...;BF}&rsquo; where BF are
arbitrary Boolean formulas. The &rsquo;cycle{...}&rsquo;
part is mandatory, but the prefix can be omitted.</p>


<h3 style="margin-left:11%">Transformations:</h3><p style="margin-left:11%"><b>
--cleanup-acceptance</b></p>

<p style="margin-left:22%;">remove unused acceptance sets
from the automaton</p>

<p style="margin-left:11%;"><b>--cnf-acceptance</b></p>

<p style="margin-left:22%;">put the acceptance condition in
Conjunctive Normal Form</p>

<p style="margin-left:11%;"><b>--complement</b></p>

<p style="margin-left:22%;">complement each automaton
(different strategies are used)</p>


<p style="margin-left:11%;"><b>--complement-acceptance</b></p>

<p style="margin-left:22%;">complement the acceptance
condition (without touching the automaton)</p>


<p style="margin-left:11%;"><b>--decompose-scc</b>=<i>t</i>|<i>w</i>|<i>s</i>|<i>N</i>|<i>aN</i>,
<b>--decompose-strength</b>=<i>t</i>|<i>w</i>|<i>s</i>|<i>N</i>|<i>aN</i></p>

<p style="margin-left:22%;">extract the (t) terminal, (w)
weak, or (s) strong part of an automaton or (N) the
subautomaton leading to the Nth SCC, or (aN) to the Nth
accepting SCC (option can be combined with commas to extract
multiple parts)</p>

<p style="margin-left:11%;"><b>--destut</b></p>

<p style="margin-left:22%;">allow less stuttering</p>

<p style="margin-left:11%;"><b>--dnf-acceptance</b></p>

<p style="margin-left:22%;">put the acceptance condition in
Disjunctive Normal Form</p>

<p style="margin-left:11%;"><b>--dualize</b></p>

<p style="margin-left:22%;">dualize each automaton</p>


<p style="margin-left:11%;"><b>--exclusive-ap</b>=<i>AP</i>,AP,...</p>

<p style="margin-left:22%;">if any of those APs occur in
the automaton, restrict all edges to ensure two of them may
not be true at the same time. Use this option multiple times
to declare independent groups of exclusive propositions.</p>


<p style="margin-left:11%;"><b>--generalized-rabin</b>[=<i>unique-inf</i>|<i>share-inf</i>],
<b><br>
--gra</b>[=<i>unique-inf</i>|<i>share-inf</i>]</p>

<p style="margin-left:22%;">rewrite the acceptance
condition as generalized Rabin; the default
&quot;unique-inf&quot; option uses the generalized Rabin
definition from the HOA format; the &quot;share-inf&quot;
option allows clauses to share Inf sets, therefore reducing
the number of sets</p>


<p style="margin-left:11%;"><b>--generalized-streett</b>[=<i>unique-fin</i>|<i>share-fin</i>],
<b><br>
--gsa</b>[=<i>unique-fin</i>|<i>share-fin</i>]</p>

<p style="margin-left:22%;">rewrite the acceptance
condition as generalized Streett; the &quot;share-fin&quot;
option allows clauses to share Fin sets, therefore reducing
the number of sets; the default &quot;unique-fin&quot; does
not</p>


<p style="margin-left:11%;"><b>--instut</b>[=<i>1</i>|<i>2</i>]</p>

<p style="margin-left:22%;">allow more stuttering (two
possible algorithms)</p>


<p style="margin-left:11%;"><b>--keep-states</b>=<i>NUM</i>[,NUM...]</p>

<p style="margin-left:22%;">only keep specified states. The
first state will be the new initial state. Implies
<b>--remove-unreachable-states</b>.</p>


<p style="margin-left:11%;"><b>--mask-acc</b>=<i>NUM</i>[,NUM...]</p>

<p style="margin-left:22%;">remove all transitions in
specified acceptance sets</p>

<p style="margin-left:11%;"><b>--merge-transitions</b></p>

<p style="margin-left:22%;">merge transitions with same
destination and acceptance</p>


<p style="margin-left:11%;"><b>--product</b>=<i>FILENAME</i>,
<b>--product-and</b>=<i>FILENAME</i></p>

<p style="margin-left:22%;">build the product with the
automaton in FILENAME to intersect languages</p>


<p style="margin-left:11%;"><b>--product-or</b>=<i>FILENAME</i></p>

<p style="margin-left:22%;">build the product with the
automaton in FILENAME to sum languages</p>


<p style="margin-left:11%;"><b>--randomize</b>[=<i>s</i>|<i>t</i>]</p>

<p style="margin-left:22%;">randomize states and
transitions (specify &rsquo;s&rsquo; or &rsquo;t&rsquo; to
randomize only states or transitions)</p>


<p style="margin-left:11%;"><b>--remove-ap</b>=<i>AP</i>[<i>=0</i>|<i>=1</i>][,AP...]</p>

<p style="margin-left:22%;">remove atomic propositions
either by existential quantification, or by assigning them 0
or 1</p>


<p style="margin-left:11%;"><b>--remove-dead-states</b></p>

<p style="margin-left:22%;">remove states that are
unreachable, or that cannot belong to an infinite path</p>

<p style="margin-left:11%;"><b>--remove-fin</b></p>

<p style="margin-left:22%;">rewrite the automaton without
using Fin acceptance</p>


<p style="margin-left:11%;"><b>--remove-unreachable-states</b></p>

<p style="margin-left:22%;">remove states that are
unreachable from the initial state</p>

<p style="margin-left:11%;"><b>--remove-unused-ap</b></p>

<p style="margin-left:22%;">remove declared atomic
propositions that are not used</p>


<p style="margin-left:11%;"><b>--sat-minimize</b>[=<i>options</i>]</p>

<p style="margin-left:22%;">minimize the automaton using a
SAT solver (only works for deterministic automata).
Supported options are acc=STRING, states=N, max-states=N,
sat-incr=N, sat-incr-steps=N, sat-langmap, sat-naive,
colored, preproc=N. Spot uses by default its PicoSAT
distribution but an external SATsolver can be set thanks to
the SPOT_SATSOLVER environment variable(see spot-x).</p>

<p style="margin-left:11%;"><b>--separate-sets</b></p>

<p style="margin-left:22%;">if both Inf(x) and Fin(x)
appear in the acceptance condition, replace Fin(x) by a new
Fin(y) and adjust the automaton</p>


<p style="margin-left:11%;"><b>--simplify-acceptance</b></p>

<p style="margin-left:22%;">simplify the acceptance
condition by merging identical acceptance sets and by
simplifying some terms containing complementary sets</p>


<p style="margin-left:11%;"><b>--simplify-exclusive-ap</b></p>

<p style="margin-left:22%;">if <b>--exclusive-ap</b> is
used, assume those AP groups are actually exclusive in the
system to simplify the expression of transition labels
(implies <b>--merge-transitions</b>)</p>

<p style="margin-left:11%;"><b>--split-edges</b></p>

<p style="margin-left:22%;">split edges into transitions
labeled by conjunctions of all atomic propositions, so they
can be read as letters</p>

<p style="margin-left:11%;"><b>--streett-like</b></p>

<p style="margin-left:22%;">convert to an automaton with
Streett-like acceptance. Works only with acceptance
condition in DNF</p>

<p style="margin-left:11%;"><b>--strip-acceptance</b></p>

<p style="margin-left:22%;">remove the acceptance condition
and all acceptance sets</p>

<p style="margin-left:11%;"><b>--sum</b>=<i>FILENAME</i>,
<b>--sum-or</b>=<i>FILENAME</i></p>

<p style="margin-left:22%;">build the sum with the
automaton in FILENAME to sum languages</p>


<p style="margin-left:11%;"><b>--sum-and</b>=<i>FILENAME</i></p>

<p style="margin-left:22%;">build the sum with the
automaton in FILENAME to intersect languages</p>

<h3 style="margin-left:11%">Decorations
(for -d and -H1.1 output):</h3><p style="margin-left:11%"><b>
--highlight-accepting-run</b>[=<i>NUM</i>]</p>

<p style="margin-left:22%;">highlight one accepting run
using color NUM</p>


<p style="margin-left:11%;"><b>--highlight-languages</b></p>

<p style="margin-left:22%;">highlight states that recognize
identical languages</p>


<p style="margin-left:11%;"><b>--highlight-nondet</b>[=<i>NUM</i>]</p>

<p style="margin-left:22%;">highlight nondeterministic
states and edges with color NUM</p>


<p style="margin-left:11%;"><b>--highlight-nondet-edges</b>[=<i>NUM</i>]</p>

<p style="margin-left:22%;">highlight nondeterministic
edges with color NUM</p>


<p style="margin-left:11%;"><b>--highlight-nondet-states</b>[=<i>NUM</i>]</p>

<p style="margin-left:22%;">highlight nondeterministic
states with color NUM</p>


<p style="margin-left:11%;"><b>--highlight-word</b>=[<i>NUM</i>,]WORD</p>

<p style="margin-left:22%;">highlight one run matching WORD
using color NUM</p>


<h3 style="margin-left:11%">Simplification
goal:</h3><p style="margin-left:11%"><b>
-a</b>, <b>--any</b></p>

<p style="margin-left:22%;">no preference, do not bother
making it small or deterministic</p>

<p style="margin-left:11%;"><b>-D</b>,
<b>--deterministic</b></p>

<p style="margin-left:22%;">prefer deterministic automata
(combine with <b>--generic</b> to be sure to obtain a
deterministic automaton)</p>

<p style="margin-left:11%;"><b>--small</b></p>

<p style="margin-left:22%;">prefer small automata</p>


<h3 style="margin-left:11%">Simplification
level:</h3>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>--high</b></p></td>
<td width="2%"></td>
<td width="52%">


<p>all available optimizations (slow)</p></td>
<td width="26%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>--low</b></p></td>
<td width="2%"></td>
<td width="52%">


<p>minimal optimizations (fast)</p></td>
<td width="26%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>--medium</b></p>

<p style="margin-left:22%;">moderate optimizations</p>

<p style="margin-left:11%; margin-top: 1em">If any option
among <b>--small</b>, <b>--deterministic</b>, or
<b>--any</b> is given, then the simplification level
defaults to <b>--high</b> unless specified otherwise. If any
option among <b>--low</b>, <b>--medium</b>, or <b>--high</b>
is given, then the simplification goal defaults to
<b>--small</b> unless specified otherwise. If none of those
options are specified, then autfilt acts as is <b>--any
--low</b> were given: these actually disable the
simplification routines.</p>


<h3 style="margin-left:11%">Miscellaneous
options:</h3><p style="margin-left:11%"><b>
--seed</b>=<i>INT</i></p>

<p style="margin-left:22%;">seed for the random number
generator (0)</p>

<p style="margin-left:11%;"><b>-x</b>,
<b>--extra-options</b>=<i>OPTS</i></p>

<p style="margin-left:22%;">fine-tuning options (see spot-x
(7))</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>--help</b></p></td>
<td width="2%"></td>
<td width="23%">


<p>print this help</p></td>
<td width="55%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>--version</b></p>

<p style="margin-left:22%;">print program version</p>

<p style="margin-left:11%; margin-top: 1em">Mandatory or
optional arguments to long options are also mandatory or
optional for any corresponding short options.</p>

<h3 style="margin-left:11%">Exit
status:</h3>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>0</p></td>
<td width="10%"></td>
<td width="56%">


<p>if some automata were output</p></td>
<td width="22%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>1</p></td>
<td width="10%"></td>
<td width="56%">


<p>if no automata were output (no match)</p></td>
<td width="22%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>2</p></td>
<td width="10%"></td>
<td width="56%">


<p>if any error has been reported</p></td>
<td width="22%">
</td></tr>
</table>

<div class="outline-2"><h2>OPTIONS FOR SAT-MINIMIZATION
<a name="OPTIONS FOR SAT-MINIMIZATION"></a>
</h2></div>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p style="margin-top: 1em">By default, SAT-based
minimization executes a binary search, checking N/2 etc. The
upper bound being N (the size of the starting automaton),
the lower bound is always 1 except when <b>sat-langmap</b>
option is used.</p></td></tr>
</table>


<p style="margin-left:11%;"><b>acc=DOUBLEQUOTEDSTRING</b></p>

<p style="margin-left:22%;">DOUBLEQUOTEDSTRING is an
acceptance formula in the HOA syntax, or a parametrized
acceptance name (the different acc-name: options from
HOA).</p>

<p style="margin-left:11%;"><b>colored</b></p>

<p style="margin-left:22%;">force all transitions (or all
states if <b>-S</b> is used) to belong to exactly one
acceptance condition.</p>

<p style="margin-left:11%;"><b>max-states=M</b></p>

<p style="margin-left:22%;">M is an upper-bound on the
maximum number of states of the constructed automaton.</p>

<p style="margin-left:11%;"><b>sat-incr=M</b></p>

<p style="margin-left:22%;">use an incremental approach for
SAT-based minimization algorithm. M can be either <b>1</b>
or <b>2</b>. They correspond respectively to <b>-x
sat-minimize=2</b> and <b>-x sat-minimize=3</b> options.
They restart the encoding only after
(N-1)-<b>sat-incr-steps</b> states have been won. Each
iterations of both starts by encoding the research of an N-1
automaton, N being the size of the starting automaton.
<b>1</b> uses Picosat assumptions. It additionally assumes
that the last <b>sat-incr-steps</b> states are unnecessary.
On failure, it relax the assumptions to do a binary search
between N-1 and (N-1)-<b>sat-incr-steps</b>.
<b>sat-incr-steps</b> defaults to 6. <b>2</b>, as for it,
after an N-1 state automaton has been found, uses
incremental solving for the next <b>sat-incr-steps</b>
iterations by forbidding the usage of an additional state
without reencoding the problem again. A full encoding occurs
after <b>sat-incr-steps</b> iterations unless
<b>sat-incr-steps=-1</b> (see SPOT_XCNF environment variable
described in spot-x). It defaults to 2.</p>

<p style="margin-left:11%;"><b>sat-incr-steps=M</b></p>

<p style="margin-left:22%;">set the value of
<b>sat-incr-steps</b> to M. This is used by <b>sat-incr</b>
option.</p>

<p style="margin-left:11%;"><b>sat-naive</b></p>

<p style="margin-left:22%;">use the naive algorithm to find
a smaller automaton. It starts from N (N being the size of
the starting automaton) and then checks N-1, N-2, etc. until
the last successful check.</p>

<p style="margin-left:11%;"><b>sat-langmap</b></p>

<p style="margin-left:22%;">Find the lower bound of default
sat-minimize procedure (1). This relies on the fact that the
size of the minimal automaton is at least equal to the total
number of different languages recognized by the
automaton&rsquo;s states.</p>

<p style="margin-left:11%;"><b>states=M</b></p>

<p style="margin-left:22%;">M is a fixed number of states
to use in the result (all the states needs not be accessible
in the result. Therefore, the output might be smaller
nonetheless). The SAT-based procedure is just used once to
synthesize one automaton, and no further minimization is
attempted.</p>

<div class="outline-2"><h2>BIBLIOGRAPHY
<a name="BIBLIOGRAPHY"></a>
</h2></div>


<p style="margin-left:11%; margin-top: 1em">The following
papers are related to some of the transformations
implemented in autfilt.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="88%">


<p>Etienne Renault, Alexandre Duret-Lutz, Fabrice Kordon,
and Denis Poitrenaud: Strength-based decomposition of the
property B&uuml;chi automaton for faster model checking.
Proceedings of TACAS&rsquo;13. LNCS 7795.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">The
<b>--strength-decompose</b> option implements the
definitions given in the above paper.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="88%">


<p style="margin-top: 1em">Franti&scaron;ek Blahoudek,
Alexandre Duret-Lutz, Vojt&#269;ech Rujbr, and Jan
Strej&#269;ek: On refinement of B&uuml;chi automata for
explicit model checking. Proceedings of SPIN&rsquo;15. LNCS
9232.</p> </td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">That paper
gives the motivation for options <b>--exclusive-ap</b> and
<b>--simplify-exclusive-ap</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="88%">


<p style="margin-top: 1em">Thibaud Michaud and Alexandre
Duret-Lutz: Practical stutter-invariance checks for
&omega;-regular languages. Proceedings of SPIN&rsquo;15.
LNCS 9232.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Describes the
algorithms used by the <b>--destut</b> and <b>--instut</b>
options. These options correpond respectively to cl() and
sl() in the paper.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="88%">


<p style="margin-top: 1em">Souheib Baarir and Alexandre
Duret-Lutz: SAT-based minimization of deterministic
&omega;-automata. Proceedings of LPAR&rsquo;15 (a.k.a
LPAR-20). LNCS 9450.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Describes the
<b>--sat-minimize</b> option.</p>

<div class="outline-2"><h2>REPORTING BUGS
<a name="REPORTING BUGS"></a>
</h2></div>


<p style="margin-left:11%; margin-top: 1em">Report bugs to
&lt;<a href="mailto:spot@lrde.epita.fr">spot@lrde.epita.fr</a>&gt;.</p>

<div class="outline-2"><h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2></div>


<p style="margin-left:11%; margin-top: 1em">Copyright
&copy; 2019 Laboratoire de Recherche et D&eacute;veloppement
de l&rsquo;Epita. License GPLv3+: <a href="http://www.gnu.org/licenses/gpl.html">GNU GPL version 3 or later</a>. <br>
This is free software: you are free to change and
redistribute it. There is NO WARRANTY, to the extent
permitted by law.</p>

<div class="outline-2"><h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2></div>



<p style="margin-left:11%; margin-top: 1em"><a href="spot-x.7.html"><b>spot-x</b></a>(7)
<a href="dstar2tgba.1.html"><b>dstar2tgba</b></a>(1)</p>
</body>
</html>
