<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-09-27 Fri 20:05 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title><code>autfilt</code></title>
<meta name="generator" content="Org mode" />
<meta name="author" content="root" />
<meta name="description" content="Spot command-line tool for filtering, tranforming, and converting Ï‰-automata."
 />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="spot.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="tools.html"> UP </a>
 |
 <a accesskey="H" href="index.html"> HOME </a>
</div><div id="content">
<h1 class="title"><code>autfilt</code></h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org96ccf15">Conversion between formats</a></li>
<li><a href="#org5b9fcd6">Displaying statistics</a></li>
<li><a href="#org3e812d7">Filtering automata</a></li>
<li><a href="#orga08e392">Simplifying automata</a>
<ul>
<li><a href="#org56de768">Determinization</a></li>
</ul>
</li>
<li><a href="#org1ee206b">Transformations</a></li>
<li><a href="#orgaa4725f">Decorations</a></li>
<li><a href="#orgc814343">Examples</a>
<ul>
<li><a href="#org3f4a9a6">Acceptance transformations</a></li>
<li><a href="#orgd79c9c9">Atomic proposition removal</a></li>
<li><a href="#orgebbdc6f">Testing word acceptance</a></li>
<li><a href="#org46b713c">Decorations</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div class="figure">
<p><object type="image/svg+xml" data="spot2.svg" class="org-svg" id="spotlogo">
Sorry, your browser does not support SVG.</object>
</p>
</div>
<p>
The <code>autfilt</code> tool can filter, transform, and convert a stream of automata.
</p>

<p>
The tool operates a loop over 5 phases:
</p>
<ul class="org-ul">
<li>input one automaton</li>
<li>optionally preprocess the automaton</li>
<li>optionally filter the automaton (i.e., decide whether to ignore the
automaton or continue with it)</li>
<li>optionally postprocess the automaton (to simply it or change its acceptance)</li>
<li>output the automaton</li>
</ul>

<p>
The simplest way to use the tool is simply to use it for input and
output (i.e., format conversion) without any transformation and
filtering.
</p>

<div id="outline-container-org96ccf15" class="outline-2">
<h2 id="org96ccf15">Conversion between formats</h2>
<div class="outline-text-2" id="text-org96ccf15">
<p>
<code>autfilt</code> can read automata written in the <a href="http://adl.github.io/hoaf/">Hanoi Omega Automata
Format</a>, as <a href="http://spinroot.com/spin/Man/never.html">Spin never claims</a>, using <a href="http://www.tcs.hut.fi/Software/lbtt/doc/html/Format-for-automata.html">LBTT's format</a>, or using
<a href="http://www.ltl2dstar.de/docs/ltl2dstar.html"><code>ltl2dstar</code>'s format</a>.  Automata in those formats (even a mix of those
formats) can be concatenated in the same stream, <code>autfilt</code> will
process them in batch.  (The only restriction is that inside a file an
automaton in LBTT's format may not follow an automaton in
<code>ltl2dstar</code>'s format.)
</p>

<p>
By default the output uses the HOA format.  This can be changed using
<a href="oaut.html">the common output options</a> like <code>--spin</code>, <code>--lbtt</code>, <code>--dot</code>,
<code>--stats</code>&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-sh">cat &gt;example.hoa &lt;&lt;EOF
<span class="org-sh-heredoc">HOA: v1</span>
<span class="org-sh-heredoc">States: 1</span>
<span class="org-sh-heredoc">Start: 0</span>
<span class="org-sh-heredoc">AP: 1 "p0"</span>
<span class="org-sh-heredoc">Acceptance: 1 Inf(0)</span>
<span class="org-sh-heredoc">--BODY--</span>
<span class="org-sh-heredoc">State: 0</span>
<span class="org-sh-heredoc">[0] 0 {0}</span>
<span class="org-sh-heredoc">[!0] 0</span>
<span class="org-sh-heredoc">--END--</span>
<span class="org-sh-heredoc">EOF</span>
autfilt example.hoa --dot
</pre>
</div>

<pre class="example">
digraph "" {
  rankdir=LR
  label=&lt;Inf(&lt;font color="#1F78B4"&gt;â“¿&lt;/font&gt;)&lt;br/&gt;[BÃ¼chi]&gt;
  labelloc="t"
  node [shape="circle"]
  node [style="filled", fillcolor="#ffffa0"]
  fontname="Lato"
  node [fontname="Lato"]
  edge [fontname="Lato"]
  I [label="", style=invis, width=0]
  I -&gt; 0
  0 [label=&lt;0&gt;]
  0 -&gt; 0 [label=&lt;p0&lt;br/&gt;&lt;font color="#1F78B4"&gt;â“¿&lt;/font&gt;&gt;]
  0 -&gt; 0 [label=&lt;!p0&gt;]
}
</pre>

<p>
The <code>--spin</code> option implicitly requires a degeneralization:
</p>

<div class="org-src-container">
<pre class="src src-sh">autfilt example.hoa --spin
</pre>
</div>

<pre class="example">
never {
accept_init:
  if
  :: (p0) -&gt; goto accept_init
  :: (!(p0)) -&gt; goto T0_S1
  fi;
T0_S1:
  if
  :: (p0) -&gt; goto accept_init
  :: (!(p0)) -&gt; goto T0_S1
  fi;
}
</pre>

<p>
Option <code>--lbtt</code> only works for BÃ¼chi or generalized BÃ¼chi acceptance.
</p>

<div class="org-src-container">
<pre class="src src-sh">autfilt example.hoa --lbtt
</pre>
</div>

<pre class="example">
1 1t
0 1
0 0 -1 p0
0 -1 ! p0
-1

</pre>
</div>
</div>

<div id="outline-container-org5b9fcd6" class="outline-2">
<h2 id="org5b9fcd6">Displaying statistics</h2>
<div class="outline-text-2" id="text-org5b9fcd6">
<p>
One special output format of <code>autfilt</code> is the statistic output.  For
instance the following command calls <a href="randaut.html"><code>randaut</code></a> to generate 10 random
automata, and pipe the result into <code>autfilt</code> to display various
statistics.
</p>


<div class="org-src-container">
<pre class="src src-sh">randaut -n 10 -A0..2 -Q10..20 -e0.05 2 |
autfilt --stats=<span class="org-string">'%s states, %e edges, %a acc-sets, %c SCCs, det=%d'</span>
</pre>
</div>

<pre class="example">
16 states, 30 edges, 1 acc-sets, 3 SCCs, det=0
20 states, 42 edges, 2 acc-sets, 1 SCCs, det=0
15 states, 27 edges, 2 acc-sets, 1 SCCs, det=0
10 states, 17 edges, 1 acc-sets, 1 SCCs, det=1
13 states, 25 edges, 1 acc-sets, 1 SCCs, det=0
11 states, 18 edges, 0 acc-sets, 1 SCCs, det=0
19 states, 41 edges, 2 acc-sets, 1 SCCs, det=0
11 states, 18 edges, 0 acc-sets, 1 SCCs, det=0
12 states, 21 edges, 1 acc-sets, 5 SCCs, det=0
18 states, 37 edges, 1 acc-sets, 5 SCCs, det=0
</pre>

<p>
The following <code>%</code> sequences are available:
</p>
<pre class="example">
%&lt;                         the part of the line before the formula if it
                           comes from a column extracted from a CSV file
%&gt;                         the part of the line after the formula if it comes
                           from a column extracted from a CSV file
%%                         a single %
%a                         number of acceptance sets
%c, %[LETTERS]c            number of SCCs; you may filter the SCCs to count
                           using the following LETTERS, possibly
                           concatenated: (a) accepting, (r) rejecting, (c)
                           complete, (v) trivial, (t) terminal, (w) weak,
                           (iw) inherently weak. Use uppercase letters to
                           negate them.
%d                         1 if the output is deterministic, 0 otherwise
%e                         number of reachable edges
%f                         the formula, in Spot's syntax
%F                         name of the input file
%g, %[LETTERS]g            acceptance condition (in HOA syntax); add brackets
                           to print an acceptance name instead and LETTERS to
                           tweak the format: (0) no parameters, (a)
                           accentuated, (b) abbreviated, (d) style used in
                           dot output, (g) no generalized parameter, (l)
                           recognize Street-like and Rabin-like, (m) no main
                           parameter, (p) no parity parameter, (o) name
                           unknown acceptance as 'other', (s) shorthand for
                           'lo0'.
%h                         the automaton in HOA format on a single line (use
                           %[opt]h to specify additional options as in
                           --hoa=opt)
%L                         location in the input file
%m                         name of the automaton
%n                         number of nondeterministic states in output
%p                         1 if the output is complete, 0 otherwise
%r                         wall-clock time elapsed in seconds (excluding
                           parsing)
%R, %[LETTERS]R            CPU time (excluding parsing), in seconds; Add
                           LETTERS to restrict to(u) user time, (s) system
                           time, (p) parent process, or (c) children
                           processes.
%s                         number of reachable states
%t                         number of reachable transitions
%u, %[e]u                  number of states (or [e]dges) with universal
                           branching
%u, %[LETTER]u             1 if the automaton contains some universal
                           branching (or a number of [s]tates or [e]dges with
                           universal branching)
%w                         one word accepted by the output automaton
%x, %[LETTERS]x            number of atomic propositions declared in the
                           automaton;  add LETTERS to list atomic
                           propositions with (n) no quoting, (s) occasional
                           double-quotes with C-style escape, (d)
                           double-quotes with C-style escape, (c)
                           double-quotes with CSV-style escape, (p) between
                           parentheses, any extra non-alphanumeric character
                           will be used to separate propositions
</pre>

<p>
When a letter is available both as uppercase and lowercase, the
uppercase version refer to the input automaton, while the lowercase
refer to the output automaton.  Of course this distinction makes sense
only if <code>autfilt</code> was instructed to perform an operation on the input
automaton.
</p>
</div>
</div>

<div id="outline-container-org3e812d7" class="outline-2">
<h2 id="org3e812d7">Filtering automata</h2>
<div class="outline-text-2" id="text-org3e812d7">
<p>
<code>autfilt</code> offers multiple options to filter automata based on
different characteristics of the automaton.
</p>

<pre class="example">
    --acc-sccs=RANGE, --accepting-sccs=RANGE
                           keep automata whose number of non-trivial
                           accepting SCCs is in RANGE
    --acc-sets=RANGE       keep automata whose number of acceptance sets is
                           in RANGE
    --accept-word=WORD     keep automata that accept WORD
    --acceptance-is=NAME|FORMULA
                           match automata with given accetance condition
    --ap=RANGE             match automata with a number of (declared) atomic
                           propositions in RANGE
    --are-isomorphic=FILENAME   keep automata that are isomorphic to the
                           automaton in FILENAME
    --edges=RANGE          keep automata whose number of edges is in RANGE
    --equivalent-to=FILENAME   keep automata that are equivalent
                           (language-wise) to the automaton in FILENAME
    --has-exist-branching  keep automata that use existential branching
                           (i.e., make non-deterministic choices)
    --has-univ-branching   keep alternating automata that use universal
                           branching
    --included-in=FILENAME keep automata whose languages are included in that
                           of the automaton from FILENAME
    --inherently-weak-sccs=RANGE
                           keep automata whose number of accepting
                           inherently-weak SCCs is in RANGE.  An accepting
                           SCC is inherently weak if it does not have a
                           rejecting cycle.
    --intersect=FILENAME   keep automata whose languages have an non-empty
                           intersection with the automaton from FILENAME
    --is-alternating       keep only automata using universal branching
    --is-colored           keep colored automata (i.e., exactly one
                           acceptance mark per transition or state)
    --is-complete          keep complete automata
    --is-deterministic     keep deterministic automata
    --is-empty             keep automata with an empty language
    --is-inherently-weak   keep only inherently weak automata
    --is-semi-deterministic   keep semi-deterministic automata
    --is-stutter-invariant keep automata representing stutter-invariant
                           properties
    --is-terminal          keep only terminal automata
    --is-unambiguous       keep only unambiguous automata
    --is-very-weak         keep only very-weak automata
    --is-weak              keep only weak automata
    --nondet-states=RANGE  keep automata whose number of nondeterministic
                           states is in RANGE
    --rej-sccs=RANGE, --rejecting-sccs=RANGE
                           keep automata whose number of non-trivial
                           rejecting SCCs is in RANGE
    --reject-word=WORD     keep automata that reject WORD
    --sccs=RANGE           keep automata whose number of SCCs is in RANGE
    --states=RANGE         keep automata whose number of states is in RANGE
    --terminal-sccs=RANGE  keep automata whose number of accepting terminal
                           SCCs is in RANGE.  Terminal SCCs are weak and
                           complete.
    --triv-sccs=RANGE, --trivial-sccs=RANGE
                           keep automata whose number of trivial SCCs is in
                           RANGE
    --unused-ap=RANGE      match automata with a number of declared, but
                           unused atomic propositions in RANGE
    --used-ap=RANGE        match automata with a number of used atomic
                           propositions in RANGE
-u, --unique               do not output the same automaton twice (same in
                           the sense that they are isomorphic)
-v, --invert-match         select non-matching automata
    --weak-sccs=RANGE      keep automata whose number of accepting weak SCCs
                           is in RANGE.  In a weak SCC, all transitions
                           belong to the same acceptance sets.
</pre>

<p>
For instance <code>--states=2..5 --acc-sets=3</code> will <i>keep</i> only automata that
use 3 acceptance sets, and that have between 2 and 5 states.
</p>

<p>
Except for <code>--unique</code>, all these filters can be inverted using option
<code>-v</code>.  Using <code>--states=2..5 --acc-sets=3 -v</code> will <i>drop</i> all automata
that use 3 acceptance sets and that have between 2 and 5 states, and
keep the others.
</p>
</div>
</div>

<div id="outline-container-orga08e392" class="outline-2">
<h2 id="orga08e392">Simplifying automata</h2>
<div class="outline-text-2" id="text-orga08e392">
<p>
The standard set of automata simplification routines (these are often
referred to as the "post-processing" routines, because these are the
procedures performed by <a href="ltl2tgba.html"><code>ltl2tgba</code></a> after translating a formula into a
TGBA) are available through the following options.
</p>

<p>
This set of options controls the desired type of output automaton:
</p>

<pre class="example">
-B, --ba                   BÃ¼chi Automaton (with state-based acceptance)
    --cobuchi, --coBuchi   automaton with co-BÃ¼chi acceptance (will
                           recognize a superset of the input language if not
                           co-BÃ¼chi realizable)
-C, --complete             output a complete automaton
-G, --generic              any acceptance is allowed (default)
-M, --monitor              Monitor (accepts all finite prefixes of the given
                           property)
-p, --colored-parity[=any|min|max|odd|even|min odd|min even|max odd|max
    even]                  colored automaton with parity acceptance
-P, --parity[=any|min|max|odd|even|min odd|min even|max odd|max even]
                           automaton with parity acceptance
-S, --state-based-acceptance, --sbacc
                           define the acceptance using states
    --tgba                 Transition-based Generalized BÃ¼chi Automaton
</pre>

<p>
These options specify any simplification goal:
</p>

<pre class="example">
-a, --any                  no preference, do not bother making it small or
                           deterministic
-D, --deterministic        prefer deterministic automata (combine with
                           --generic to be sure to obtain a deterministic
                           automaton)
    --small                prefer small automata

</pre>

<p>
Finally, the following switches control the amount of effort applied
toward the desired goal:
</p>

<pre class="example">
--high                 all available optimizations (slow)
--low                  minimal optimizations (fast)
--medium               moderate optimizations

</pre>


<p>
By default, <code>--any --low</code> is used, which cause all simplifications to
be skipped.  However if any goal is given, than the simplification level
defaults to <code>--high</code> (unless specified otherwise).  If a simplification
level is given without specifying any goal, then the goal default to <code>--small</code>.
</p>

<p>
So if you want to reduce the size of the automaton, try <code>--small</code> and
if you want to try to make (or keep) it deterministic use
<code>--deterministic</code>.
</p>

<p>
Note that the <code>--deterministic</code> flag has two possible behaviors
depending on the constraints on the acceptance conditions:
</p>
<ul class="org-ul">
<li>When <code>autfilt</code> is configured to work with generic acceptance (the
<code>--generic</code> option, which is the default) or parity acceptance
(using <code>--parity</code> or <code>--colored-parity</code>), then the <code>--deterministic</code>
flag will do whatever it takes to output a deterministic automaton,
and this includes changing the acceptance condition if needed (see
below).</li>
<li>If options <code>--tgba</code> or <code>--ba</code> are used, the <code>--deterministic</code> option
is taken as a <i>preference</i>: <code>autfilt</code> will try to favor determinism
in the output, but it may not always succeed and may output
non-deterministic automata.  Note that if <code>autfilt --deterministic
  --tgba</code> fails to output a deterministic automaton, it does not
necessarily implies that a deterministic TGBA does not exist: it
just implies that <code>autfilt</code> could not find it.</li>
</ul>
</div>


<div id="outline-container-org56de768" class="outline-3">
<h3 id="org56de768">Determinization</h3>
<div class="outline-text-3" id="text-org56de768">
<p>
Spot has basically two ways to determinize automata, and that it uses
when <code>--deterministic</code> is passed.
</p>

<ul class="org-ul">
<li>Automata that express obligation properties (this can be decided),
can be <b>determinized and minimized</b> into weak BÃ¼chi automata, as
discussed by <a href="http://www.daxc.de/eth/paper/atva07.pdf">Dax at al. (ATVA'07)</a>.</li>

<li>BÃ¼chi automata (preferably with transition-based acceptance) can be
determinized into parity automata using a Safra-like procedure close
to the one presented by <a href="http://www.romanredz.se/papers/FI2012.pdf">Redziejowski (Fund. Inform. 119)</a>, with a few
additional tricks.  This procedure does not necessarily produce a
minimal automaton.</li>
</ul>

<p>
When <code>--deterministic</code> is used, the first of these two procedures is
attempted on any supplied automaton.  (It's even attempted for
deterministic automata, because that might reduce them.)
</p>

<p>
If that first procedure failed, and the input automaton is not
deterministic and <code>--generic</code> (the default for <code>autfilt</code>), <code>--parity</code>
or <code>--colorized-parity</code> is used, then the second procedure is used.
In this case, automata will be first converted to transition-based
BÃ¼chi automata if their acceptance condition is more complex.
</p>

<p>
The difference between <code>--parity</code> and <code>--colored-parity</code> parity is
that the latter requests all transitions (or all states when
state-based acceptance is used) to belong to exactly one acceptance
set.
</p>
</div>
</div>
</div>

<div id="outline-container-org1ee206b" class="outline-2">
<h2 id="org1ee206b">Transformations</h2>
<div class="outline-text-2" id="text-org1ee206b">
<p>
The following transformations are available:
</p>

<pre class="example">
--cleanup-acceptance   remove unused acceptance sets from the automaton
--cnf-acceptance       put the acceptance condition in Conjunctive Normal
                       Form
--complement           complement each automaton (different strategies
                       are used)
--complement-acceptance   complement the acceptance condition (without
                       touching the automaton)
--decompose-scc=t|w|s|N|aN, --decompose-strength=t|w|s|N|aN
                       extract the (t) terminal, (w) weak, or (s) strong
                       part of an automaton or (N) the subautomaton
                       leading to the Nth SCC, or (aN) to the Nth
                       accepting SCC (option can be combined with commas
                       to extract multiple parts)
--destut               allow less stuttering
--dnf-acceptance       put the acceptance condition in Disjunctive Normal
                       Form
--dualize              dualize each automaton
--exclusive-ap=AP,AP,...   if any of those APs occur in the automaton,
                       restrict all edges to ensure two of them may not
                       be true at the same time.  Use this option
                       multiple times to declare independent groups of
                       exclusive propositions.
--generalized-rabin[=unique-inf|share-inf], --gra[=unique-inf|share-inf]
                       rewrite the acceptance condition as generalized
                       Rabin; the default "unique-inf" option uses the
                       generalized Rabin definition from the HOA format;
                       the "share-inf" option allows clauses to share Inf
                       sets, therefore reducing the number of sets
--generalized-streett[=unique-fin|share-fin], --gsa[=unique-fin|share-fin]                                                          rewrite the
                       acceptance condition as generalized Streett; the
                       "share-fin" option allows clauses to share Fin
                       sets, therefore reducing the number of sets; the
                       default "unique-fin" does not
--instut[=1|2]         allow more stuttering (two possible algorithms)
--keep-states=NUM[,NUM...]   only keep specified states.  The first state
                       will be the new initial state.  Implies
                       --remove-unreachable-states.
--mask-acc=NUM[,NUM...]   remove all transitions in specified acceptance
                       sets
--merge-transitions    merge transitions with same destination and
                       acceptance
--product=FILENAME, --product-and=FILENAME
                       build the product with the automaton in FILENAME
                       to intersect languages
--product-or=FILENAME  build the product with the automaton in FILENAME
                       to sum languages
--randomize[=s|t]      randomize states and transitions (specify 's' or
                       't' to randomize only states or transitions)
--remove-ap=AP[=0|=1][,AP...]
                       remove atomic propositions either by existential
                       quantification, or by assigning them 0 or 1
--remove-dead-states   remove states that are unreachable, or that cannot
                       belong to an infinite path
--remove-fin           rewrite the automaton without using Fin acceptance

--remove-unreachable-states
                       remove states that are unreachable from the
                       initial state
--remove-unused-ap     remove declared atomic propositions that are not
                       used
--sat-minimize[=options]   minimize the automaton using a SAT solver
                       (only works for deterministic automata). Supported
                       options are acc=STRING, states=N, max-states=N,
                       sat-incr=N, sat-incr-steps=N, sat-langmap,
                       sat-naive, colored, preproc=N. Spot uses by
                       default its PicoSAT distribution but an external
                       SATsolver can be set thanks to the SPOT_SATSOLVER
                       environment variable(see spot-x).
--separate-sets        if both Inf(x) and Fin(x) appear in the acceptance
                       condition, replace Fin(x) by a new Fin(y) and
                       adjust the automaton
--simplify-acceptance  simplify the acceptance condition by merging
                       identical acceptance sets and by simplifying some
                       terms containing complementary sets
--simplify-exclusive-ap   if --exclusive-ap is used, assume those AP
                       groups are actually exclusive in the system to
                       simplify the expression of transition labels
                       (implies --merge-transitions)
--split-edges          split edges into transitions labeled by
                       conjunctions of all atomic propositions, so they
                       can be read as letters
--streett-like         convert to an automaton with Streett-like
                       acceptance. Works only with acceptance condition
                       in DNF
--strip-acceptance     remove the acceptance condition and all acceptance
                       sets
--sum=FILENAME, --sum-or=FILENAME
                       build the sum with the automaton in FILENAME to
                       sum languages
--sum-and=FILENAME     build the sum with the automaton in FILENAME to
                       intersect languages
</pre>
</div>
</div>

<div id="outline-container-orgaa4725f" class="outline-2">
<h2 id="orgaa4725f">Decorations</h2>
<div class="outline-text-2" id="text-orgaa4725f">
<p>
Decorations work by coloring some states or edges in the automaton.
They are only useful when the automaton is output in Dot format (with
<code>--dot</code> or <code>-d</code>) or HOA v1.1 format (with <code>-H1.1</code> or <code>--hoa=1.1</code>).
</p>

<pre class="example">
--highlight-accepting-run[=NUM]
                       highlight one accepting run using color NUM
--highlight-languages  highlight states that recognize identical
                       languages
--highlight-nondet[=NUM]   highlight nondeterministic states and edges
                       with color NUM
--highlight-nondet-edges[=NUM]
                       highlight nondeterministic edges with color NUM
--highlight-nondet-states[=NUM]
                       highlight nondeterministic states with color NUM
--highlight-word=[NUM,]WORD
                       highlight one run matching WORD using color NUM
</pre>

<p>
Color numbers are indices in some hard-coded color palette.  It is the
same palette that is currently used to display colored acceptance
sets, but this might change in the future.
</p>
</div>
</div>

<div id="outline-container-orgc814343" class="outline-2">
<h2 id="orgc814343">Examples</h2>
<div class="outline-text-2" id="text-orgc814343">
</div>
<div id="outline-container-org3f4a9a6" class="outline-3">
<h3 id="org3f4a9a6">Acceptance transformations</h3>
<div class="outline-text-3" id="text-org3f4a9a6">
<p>
Here is an automaton with transition-based acceptance:
</p>

<div class="org-src-container">
<pre class="src src-sh">cat &gt;aut-ex1.hoa&lt;&lt;EOF
<span class="org-sh-heredoc">HOA: v1</span>
<span class="org-sh-heredoc">States: 3</span>
<span class="org-sh-heredoc">Start: 0</span>
<span class="org-sh-heredoc">AP: 2 "a" "b"</span>
<span class="org-sh-heredoc">Acceptance: 4 Inf(0)&amp;Fin(1)&amp;Fin(3) | Inf(2)&amp;Inf(3) | Inf(1)</span>
<span class="org-sh-heredoc">--BODY--</span>
<span class="org-sh-heredoc">State: 0 {3}</span>
<span class="org-sh-heredoc">[t] 0</span>
<span class="org-sh-heredoc">[0] 1 {1}</span>
<span class="org-sh-heredoc">[!0] 2 {0}</span>
<span class="org-sh-heredoc">State: 1 {3}</span>
<span class="org-sh-heredoc">[1] 0</span>
<span class="org-sh-heredoc">[0&amp;1] 1 {0}</span>
<span class="org-sh-heredoc">[!0&amp;1] 2 {2}</span>
<span class="org-sh-heredoc">State: 2</span>
<span class="org-sh-heredoc">[!1] 0</span>
<span class="org-sh-heredoc">[0&amp;!1] 1 {0}</span>
<span class="org-sh-heredoc">[!0&amp;!1] 2 {0}</span>
<span class="org-sh-heredoc">--END--</span>
<span class="org-sh-heredoc">EOF</span>
</pre>
</div>

<p>
(Note: that the <code>--dot</code> option used below uses some default options
discussed <a href="oaut.html#default-dot">on another page</a>.)
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org0a0303d">autfilt aut-ex1.hoa --dot
</pre>
</div>


<div class="figure">
<p><object type="image/svg+xml" data="autfilt-ex1.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

<p>
Using <code>-S</code> will "push" the acceptance membership of the transitions to the states:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org104ceb2">autfilt -S aut-ex1.hoa --dot
</pre>
</div>


<div class="figure">
<p><object type="image/svg+xml" data="autfilt-ex2.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

<p>
Using <code>--cnf-acceptance</code> simply rewrites the acceptance condition in Conjunctive Normal Form:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org507f8cd">autfilt --cnf-acceptance aut-ex1.hoa --dot
</pre>
</div>


<div class="figure">
<p><object type="image/svg+xml" data="autfilt-ex3.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>


<p>
Using <code>--remove-fin</code> transforms the automaton to remove all traces
of Fin-acceptance: this usually requires adding non-deterministic jumps to
altered copies of strongly-connected components.
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org59cc5e3">autfilt --remove-fin aut-ex1.hoa --dot
</pre>
</div>


<div class="figure">
<p><object type="image/svg+xml" data="autfilt-ex4.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

<p>
Use <code>--mask-acc=NUM</code> to remove some acceptances sets and all
transitions they contain.  The acceptance condition will be updated to
reflect the fact that these sets can never be visited.
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org1bfc52e">autfilt --mask-acc=1,2 aut-ex1.hoa --dot
</pre>
</div>


<div class="figure">
<p><object type="image/svg+xml" data="autfilt-ex5.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>

<div id="outline-container-orgd79c9c9" class="outline-3">
<h3 id="orgd79c9c9">Atomic proposition removal</h3>
<div class="outline-text-3" id="text-orgd79c9c9">
<p>
Atomic propositions can be removed from an automaton in three ways:
</p>
<ul class="org-ul">
<li>use <code>--remove-ap=a</code> to remove <code>a</code> by existential quantification, i.e., both <code>a</code> and its negation will be replaced by true.
This does not remove any transition.</li>
<li>use <code>--remove-ap=a=0</code> to keep only transitions compatible with <code>!a</code> (i.e, transitions requiring <code>a</code> will be removed).</li>
<li>use <code>--remove-ap=a=1</code> to keep only transitions compatible with <code>a</code> (i.e, transitions requiring <code>!a</code> will be removed).</li>
</ul>

<p>
Here are the results of these three options on our example:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org6b35de6">autfilt --remove-ap=a aut-ex1.hoa --dot
</pre>
</div>


<div class="figure">
<p><object type="image/svg+xml" data="autfilt-ex6a.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

<div class="org-src-container">
<pre class="src src-sh" id="org271e4f1">autfilt --remove-ap=<span class="org-variable-name">a</span>=0 aut-ex1.hoa --dot
</pre>
</div>


<div class="figure">
<p><object type="image/svg+xml" data="autfilt-ex6b.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

<div class="org-src-container">
<pre class="src src-sh" id="orgbafb3b9">autfilt --remove-ap=<span class="org-variable-name">a</span>=1 aut-ex1.hoa --dot
</pre>
</div>


<div class="figure">
<p><object type="image/svg+xml" data="autfilt-ex6c.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>

<div id="outline-container-orgebbdc6f" class="outline-3">
<h3 id="orgebbdc6f">Testing word acceptance</h3>
<div class="outline-text-3" id="text-orgebbdc6f">
<p>
The following example checks whether the formula <code>a U b U c</code> accepts
the word <code>a&amp;!b&amp;!c; cycle{!a&amp;!b&amp;c}</code>.
</p>

<div class="org-src-container">
<pre class="src src-sh">ltl2tgba <span class="org-string">'a U b U c'</span> |
  autfilt --accept-word <span class="org-string">'a&amp;!b&amp;!c; cycle{!a&amp;!b&amp;c}'</span> -q  &amp;&amp; <span class="org-builtin">echo</span> <span class="org-string">"word accepted"</span>
</pre>
</div>
<pre class="example">
word accepted

</pre>

<p>
Here is an example where we generate an infinite stream of random LTL
formulas using <a href="randltl.html"><code>randltl</code></a>, convert them all to automata using
<a href="ltl2tgba.html"><code>ltl2tgba</code></a>, filter out the first 10 automata that accept both the
words <code>a&amp;!b;cycle{!a&amp;!b}</code> and <code>!a&amp;!b;cycle{a&amp;b}</code> yet reject any word
of the form <code>cycle{b}</code>, and display the associated formula (which was
stored as the name of the automaton by <code>ltl2tgba</code>).
</p>

<div class="org-src-container">
<pre class="src src-sh">randltl -n -1 a b | ltlfilt --simplify --uniq | ltl2tgba |
  autfilt --accept-word=<span class="org-string">'a&amp;!b;cycle{!a&amp;!b}'</span> --accept-word=<span class="org-string">'!a&amp;!b;cycle{a&amp;b}'</span> <span class="org-sh-escaped-newline">\</span>
          --reject-word=<span class="org-string">'cycle{b}'</span> --stats=%M -n 10
</pre>
</div>

<pre class="example">
F!b
!b
F(!a &amp; !b)
!a R !b
F(Fb R !b)
Fa R F!b
Fa U !b
!b &amp; X(!b W Ga)
Fb R F!b
XF!b U (!b &amp; (!a | G!b))
</pre>

<p>
Note that the above example could be simplified using the
<code>--accept-word</code> and <code>--reject-word</code> options of <code>ltlfilt</code> directly.
However this demonstrates that using <code>--stats=%M</code>, it is possible to
filter formulas based on some properties of automata that have been
generated by from them.  The translator needs not be <code>ltl2tgba</code>: other
tools can be wrapped with <a href="ltldo.html"><code>ltldo --name=%f</code></a> to ensure they work well
in a pipeline and preserve the formula name in the HOA output.  For
example Here is a list of 5 LTL formulas that <code>ltl2dstar</code> converts to
Rabin automata that have exactly 4 states:
</p>

<div class="org-src-container">
<pre class="src src-sh">randltl -n -1 a b | ltlfilt --simplify --remove-wm |
    ltldo ltl2dstar --name=%f | autfilt --states=4 --stats=%M -n 5
</pre>
</div>

<pre class="example">
Gb | G!b
b R (a | b)
(a &amp; !b &amp; (b | F(!b &amp; F!a))) | (!a &amp; (b | (!b &amp; G(b | Ga))))
(a &amp; (a U !b)) | (!a &amp; (!a R b))
a | G((a &amp; GFa) | (!a &amp; FG!a))

</pre>
</div>
</div>

<div id="outline-container-org46b713c" class="outline-3">
<h3 id="org46b713c">Decorations</h3>
<div class="outline-text-3" id="text-org46b713c">
<p>
We know from a previous exemple that formula <code>a U b U c</code> accepts the
word <code>b; cycle{c}</code>.  We can actually highlight the corresponding
run in the automaton:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org784ba7f">ltl2tgba <span class="org-string">'a U b U c'</span> | autfilt --highlight-word=<span class="org-string">'a&amp;!b&amp;!c; cycle{!a&amp;!b&amp;c}'</span> -d
</pre>
</div>


<div class="figure">
<p><object type="image/svg+xml" data="autfilt-hlword.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>


<p>
We can change the color by prefixing the word with a number and a
comma.  Also it is possible to highlight multiple words, but a
transition may only have one color so late highlights will overwrite
previous ones.
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org9ce1927">ltl2tgba <span class="org-string">'a U b U c'</span> |
  autfilt --highlight-word=5,<span class="org-string">'a&amp;!b&amp;!c; cycle{!a&amp;!b&amp;c}'</span> <span class="org-sh-escaped-newline">\</span>
          --highlight-word=4,<span class="org-string">'!a&amp;b&amp;!c; cycle{!a&amp;!b&amp;c}'</span> -d
</pre>
</div>


<div class="figure">
<p><object type="image/svg+xml" data="autfilt-hlword2.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>



<p>
Another useful thing to highlight is nondeterminism.  One can
highlight states or edges where nondeterministic choices need to be
made.
</p>

<div class="org-src-container">
<pre class="src src-sh" id="orgfe1f476">ltl2tgba <span class="org-string">'F((b R a) W Gb)'</span> |
    autfilt --highlight-nondet-states=5 --highlight-nondet-edges=1 -d
</pre>
</div>


<div class="figure">
<p><object type="image/svg+xml" data="autfilt-hlnondet.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>
</div>
</div>
</body>
</html>
